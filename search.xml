<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/article/2017/04/23/2017-04-23-hello-world/</url>
    <content><![CDATA[<p>刚用<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>主题搭建好博客框架! Hexo主题相关 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a>。</p>
<a id="more"></a>
<h2 id="常用步骤"><a href="#常用步骤" class="headerlink" title="常用步骤"></a>常用步骤</h2><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"文章名"</span></span><br></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="本地服务查看"><a href="#本地服务查看" class="headerlink" title="本地服务查看"></a>本地服务查看</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="生成静态站点文件"><a href="#生成静态站点文件" class="headerlink" title="生成静态站点文件"></a>生成静态站点文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="部署到站点"><a href="#部署到站点" class="headerlink" title="部署到站点"></a>部署到站点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">Documentation</a></p>
]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>生活杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>吉他谱收藏</title>
    <url>/article/2017/04/25/2017-04-25-%E5%90%89%E4%BB%96%E8%B0%B1%E6%94%B6%E8%97%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>收藏</category>
      </categories>
      <tags>
        <tag>吉他谱</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令mark</title>
    <url>/article/2017/04/29/2017-04-29-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4mark/</url>
    <content><![CDATA[<h1 id="安装-sogou-拼音输入法"><a href="#安装-sogou-拼音输入法" class="headerlink" title="安装 sogou 拼音输入法"></a>安装 sogou 拼音输入法</h1><p>在官网下载好deb安装包之后双击进入软件中心进行安装，或者使用命令安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -i *.deb</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>安装完成之后，在终端中输入<code>im-config</code> 进行配置，依次 OK-&gt;Yes之后查看其中选项是否选中的是 fcitx，若没有则到设置中心 language support 中将 ibus更改为 fcitx。之后重启linux。重启之后，一般情况下系统已经选择了sogou输入法，若没有，则在终端中输入<code>fcitx-config-gtk3</code>，在设置面板中增加 sogou输入法(将过滤条件取消)。</p>
</blockquote>
<h1 id="与windows-共生双系统下挂载只读磁盘"><a href="#与windows-共生双系统下挂载只读磁盘" class="headerlink" title="与windows 共生双系统下挂载只读磁盘"></a>与windows 共生双系统下挂载只读磁盘</h1><p>双系统机器上Linux中挂载属于windows系统的磁盘分区时，当该分区为保护分区时使用一般方法会挂载不上，可以通过只读方式挂载<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">udisksctl mount -p block_devices/sda4 -o ro</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>其中<code>-o ro</code>为只读</p>
</blockquote>
<h1 id="IP地址配置"><a href="#IP地址配置" class="headerlink" title="IP地址配置"></a>IP地址配置</h1><h2 id="临时指定IP地址（重启机器后失效）"><a href="#临时指定IP地址（重启机器后失效）" class="headerlink" title="临时指定IP地址（重启机器后失效）"></a>临时指定IP地址（重启机器后失效）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ifconfig eth0 192.168.1.111 netmask 255.255.255.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中‘eth0是当前网卡的名称’</p>
</blockquote>
<h2 id="固定静态IP地址配置（重启机器仍有效）"><a href="#固定静态IP地址配置（重启机器仍有效）" class="headerlink" title="固定静态IP地址配置（重启机器仍有效）"></a>固定静态IP地址配置（重启机器仍有效）</h2><p>编辑位于<code>/etc/network/interfaces</code>的配置文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim:</span><br><span class="line">	</span><br><span class="line">  1 # This file describes the network interfaces available on your system               </span><br><span class="line">  2 # and how to activate them. For more information, see interfaces(5).</span><br><span class="line">  3  </span><br><span class="line">  4 # The loopback network interface</span><br><span class="line">  5 auto lo</span><br><span class="line">  6 iface lo inet loopback</span><br><span class="line">  7  </span><br><span class="line">  8 # The primary network interface</span><br><span class="line">  9 auto eth0 # 当前网卡为‘eth0’</span><br><span class="line"> 10 iface eth0 inet static # 此处是由‘dhcp’更改为‘static’</span><br><span class="line"> 11 address 192.168.1.11 # 新的静态IP地址</span><br><span class="line"> 12 gateway 192.168.1.1 # 网关</span><br><span class="line"> 13 netmask 255.255.255.0 # 掩码</span><br><span class="line"> 14 broadcast 192.168.1.255 # 广播地址</span><br></pre></td></tr></table></figure></p>
<p>修改完成之后不要忘了重启网卡服务，当然你可以选择重启机器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/network restart</span><br></pre></td></tr></table></figure></p>
<h1 id="Ubuntu-Server-中文乱码解决方案"><a href="#Ubuntu-Server-中文乱码解决方案" class="headerlink" title="Ubuntu Server 中文乱码解决方案"></a>Ubuntu Server 中文乱码解决方案</h1><h2 id="乱码之-显示”-”"><a href="#乱码之-显示”-”" class="headerlink" title="乱码之 - 显示”???”"></a>乱码之 - 显示”???”</h2><p>1、安装中文支持包<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install language-pack-zh-hans</span><br></pre></td></tr></table></figure></p>
<p>2、修改<code>/etc/environment</code>在下面添加如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LANG=”zh_CN.UTF-8″</span><br><span class="line">LANGUAGE=”zh_CN:zh:en_US:en”</span><br></pre></td></tr></table></figure></p>
<p>3、修改<code>/var/lib/locales/supported.d/local</code>在下面添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">en_US.UTF-8 UTF-8</span><br><span class="line">zh_CN.UTF-8 UTF-8</span><br><span class="line">zh_CN.GBK GBK</span><br><span class="line">zh_CN GB2312</span><br></pre></td></tr></table></figure></p>
<p>4、保存后，执行以下命令使配置生效<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo locale-gen</span><br></pre></td></tr></table></figure></p>
<h2 id="乱码之-中文显示空格"><a href="#乱码之-中文显示空格" class="headerlink" title="乱码之 - 中文显示空格"></a>乱码之 - 中文显示空格</h2><p>Ubuntu Server自己安装桌面环境，xface，kde，接着chrome，发现chrome浏览器中的中文都显示成”□”，不是一般的乱码啊，这分明就是没有对应的字体嘛，于是赶紧安装起来，发现有下面几个就够用了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fonts-droid</span><br><span class="line">ttf-wqy-zenhei</span><br><span class="line">ttf-wqy-microhei</span><br><span class="line">fonts-arphic-ukai</span><br><span class="line">fonts-arphic-uming</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用以下命令就是了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fonts-droid ttf-wqy-zenhei ttf-wqy-	microhei fonts-arphic-ukai fonts-arphic-uming</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>sogou</tag>
        <tag>静态IP</tag>
        <tag>udisksctl</tag>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux交换分区管理</title>
    <url>/article/2017/04/27/2017-04-27-Linux%E4%BA%A4%E6%8D%A2%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>交换区是对物理内存的逻辑扩充。在linux中，一般在安装os的时候会分配交换分区，也就是使用独立的分区。当在os使用过程中，需要再增加交换区大小的时候，若不能创建新的分区，一般会使用作为交换设备。</p>
<a id="more"></a>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>首先，在home目录下创建一个名为swap的文件夹并进入，创建指定大小的连续的一个文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dd if=/dev/zero of=./swap_myadd bs=1M count=1024</span><br></pre></td></tr></table></figure></p>
<p>以上命令只为创建一个连续的，空的，大小为1G的文件，以备作为交换区的文件使用。我们都知道，<code>dd</code>命令是用来复制文件的，其中，<code>if</code>即输入源，<code>of</code>为输出目标。</p>
<blockquote>
<p>这里，使用到了<code>/dev/zero</code>这个文件，通过查看可知：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leo@box:/dev$ ll |grep zero</span><br><span class="line">crw-rw-rw-   1 root root      1,   5 Mar 20 12:42 zero</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>关于<code>/dev/zero</code>是什么东西，查看 <a href="http://blog.sina.com.cn/s/blog_588c88cb0100xq3h.html" target="_blank" rel="noopener">Linux中 /dev/zero和/dev/null 是什么</a>，反正是一个字符设备。</p>
</blockquote>
<h2 id="构建交换设备"><a href="#构建交换设备" class="headerlink" title="构建交换设备"></a>构建交换设备</h2><p>将创建好的文件构建为一个交换设备<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkswap ./swap_myadd 1024000</span><br></pre></td></tr></table></figure></p>
<h2 id="激活交换设备"><a href="#激活交换设备" class="headerlink" title="激活交换设备"></a>激活交换设备</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo swapon /dev/swap_myadd</span><br></pre></td></tr></table></figure>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leo@box:/dev$ cat /proc/swaps</span><br><span class="line">Filename				  	Type		Size	Used	Priority</span><br><span class="line">/dev/sda5                   partition	2095100	0	    -1</span><br><span class="line">/home/leo/swap/swap_myadd   file		1048572	0	    -2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>swap</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows个性化</title>
    <url>/article/2017/04/29/2017-04-29-Windows%E4%B8%AA%E6%80%A7%E5%8C%96/</url>
    <content><![CDATA[<p>作为一名windows重度用户，娱乐工作几乎都在windows操作系统下度过，又不舍得有些linux操作系统中令人难以割爱的操作，需要对windows”私人订制”一下，Just for fun.</p>
<a id="more"></a>
<h4 id="Cygwin中文乱码"><a href="#Cygwin中文乱码" class="headerlink" title="Cygwin中文乱码"></a>Cygwin中文乱码</h4><p>(Windows10)在cygwin的终端里配置Options时，无论怎么配置，总是出现要么显示系统文件名（ls等命令）的中文出现乱码，要么使用系统打印命令（ipconfig等命令）的中文输出乱码。最终得到如下的解决方案，在用户家目录下的<code>.bash_profile</code>文件后面添加如下配置：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LC_CTYPE=zh_CN.GBK</span><br><span class="line"><span class="built_in">export</span> LANG=zh_CN.GBK</span><br><span class="line"><span class="built_in">export</span> OUTPUT_CHARSET=GBK</span><br><span class="line"><span class="built_in">export</span> LESSCHARSET=latin1</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>也可以将cygwin的home目录指定到windows中的用户主目录下,将cgwin中<code>/home/{User}</code>路径下的文件剪切到windows的用户目录下(备份已有的cygwin内容)，删除cygwin中的<code>/home/{User}</code>目录。使用<code>ln</code>创建软连接将windows下的用户目录链接到cygwin下的<code>/home/{user}</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s /cygdrive/c/User/&#123;user&#125; /home/&#123;user&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="ls等命令高亮"><a href="#ls等命令高亮" class="headerlink" title="ls等命令高亮"></a><strong>ls等命令高亮</strong></h4><p>还是用户家目录，在文件<code>.bashrc</code>中对已有的配置进行修改，将已注释掉的相关别名全部打开，其他的别名也可根据自己的需要开放。<br>如ls相关命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Default to human readable figures</span><br><span class="line">alias df=&apos;df -h&apos;</span><br><span class="line">alias du=&apos;du -h&apos;</span><br><span class="line"></span><br><span class="line"># Misc :)</span><br><span class="line">alias less=&apos;less -r&apos;                          # raw control characters</span><br><span class="line">alias whence=&apos;type -a&apos;                        # where, of a sort</span><br><span class="line">alias grep=&apos;grep --color&apos;                     # show differences in colour</span><br><span class="line">alias egrep=&apos;egrep --color=auto&apos;              # show differences in colour</span><br><span class="line">alias fgrep=&apos;fgrep --color=auto&apos;              # show differences in colour</span><br><span class="line"></span><br><span class="line"># Some shortcuts for different directory listings</span><br><span class="line">alias ls=&apos;ls -hF --color=tty&apos;                 # classify files in colour</span><br><span class="line">alias dir=&apos;ls --color=auto --format=vertical&apos;</span><br><span class="line">alias vdir=&apos;ls --color=auto --format=long&apos;</span><br><span class="line">alias ll=&apos;ls -l&apos;                              # long list</span><br><span class="line">alias la=&apos;ls -A&apos;                              # all but . and ..</span><br><span class="line">alias l=&apos;ls -CF&apos;                              #</span><br></pre></td></tr></table></figure></p>
<h4 id="改变系统编辑框颜色"><a href="#改变系统编辑框颜色" class="headerlink" title="改变系统编辑框颜色"></a><strong>改变系统编辑框颜色</strong></h4><p>偏爱豆绿色，因为护眼。运行中输入regedit，进入注册表编辑器<br><img src="/images/coding/20160412172846019.jpg" alt="打开注册表"></p>
<p>修改<code>HKEY_CURRENT_USER/Control Panel/Colors</code>和<code>HKEY_CURRENT_USER/Control Panel/Desktops/Colors</code>下的Windows的值为“204 238 208”。</p>
<p><img src="/images/coding/20160412172700034.jpg" alt="编辑HKEY_CURRENT_USER/Control Panel/Colors/Windows的值"><br><strong> 若只完成以上步骤，休眠唤醒后仍会失效，再修改以下项成对应的十六进制颜色编码 </strong><br><img src="/images/coding/20161022233424795.jpg" alt="十六进制颜色代码为`cceece`"><br>即<code>\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes\DefaultColors\Standard</code>项下的<code>Windows</code>的值设置为<code>cceece</code>。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>豆绿色</tag>
        <tag>cgwin</tag>
      </tags>
  </entry>
  <entry>
    <title>《父子》——影评</title>
    <url>/article/2017/05/05/2017-05-05-%E3%80%8A%E7%88%B6%E5%AD%90%E3%80%8B%E2%80%94%E2%80%94%E5%BD%B1%E8%AF%84/</url>
    <content><![CDATA[<p>一部作品，好与坏，不可能满足每一位观众。我只希望，您能自己从中找到一些有意义或难以忘怀的东西。若本片到最后能令您有所感触，我希望那不是伤感的沉溺，而是清醒的感动。                 —— 谭家明<br><a id="more"></a></p>
<p>片名《父子》，很容易让人联想到这是一部亲情篇，事实也是如此，但本片很好的利用了亲情这一入口探讨了平凡生活中各个角色的心理，细致的描绘了一幅市井人生的心理分析。父亲这个角色在这个父系社会的很多人眼中都应该是家里的顶梁柱，是一个家的象征，父亲是什么样子，这个家就是什么样子。其实，所有已为人父的人都应该值得尊敬，他们从男孩变成男人，这中间成长的过程的变化是巨大的，当你是男孩的时候，可以放肆的享受来自父母的庇佑，所需的物品可以毫无条件的索取，所犯的过错也能理所当然的被原谅。可是一旦成为了父亲，你就成了需要满足那个可以毫无条件索取，宽容地去原谅或者承担你孩子犯下的所有过错，还有提供给你身后女人的安全感，父亲的伟大正因如此。</p>
<p>在我国，婚姻几乎就是区分男孩与男人的标识，一纸红书（结婚证）将两个人绑定为一个家，父亲是户主，这个蓝本本（户口本）上的所有成员都是父亲需要保护的人，这是一件很光荣也很艰巨的使命。影片中的父亲阿胜或许在很多观影人看来都是一个没有一家之主的意识，又拥有强烈的大男子主义的一个人，更多的会倾向于同情阿莲和他们的儿子阿宝。阿宝当时在读小学，在故事的开头就铺垫当时的阿宝并不是一个十分成熟的小孩子，性格上的软弱更多的是趋近于他母亲阿莲，软弱的性格在大男子主义父亲的阴郁下等显得孤苦飘零，面对母亲的离家出走前反常的举动，阿宝有明显的感觉，这更突显阿莲的离家出走是一件理所当然的事情，家庭的分崩离析，受伤的往往是孩子，海报中手拿风车坐在伟岸的父亲骑着的自行车上，那是阿宝梦境中的场景，然而现实是父亲的颓废模样和母亲泪眼涟涟的样子，阿宝的眼神中更多的是落寞无助。</p>
<p>影片描述的父亲这个角色只聚焦在主角阿胜身上，阿胜是一个平凡的浪子，抽烟、打女人、收入不稳定、花钱大手大脚，一个没有担当和责任感却一贯蛮横的性情，此类男人在生活中貌似不多见却又到处可见踪迹。正片从阿莲收拾行李准备离家出走时开始，之前并未交代阿莲为什么想要离家出走，却在阿胜拦住阿莲的离家出走之时的行为可见一斑。“我对你不好吗，你为什么要走？”往往也是很多人自信却不自知的道理。之后短暂的交谈交代了家庭的组成，阿莲和阿胜没有结婚，阿宝也许只是他们冲动下的结果，却也是这样没有保障婚姻的受难者。有了离家出走的念头，虽然被拦住了，但欲望却愈加强烈，终于在父子的出游中阿莲离开了这个没有能给她安全感的“家”，走得决绝，即使要她抛弃她爱着的儿子阿宝。有意思的是，阿莲跟人走的那人和阿胜是同一个演员（郭富城），虽然片中并未对富人的“阿胜”有太多的描述，大抵是交代其是一个有稳定收入的比主角“父亲”更值得托付的“第三者”，与脾气暴躁、性格懦弱、衣着邋遢、动作粗鲁、满嘴脏话的阿胜形成鲜明对比。不出意料，发现老婆离家出走的阿胜发了狂也慌了神，到邻居家询问，到酒吧（阿莲之前工作的地方）追问。“我要是阿莲，我也肯定跟别人走了”老板娘如是说，虽然无意间吐露，却也表明了阿莲其实对自己生活的不满已经渗透到工作中，其不满程度已经无法再压制，却又能得到同是女人的认可。面对老板娘强硬的回答，阿胜纵然暴躁却无可奈何，“我又不是吓大的”话一出，阿胜语气便弱下去了，由此可见阿胜只是外强中干。自从阿莲离开，本来就勉强支持的家庭更加没有了依靠，母亲的离家出走，最痛苦的就是还是孩子的阿宝，同时叙事的主线从阿莲的心理活动转移到阿宝的日常生活。没钱的时候作为父亲的阿胜与妓女合作诈骗富人老头，怂恿阿宝偷走同学（邻居）小胖的存钱罐，到后来让阿宝入陌生人家里偷东西，却在被抓现行的时候瞬间开溜，留下阿宝一人独自承担，更是将一个没有父亲担当的角色刻画得更加丑陋。终于在阿胜探望入狱后的阿宝时，阿宝再也忍受不了这个没有带给他“父爱”的父亲，咬下了父亲的耳朵，痛苦和纠结在那一刻爆发，没有更多的描述，交杂着血和泪的画面总能给人强烈的冲击，似乎整部影片对父亲的不满也在这一刻爆发，也许大快人心。十多年后阿宝将多年前偷走的手表赎了回来并还了回去，坦然交代“这只表是别人的，我偷别人的”，算是给过去犯下的错道歉，脸上不再有童年时候的茫然和怯懦，多了一份阳光和淡然，像是饱受摧残却依然绽放的太阳花，那么阳光，透露这一层光亮。剧的结尾，深受儿子唾弃的父亲走入深塘，看似是轻生，在阿宝探望隔壁阿姨的时候阿姨说阿胜结了婚，生活过的也还好，可见当初的浪子终于回了头，也算是给影片给了一个看似还不错的结尾。</p>
<p>片名《父子》，描述的不只是孩子的成长，更是一个父亲的成长，人总是在顺境中颓废和消亡，却在逆境和刺激后成长。</p>
<p>观影指南：<a href="http://www.iqiyi.com/v_19rrj5vnok.html" title="爱奇艺" target="_blank" rel="noopener">《父子》</a></p>
]]></content>
      <categories>
        <category>影评</category>
      </categories>
      <tags>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下sublime-text无法输入中文解决方案</title>
    <url>/article/2017/05/07/2017-05-07-Linux%E4%B8%8Bsublime-text%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>在Ubunutu14.04或相近版本中的linux系统Unity桌面环境下出现sublime-text编辑器使用输入法无法输入中文的情况，从别人那借来的偏方，mark一下。</p>
<a id="more"></a>
<h2 id="google别人的方法"><a href="#google别人的方法" class="headerlink" title="google别人的方法"></a>google别人的方法</h2><p>别人的解决方案 <a href="http://my.oschina.net/tsl0922/blog/113495?p=4#comments" target="_blank" rel="noopener">http://my.oschina.net/tsl0922/blog/113495?p=4#comments</a>， 按照这上面的方法执行是完全没有问题的，亲测哟。<br>    <strong>总结如下：</strong><br> (编译好的<figure class="highlight plain"><figcaption><span>'百度云分享') ，Ubuntu_14.04 _x64)</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">将程序入口文件（一般位于```/usr/bin/``` 下的```subl``` 文件）的配置信息修改为如下：</span><br></pre></td></tr></table></figure></p>
<p>  1 #!/bin/sh<br>  2<br>  3 SUBLIME_HOME=”/opt/sublime_text”<br>  4 LD_LIB=$SUBLIME_HOME/libsublime-imfix.so<br>  5<br>  6 sh -c “LD_PRELOAD=$LD_LIB $SUBLIME_HOME/sublime_text $@”<br>  7 # exec /opt/sublime_text/sublime_text “$@”</p>
<p><code>`</code></p>
<h2 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h2><p>最简单的方法莫过于用别人已经整理好的东西，呵呵哒。一下是我将上一方法中编译好的 <code>.so</code> 文件放进安装包中，<a href="http://pan.baidu.com/s/1mceom" title="百度云共享" target="_blank" rel="noopener">下载链接</a>，懒得编译的童鞋可以将该安装包直接解压，执行 <code>subl</code> 直接使用。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Sublime-text</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下无法挂载U盘设备</title>
    <url>/article/2017/05/13/2017-05-13-Ubuntu%E4%B8%8B%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BDU%E7%9B%98%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<p>Ubuntu14.04下默认是无法挂在U盘设备，或者手机存储卡的，错误提示：<br>mount：未知文件系统类型“exfat”<br><a id="more"></a></p>
<p>解决的方法是需要安装exfat磁盘格式工具：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install exfat-utils</span><br></pre></td></tr></table></figure></p>
<p>安装好之后重新插拔一下U盘设备或者手机就行了。</p>
<h2 id="更早版本的Ubuntu，如12-04、13-10等依次执行"><a href="#更早版本的Ubuntu，如12-04、13-10等依次执行" class="headerlink" title="更早版本的Ubuntu，如12.04、13.10等依次执行"></a>更早版本的Ubuntu，如12.04、13.10等依次执行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:relan/exfat</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install exfat-utils fuse-exfat</span><br></pre></td></tr></table></figure>
<p>安装好之后，重新插拔一下U盘设备或者手机，若还是不行，重启电脑即可</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的goto</title>
    <url>/article/2017/05/18/2017-05-18-Java%E4%B8%AD%E7%9A%84goto/</url>
    <content><![CDATA[<p><code>goto</code>是java中的保留字，确不是java中的关键字，这一点很多人都知道，为什么不用<code>goto</code>是因为对大多数人而言，用好<code>goto</code>很难，如果使用不当，会使代码的逻辑变得很混乱，故在java中未明确使用<code>goto</code>关键字，主要是希望开发人员能够谨慎使用。但同时，在java中，<code>goto</code>完全可以通过带标签的<code>continue</code>、<code>break</code>关键字实现。</p>
<a id="more"></a>
<p>虽然没有<code>goto</code>关键字，但在使用到goto的场景还是非常丰富的，譬如在<code>java.util.Collections</code>中：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List&lt;?&gt; source, List&lt;?&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sourceSize = source.size();</span><br><span class="line">    <span class="keyword">int</span> targetSize = target.size();</span><br><span class="line">    <span class="keyword">int</span> maxCandidate = sourceSize - targetSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceSize &lt; INDEXOFSUBLIST_THRESHOLD ||</span><br><span class="line">        (source <span class="keyword">instanceof</span> RandomAccess&amp;&amp;target <span class="keyword">instanceof</span> RandomAccess)) &#123;</span><br><span class="line">    nextCand:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candidate = <span class="number">0</span>; candidate &lt;= maxCandidate; candidate++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=candidate; i&lt;targetSize; i++, j++)</span><br><span class="line">                <span class="keyword">if</span> (!eq(target.get(i), source.get(j)))</span><br><span class="line">                    <span class="keyword">continue</span> nextCand;  <span class="comment">// Element mismatch, try next cand</span></span><br><span class="line">            <span class="keyword">return</span> candidate;  <span class="comment">// All elements of candidate matched target</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// Iterator version of above algorithm</span></span><br><span class="line">        ListIterator&lt;?&gt; si = source.listIterator();</span><br><span class="line">    nextCand:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candidate = <span class="number">0</span>; candidate &lt;= maxCandidate; candidate++) &#123;</span><br><span class="line">            ListIterator&lt;?&gt; ti = target.listIterator();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;targetSize; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!eq(ti.next(), si.next())) &#123;</span><br><span class="line">                    <span class="comment">// Back up source iterator to next candidate</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">                        si.previous();</span><br><span class="line">                    <span class="keyword">continue</span> nextCand;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// No candidate matched the target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在获取List中子List所在的起始位置时，其中使用到的<code>continue</code>加label的方式，能够通过更简洁的代码以实现。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>goto</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下boot/grub/i386-pc/normal.mod未找到问题</title>
    <url>/article/2017/05/27/2017-05-27-Linux%E4%B8%8Bboot-grub-i386-pc-normal-mod%E6%9C%AA%E6%89%BE%E5%88%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>启动linux系统时屏幕提示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: file ‘boot/grub/i386-pc/normal.mod’ not found</span><br><span class="line">Entering rescue mode…</span><br></pre></td></tr></table></figure></p>
<p>windows10和Ubuntu双系统，今天进入Ubuntu的时候出错，显示这个信息，顿时头大。 </p>
<a id="more"></a>
<p>搜索了解到引起这个问题的原因硬盘分区出现错误，回想一下，原来再windows10下，我刚将一个分区删除了。。。 -_-||</p>
<p>解决方法：</p>
<p>1、使用 <code>ls</code> 命令查看当前的分区情况，结果如下（各有不同）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(hd0) (hd0, msdos6) (hd0, msdos5) (hd0, msdos3) (hd0, msdos2) (hd0, msdos1) (hd0, msdos0)</span><br></pre></td></tr></table></figure></p>
<p>2、使用 <code>ls (hd0, msdos6)/boot/grub</code> 也就是从左边开始有 <code>msdos×</code>字样的分区开始查找，<strong>也就是查找grub所在的分区</strong>，当显示的结果不再是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: unkonwn filesystem.</span><br></pre></td></tr></table></figure></p>
<p>也就说，当结果显示的是文件夹下面是一些文件目录的时候，譬如我的是在 <code>ls (hd0,msdos2)/boot/grub</code>的时候出现的，则依次使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set boot=(hd0,msdos2)/boot/grub </span><br><span class="line">set prefix=(hd0,msdos2)/boot/grub </span><br><span class="line">insmod normal </span><br><span class="line">normal</span><br></pre></td></tr></table></figure></p>
<p>在 <code>normal</code>执行完成后就会进入熟悉系的统列表了。</p>
<blockquote>
<p>注：<br><code>set</code>设置环境变量<br><code>ls</code>查看目录<br><code>insmod</code>加载模块<br><code>normal</code>普通模式<br><code>root</code>制定引导，即grub所在的安装的系统所在的分区<br><code>prefix</code>设定grub配置文件和启动路径</p>
</blockquote>
<p>重启后发现还是会出现一样的情况，在使用以上方法进入 Ubuntu系统下之后，执行以下步骤：</p>
<p>1、在liveCD模式进入UBUNTU，插入光盘，选择try ubuntu就是。安装Boot-Repair，首先指定一个软件仓库（这里没资源，用别人的）<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:yannubuntu/boot-repair</span><br></pre></td></tr></table></figure></p>
<p>2、更新本地列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p>
<p>3、安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y boot-repair</span><br></pre></td></tr></table></figure></p>
<p>4、执行修复命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boot-repair</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Grub</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop学习笔记-Hadoop HDFS环境搭建</title>
    <url>/article/2017/06/17/2017-06-17-Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Hadoop-HDFS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>HDFS初入环境搭建过程日志<br><a id="more"></a></p>
<h3 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h3><p>1、JDK下载： <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" title="官网下载jdk" target="_blank" rel="noopener">下载链接</a><br>2、hadoop： <a href="http://hadoop.apache.org/releases.html" title="官网下载hadoop" target="_blank" rel="noopener">下载链接</a><br>3、下载完成后验证一下下载，将计算的MD5值与官网的进行对比已验证安装包的准确性：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">md5sum ./hadoop-2.6.*.tar.gz | tr &quot;a-z&quot; &quot;A-Z&quot; # 计算md5值，并转化为大写，方便比较</span><br></pre></td></tr></table></figure></p>
<h3 id="创建Hadoop用户"><a href="#创建Hadoop用户" class="headerlink" title="创建Hadoop用户"></a>创建Hadoop用户</h3><p>创建hadoop用户，并分配以用户名为家目录<code>/home/hadoop</code>，并将其加入到<code>sudo</code>用户组，创建好用户之后，以hadoop用户登录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo useradd -m hadoop -s /bin/bash</span><br><span class="line">sudo adduser hadoop sudo</span><br><span class="line">sudo passwd hadoop # 设置hadoop用户密码</span><br></pre></td></tr></table></figure></p>
<h3 id="安装JDK、Hadoop及配置环境变量"><a href="#安装JDK、Hadoop及配置环境变量" class="headerlink" title="安装JDK、Hadoop及配置环境变量"></a>安装JDK、Hadoop及配置环境变量</h3><p>安装，解压JDK到<code>/usr/lib/java/</code>路径下，Hadoop到<code>/usr/local/etc/hadoop/</code>路径下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxf ./hadoop-2.6.*.tar.gz </span><br><span class="line">mv ./hadoop-2.6.* /usr/<span class="built_in">local</span>/etc/hadoop <span class="comment"># 将 /usr/local/etc/hadoop作为Hadoop的安装路径</span></span><br></pre></td></tr></table></figure></p>
<p>解压完成之后，可验证hadoop的可用性：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/etc/hadoop</span><br><span class="line">./bin/hadoop version # 查看hadoop的版本信息</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意:</strong> 若在此处，会出现类似以下的错误信息，则很有可能是该安装包有问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error: Could not find or load main class org.apache.hadoop.util.VersionInfo</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>配置环境，编辑<code>/etc/profile</code>文件，在其后添加如下信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/local/etc/hadoop</span><br><span class="line">export JAVA_HOME=/usr/lib/java/jdk1.8.0_45</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$PATH:$&#123;JAVA_HOME&#125;/bin:$&#123;JRE_HOME&#125;/bin:$&#123;HADOOP_HOME&#125;/bin:$&#123;HADOOP_HOME&#125;/sbin</span><br></pre></td></tr></table></figure></p>
<p>使配置的变量生效：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>测试一下<br>在此我们可以运行一个简单的官方Demo：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd `echo $HADOOP_HOME` # 到hadoop安装路径</span><br><span class="line">mkdir ./input</span><br><span class="line">cp ./etc/hadoop/*.xml ./input</span><br><span class="line">hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep ./input ./output &apos;dfs[a-z.]+&apos;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>输出的结果应该会是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1   dfsadmin</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>这里有一点需要注意，该Example程序运行时不能已存在<code>output</code>目录，否则或将无法执行！</strong></p>
</blockquote>
<h3 id="Hadoop的伪分布式环境搭建"><a href="#Hadoop的伪分布式环境搭建" class="headerlink" title="Hadoop的伪分布式环境搭建"></a>Hadoop的伪分布式环境搭建</h3><p>什么是伪分布式？Hadoop 伪分布式模式是在一台机器上模拟Hadoop分布式，单机上的分布式并不是真正的分布式，而是使用线程模拟的分布式。分布式和伪分布式这两种配置也很相似，唯一不同的地方是伪分布式是在一台机器上配置，<strong>也就是名字节点（namenode）和数据节点（datanode）均是同一台机器</strong>。</p>
<p>需要配置的文件有<code>core-site.xml</code>和<code>hdfs-site.xml</code>这两个文件他们都位于<code>${HADOOP_HOME}/etc/hadoop/</code>文件夹下。<br>其中<code>core-site.xml</code>：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> 1 <span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"> 2 <span class="meta">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"> 3 <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 4   Licensed ...</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">18  </span><br><span class="line">19 <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">20   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">21     <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">22     <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/home/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">23     <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">24   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">25   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">26     <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">27     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">28   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">29 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>文件<code>hdfs-site.xml</code>的配置如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> 1 <span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"> 2 <span class="meta">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"> 3 <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 4   Licensed ...</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">18   </span><br><span class="line">19 <span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">20   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">21     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">22     <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">23   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">24   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">25     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">26     <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/home/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">27   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">28   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">29     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">30     <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/home/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">31   <span class="tag">&lt;/<span class="name">property</span>&gt;</span>                                                                          </span><br><span class="line">32 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>配置完成后，执行格式化命令，使HDFS将制定的目录进行格式化：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure></p>
<p>若格式化成功，在临近输出的结尾部分可看到如下信息：<br><img src="/images/coding/20160116232649800.jpg" alt="格式化后的输出信息" title="格式化后的输出信息"></p>
<h3 id="启动HDFS"><a href="#启动HDFS" class="headerlink" title="启动HDFS"></a>启动HDFS</h3><p>启动HDFS的脚本位于Hadoop目录下的<code>sbin</code>文件夹中，即：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd `echo $HADOOP_HOME`</span><br><span class="line">./sbin/start-dfs.sh # 启动HDFS脚本</span><br></pre></td></tr></table></figure></p>
<p>在执行<code>start-dfs.sh</code>脚本启动HDFS时，可能出现类似如下的报错内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localhost: Error: JAVA_HOME is not set and could not be found.</span><br></pre></td></tr></table></figure></p>
<p>很明显，是<code>JAVA_HOME</code>没找到，这是因为在<code>hadoop-env.sh</code>脚本中有个<code>JAVA_HOME=${JAVA_HOME}</code>，所以只需将<code>${JAVA_HOME}</code>替换成你的JDK的路径即可解决：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $JAVA_HOME # /usr/lib/java/jdk1.*.*_**</span><br><span class="line">vim ./etc/hadoop/hadoop-env.sh # 将‘export JAVA_HOME=$&#123;JAVA_HOME&#125;’字段替换成‘export JAVA_HOME=/usr/lib/java/jdk1.*.*_**’即可</span><br></pre></td></tr></table></figure></p>
<p>再次执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`echo $HADOOP_HOME`/sbin/start-all.sh</span><br></pre></td></tr></table></figure></p>
<p>如果成功，应该会有如下输出：<br><img src="/images/coding/20160116232452136.jpg" alt="`echo $HADOOP_HOME`/sbin/start-dfs.sh 运行截图" title="`echo $HADOOP_HOME`/sbin/start-dfs.sh 运行截图"><br>也可以执行以下命令判断是否启动：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure></p>
<p>若已成功运行起来了，会有类似如下输出：<br><img src="/images/coding/20160116205801410.jpg" alt="判断是否成功运行执行命令“jps”输出结果" title="判断是否成功运行执行命令“jps”输出结果"><br>对了，初次执行貌似还有两次确认，输入“yes”即是。对应的启动，自然也有关闭咯：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`echo $HADOOP_HOME`/sbin/stop-dfs.sh</span><br></pre></td></tr></table></figure></p>
<p>当成功启动之后，可以在浏览器通过访问网址<a href="http://192.168.2.109:50070/" title="查看namenode和datanode的相关信息" target="_blank" rel="noopener">http://192.168.2.109:50070/</a><br><img src="/images/coding/20160116225516511.jpg" alt="http://192.168.2.109:50070/ 预览界面" title="http://192.168.2.109:50070/ 预览界面"></p>
<hr>
<h3 id="运行伪分布式实例"><a href="#运行伪分布式实例" class="headerlink" title="运行伪分布式实例"></a>运行伪分布式实例</h3><p>以上的“测试一下”只是使用的是本机的源生文件运行的测试Demo实例。既然搭建好了伪分布式的环境，那就使用分布式上存储（HDFS）的数据来进行一次Demo测试：</p>
<p>先将数据源搞定，也就是仿照“测试一下”中的Demo一样，新建一个文件夹作为数据源目录，并添加一些数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs dfs -mkdir /input # 这里的文件名必须要以‘/’开头，暂时只了解是hdfs是以绝对路径为基础，因为没有 ‘-cd’这样的命令支持 </span><br><span class="line">hdfs dfs -put `echo $HADOOP_HOME`/etc/hadoop/*.xml /input</span><br></pre></td></tr></table></figure></p>
<p>也可以查看此时新建的<code>input</code>目录里面有什么：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs dfs -ls /</span><br><span class="line">hdfs dfs -ls /input</span><br></pre></td></tr></table></figure></p>
<p>再次运行如之前运行的那个Demo<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop jar /usr/local/etc/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep /input /output &apos;dfs[a-z.]+&apos;</span><br></pre></td></tr></table></figure></p>
<p>可看见如下输出：<br><img src="/images/coding/20160117010042062.jpg" alt="执行以上命令后的输出末尾" title="执行以上命令后的输出末尾"><br>再次查看HDFS中的目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs dfs -ls /</span><br><span class="line">hdfs dfs -cat /output*</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/coding/20160117010530268.jpg" alt="查看运行结果的输出" title="查看运行结果的输出"></p>
<p>如此，该测试算式通过了。HDFS支持的操作<code>hdfs dfs -command</code>中的‘command’也可通过只键入<code>hdfs dfs</code>即可查看：<br><img src="/images/coding/20160117010914291.jpg" alt="查看帮助" title="查看帮助"><br><img src="/images/coding/20160117011001789.jpg" alt="查看帮助" title="查看帮助"></p>
<h3 id="Hadoop集群安装"><a href="#Hadoop集群安装" class="headerlink" title="Hadoop集群安装"></a>Hadoop集群安装</h3><p>关乎集群，必然需要各机器间能够通信，所以需配置使每台虚拟机的网卡连接方式为“桥接网卡”，并且他们的<strong>MAC地址一定不能有相同</strong>。配置集群所需的三台Linux虚拟机都运行在VirtualBox虚拟机上，既然已经配置好了一台的环境，可以使用virtualbox的复制功能，直接复制两台出来。<br>先关闭虚拟机，右键点击已配置好的那台Linux虚拟机，选择“复制”，<strong>在复制选项中一定要确认“初始化MAC地址”</strong>：<br><img src="/images/coding/20160117133242276.jpg" alt="复制虚拟机" title="复制虚拟机"></p>
<p><strong>配置master</strong><br>为便于区别master和slave，将作为master的主机名改为“master”，修改<code>/etc/hostname</code>文件，将里面以前的名称替换成“master”：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hostname</span><br></pre></td></tr></table></figure></p>
<p>修改<strong>master以及所有slave主机</strong>上的IP地址映射关系，添加master机器的IP以及slave机器的IP及对应的机器名称：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line"></span><br><span class="line">#vim: </span><br><span class="line">  8 192.168.2.109 master</span><br><span class="line">  9 192.168.2.119 slave01 # 对应的第一个slav主机的名称</span><br><span class="line"> 10 192.168.2.129 slave02 # 对应的第二个slav主机的名称</span><br></pre></td></tr></table></figure></p>
<p>修改完成之后重启一下虚拟机，重启之后验证一下是否能互相ping通：<br>master主机上ping所有：<br><img src="/images/coding/20160117155909395.jpg" alt="master ping all" title="master主机上的测试"><br>slave01主机上ping所有：<br><img src="/images/coding/20160117160149357.jpg" alt="slave01 ping all" title="slave主机上的测试"></p>
<blockquote>
<p><strong> 这里所使用的IP地址，最好配置成静态的IP，配置静态IP可参考  <a href="/article/2017/04/29/2017-04-29-Linux常用命令mark/" title="Ubuntu静态IP配置">配置静态IP地址</a> #IP地址配置 </strong></p>
</blockquote>
<h3 id="master配置SSH无密码登陆slave节点"><a href="#master配置SSH无密码登陆slave节点" class="headerlink" title="master配置SSH无密码登陆slave节点"></a>master配置SSH无密码登陆slave节点</h3><p>这个操作是要让master节点可以无需密码通过SSH登陆到各个slave节点上安装openssh-server，生成密钥，配置无密码登录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br><span class="line">cd ~ # 进入hadoop用户目录下</span><br><span class="line">mkdir .ssh &amp; cd ./.ssh # keygen存放的位置</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys # 加入授权</span><br></pre></td></tr></table></figure></p>
<p>然后将生成的密钥复制到其他的slave主机上，期间需要输入‘yes’确认传输和输入密码以认证身份：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp /home/hadoop/.ssh/id_rsa.pub hadoop@slave01:/home/hadoop</span><br><span class="line">scp /home/hadoop/.ssh/id_rsa.pub hadoop@slave02:/home/hadoop</span><br></pre></td></tr></table></figure></p>
<p>接着在各个slave节点上将ssh公钥加入授权：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir .ssh # 若是已经存在了，就先把它删掉</span><br><span class="line">cat id_rsa.pub &gt;&gt; ./.ssh/authorized_keys</span><br><span class="line">rm id_rsa.pub # 已使用</span><br></pre></td></tr></table></figure></p>
<p>执行完以上操作，便可测试一下在master上无密码ssh连接slave节点的主机了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh slave01</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/coding/20160117171607293.jpg" alt="无密码访问slave节点" title="无密码访问slave节点主机"></p>
<h3 id="配置集群-分布式环境"><a href="#配置集群-分布式环境" class="headerlink" title="配置集群/分布式环境"></a>配置集群/分布式环境</h3><p>配置分布式集群环境需对一下几个文件进行配置：</p>
<p>slaves： 文件 slaves，配置datanode的主机名，每行一个，默认为 localhost，所以在伪分布式配置时，节点即作为namenode也作为datanode。分布式配置可以保留localhost，也可以删掉，让master节点仅作为namenode使用。现配置两个slave则在该文件中编辑如下字段：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slave01</span><br><span class="line">slave02</span><br></pre></td></tr></table></figure></p>
<p>core-site.xml：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> 1 <span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"> 2 <span class="meta">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"> 3 <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 4   Licensed ...</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">18  </span><br><span class="line">19 <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">20   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">21     <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!-- Hadoop的默认临时文件存放路径 --&gt;</span></span><br><span class="line">22     <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/home/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">23     <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">24   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">25   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">26     <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!-- namenode的URI --&gt;</span></span><br><span class="line">27     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">28   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">29 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>hdfs-site.xml：<br> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> 1 <span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"> 2 <span class="meta">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"> 3 <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 4   Licensed ...</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">18  </span><br><span class="line">19 <span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">20   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">21     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!-- 数据节点个数 --&gt;</span></span><br><span class="line">22     <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">23   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">24   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">25     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!--namenode节点的namenode存储URL  --&gt;</span></span><br><span class="line">26     <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/home/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">27   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">28   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">29     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">30     <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/home/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">31   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">32   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">33     <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">34     <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">35   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">36 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>mapred-site.xml，该文件一开始为一个模版，所以先拷贝并重命名一份：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp etc/hadoop/mapred-site.xml.template etc/hadoop/mapred-site.xml</span><br></pre></td></tr></table></figure></p>
<p>vim:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> 1 <span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"> 2 <span class="meta">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"> 3 <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 4   Licensed </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">18  </span><br><span class="line">19 <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">20   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">21     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">22     <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">23   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">24   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">25     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">26     <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">27   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">28   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">29     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">30     <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">31   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">32 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>yarn-site.xml：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> 1 <span class="meta">&lt;?xml version="1.0"?&gt;</span>                                                               </span><br><span class="line"> 2 <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 3   Licensed ...</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">15 <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">16 <span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line">17   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">18     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">19     <span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">20   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">21   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">22     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">23     <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">24   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">25 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这些配置文件其他的相关配置可参考官方文档。配置好后，因为之前有跑过伪分布式模式，建议在切换到集群模式前先删除之前的临时文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd `echo $HADOOP_HOME`</span><br><span class="line">rm -rf ./tmp/</span><br><span class="line">rm -rf ./logs</span><br></pre></td></tr></table></figure></p>
<p>再将配置好的master上的<code>/usr/local/etc/hadoop</code>文件夹复制到各个节点上（也就是覆盖原来的slave节点上安装的hadoop）。<br>以上步骤完毕后，首次启动需要先在master节点执行namenode的格式化：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format # 首次运行需要执行初始化，之后并不需要</span><br></pre></td></tr></table></figure></p>
<p>接着可以启动hadoop了，启动需要在master节点上进行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd `echo $HADOOP_HOME/etc/hadoop`</span><br><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><img src="/images/coding/20160118214252612.jpg" alt="master执行结果" title="master执行结果"></p>
<p>再使用<code>jps</code>查看启动之后的状态：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/coding/20160118212247636.jpg" alt="启动HDFS集群" title="启动HDFS集群"><br>此时，到slave主机上查看(<code>jps</code>)状态，会发现：<br><img src="/images/coding/20160118212438188.jpg" alt="slave01状态" title="slave01状态"><br><img src="/images/coding/20160118212502012.jpg" alt="slave02状态" title="slave02状态"></p>
<blockquote>
<p><strong>缺少任一进程都表示出错。另外还需要在 master 节点上通过命令<code>hdfs dfsadmin -report -live</code>查看 datanode 是否正常启动，如果 Live datanodes 不为 0 ，则说明集群启动成功。例如在此配置了两个datanode，则这边一共有 2 个 datanodes：</strong><br><img src="/images/coding/20160118224803089.jpg" alt="查看启动的节点" title="查看启动的节点"><br>也可通过<a href="http://192.168.2.109:50070/dfshealth.html#tab-overview" title="http://192.168.2.109:50070" target="_blank" rel="noopener">http://192.168.2.109:50070</a><br><img src="/images/coding/20160118224932949.jpg" alt="web查看启动的节点" title="web页面查看启动的节点"><br><strong>如果发现并没有出现如上信息，则使用刷新节点命令进行刷新：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs dfsadmin -refreshNodes</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="HDFS集群实例测试"><a href="#HDFS集群实例测试" class="headerlink" title="HDFS集群实例测试"></a>HDFS集群实例测试</h3><p>依然是之前的那个示例，首先，创建一个数据源文件夹，并添加数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs dfs -mkdir /input</span><br><span class="line">hdfs dfs -put /usr/local/etc/hadoop/etc/hadoop/*.xml /input</span><br></pre></td></tr></table></figure></p>
<p>运行mapreduce示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop jar /usr/local/etc/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep /input /output &apos;dfs[a-z.]+&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="官方文档参考"><a href="#官方文档参考" class="headerlink" title="官方文档参考"></a>官方文档参考</h3><p><a href="https://hadoop.apache.org/docs" title="官方Hadoop文档" target="_blank" rel="noopener">官方文档参考</a></p>
<p><strong>holding…</strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>java</tag>
        <tag>Hadoop</tag>
        <tag>HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中常用数据结构-Collection</title>
    <url>/article/2017/06/06/2017-06-06-Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Collection/</url>
    <content><![CDATA[<p>java内置的数据结构中主要有Collection和Map两个接口实现的集合结构类，Collection用于存储数组形式的单一对象集合，Map使用Key-Value的键值对结构存储对象的集合。其中Collection结构下又主要有List, Set, Queue三种接口，如常用的ArrayList, LinkedList是List的主要实现，HashSet, TreeSet是Set的实现，PriorityQueue, ConcurrentLinkedQueue是Queue的实现，除此之外，BlockingQueue和Deque也是Queue的常用接口。（基于jdk1.8）</p>
<a id="more"></a>
<p><strong>Collection(interface)</strong><br><code>java.util.Collection</code>接口是集合类数据结构的根接口，改接口继承了<code>java.lang.Iterator</code>接口，即所有Collection的实现都是可枚举的。该接口具有的功能有：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(E)                              <span class="comment">// 向集合中添加一个E类型的元素</span></span><br><span class="line">addAll(Collection&lt;?&gt;)               <span class="comment">// 将一个集合中所有的元素添加到该集合中</span></span><br><span class="line">clear()                             <span class="comment">// 移除所有该集合中的元素</span></span><br><span class="line">contains(Object)                    <span class="comment">// 该集合中是否包含这个Object元素</span></span><br><span class="line">containsAll(Collection&lt;?&gt;)          <span class="comment">// 该集合中是否包含另一个集合中的所有元素</span></span><br><span class="line">isEmpty()                           <span class="comment">// 该集合元素数量是否为0</span></span><br><span class="line">iterator()                          <span class="comment">// 获取该集合的枚举对象</span></span><br><span class="line">remove(Object)                      <span class="comment">// 从该集合中移除Object元素,在字类型的实现中，常给出移除指定索引的元素和指定元素</span></span><br><span class="line">removeAll(Collection&lt;? extends E&gt;)  <span class="comment">// 从该集合中移除另一集合中的所有元素</span></span><br><span class="line">retainAll(Collection&lt;?&gt;)            <span class="comment">// 只保留该集合中包含在指定集合中的元素(可选操作)</span></span><br><span class="line">size()                              <span class="comment">// 获取该集合的元素个数</span></span><br><span class="line">toArray()                           <span class="comment">// 返回该集合的数组</span></span><br><span class="line">toArray(T[])                        <span class="comment">// 返回该集合的数组，如果T[]的长度大于或等于该集合的元素数量则将该集合复制到T[]这个数组中，T[]长度超出的部分置为null</span></span><br></pre></td></tr></table></figure></p>
<p>在jdk1.8中，增加了对集合的stream操作，且对interface中增加default关键字，对<code>java.util.Collection</code>接口拓展了以下方法，并使用default实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parallelStream()                    <span class="comment">// 返回一个并行流对象，并将此集合作为其源</span></span><br><span class="line">removeIf(Predicate&lt;? <span class="keyword">super</span> E&gt;)      <span class="comment">// 从该集合中移除满足该Predicate描述的元素</span></span><br><span class="line">spliterator()                       <span class="comment">// 从该集合中创建一个可分割迭代器(splitable iterator可分割迭代器)</span></span><br><span class="line">stream()                            <span class="comment">// 将这个集合作为源返回一个可序列的流</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/images/coding/jdk_collection_mind_map.png" alt="Collection接口" title="Collection类型接口及实现类型"></p>
<h2 id="List-interface"><a href="#List-interface" class="headerlink" title="List(interface)"></a>List(interface)</h2><p>一种有序的集合，使用这个接口可以精确地控制列表中每个元素被插入的位置。可以通过他们的整数索引(在列表中的位置)访问元素，并搜索列表中的元素。除Collection声明之外的主要功能有：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(<span class="keyword">int</span>, E)                             <span class="comment">// 将元素E添加到指定位置上</span></span><br><span class="line">addAll(<span class="keyword">int</span>, Collection&lt;? extends E&gt;)    <span class="comment">// 将另一集合插入到该集合的指定位置上</span></span><br><span class="line">get(<span class="keyword">int</span>)                                <span class="comment">// 获取该集合上指定位置的元素</span></span><br><span class="line">indexOf(Object)                         <span class="comment">// 获取元素Object在该集合上的位置</span></span><br><span class="line">lastIndexOf(Object)                     <span class="comment">// 获取元素Object在该集合上最后的位置</span></span><br><span class="line">listIterator()                          <span class="comment">// 返回一个列表迭代器</span></span><br><span class="line">listIterator(<span class="keyword">int</span>)                       <span class="comment">// 从指定位置开始返回一个列表迭代器</span></span><br><span class="line">set(<span class="keyword">int</span>, E)                             <span class="comment">// 设置该集合指定位置上元素的值</span></span><br><span class="line">subList(<span class="keyword">int</span>, <span class="keyword">int</span>)                       <span class="comment">// 返回截取集合的子集合</span></span><br><span class="line"></span><br><span class="line">replaceAll(UnaryOperator&lt;E&gt;)            <span class="comment">// 使用运算符(函数变换)覆盖原值</span></span><br><span class="line">sort(Comparator&lt;? <span class="keyword">super</span> E&gt;)             <span class="comment">// 使用外排序返回排序后的集合</span></span><br></pre></td></tr></table></figure></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList基于数组实现，可通过ArrayList()使用默认初始容量大小（10）, ArrayList(capacity)指定初始容量大小, ArrayList(Collection&lt;?&gt;)从另一个集合对象中赋值组装，三种方式构造一个实例。ArrayList可以指定初始容量大小，但是可以无限扩容（也有限制，毕竟记录容量大小的变量类型为int类型，即最大容量为<code>Integer.MAX_VALUE</code>），其扩容策略如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即当向集合中增加一个元素时，先通过<code>ensureCapacityInternal</code>方法判断，并必要时增加数组的容量。在<code>ensureCapacityInternal</code>中，<code>minCapacity</code>值为添加元素后数组允许的最小容量即<code>size+1</code>，当集合中的数组为空数组时，<code>minCapacity</code>重新赋值为默认容量与<code>minCapacity</code>的较大值（其实就是默认容量大小10），并在<code>ensureExplicitCapacity</code>中判断容量是否需要增加。通过<code>grow</code>方法可以看出，当集合中容量不够用时，即将当前容量扩容至当前容量的3/2倍（取整），如果此次增加元素后数组长度达到最大数组长度(<code>Integer.MAX_VALUE - 8</code>)，则直接将新的容量设置为<code>Integer.MAX_VALUE</code>，并将旧数组拷贝到新的大容量的数组中。</p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>ArrayList在插入元素的时候需要考虑是否扩容，如果需要减小集合的容量，则可通过<code>trimToSize()</code>方法将当前集合的容量设置为size大小。</li>
<li>ArrayList是非线程安全的集合。</li>
<li>使用遍历删除集合中的元素时，不应使用<code>for</code>, <code>while</code>的遍历方式进行元素的删除，应当使用迭代器<code>iterator()</code>去移除。</li>
<li>在明确集合的大小时，应当通过<code>new ArrayList&lt;&gt;(size)</code>手动指定集合的初始容量，而非完全依赖ArrayList的自动扩容去依次递增容量，降低数组赋值带来的额外开销。</li>
<li>ArrayList中的elementData是通过<code>transient</code>修饰的，但它却实现了Serializable接口，注意看它的<code>writeObject(ObjectOutputStream)</code>和<code>readObject(ObjectInputStream)</code>，使用<code>transient</code>修饰存储对象是为了只序列化有效的容量，以达到不浪费资源的目的。这点同样适用以下序数据结构列化的实现原因。</li>
</ul>
</blockquote>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector与ArrayList一样，是基于数组实现的集合类型，相对于ArrayList，Vector的所有公有方法都具有<code>synchronized</code>关键字，即Vecotr集合是线程安全的集合，可以通过<code>new Vector()</code>实例化一个默认容量大小的集合,<code>new Vector(int)</code>实例化一个指定容量大小的集合, <code>new Vector(int, int)</code>实例化一个指定容量大小，且指定其容量递增的大小, <code>new Vector(Collection&lt;? extends E&gt;)</code>从另一个集合中创建一个Vector集合。Vector除了是线程安全的集合外，与ArrayList相比，它的容量递增方案也不一样：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未指定容量的情况下，默认Vector的容量为10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与ArrayList一样，<code>minCapacity</code>值为<code>size+1</code>，当插入下一个元素导致容量不够的情况下，Vector将通过<code>grow</code>方法扩容，可以看出，如果未指定<code>capacityIncrement</code>的值(其默认值为0），扩容后他的容量将是原容量的2倍，如果指定<code>capacityIncrement</code>则Vector每次容量递增为指定的大小，这点比ArrayList更为灵活。</p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>Vector是线程安全的集合</li>
<li>鉴于在Vector元素超过容量的情况下，如果不指定<code>capacityIncrement</code>，则其扩容为原容量的两倍，故最好初始化Vector对象的时候应选择适当的扩容大小。</li>
<li>与ArrayList一致，在需要移除Vector中的元素的时候，应选择通过迭代器访问的方式移除元素，避免空指针异常。</li>
</ul>
</blockquote>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>Stark（栈）是Vector的子类，即Stack也是线程安全的集合，扩容方案也跟随Vector，不同的是，在实例化Stack的时候，并不提供指定扩容大小的构造声明。栈的使用有以下常用方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">push(E)         <span class="comment">// 入栈</span></span><br><span class="line">peek()          <span class="comment">// 获取栈顶元素</span></span><br><span class="line">pop()           <span class="comment">// 出栈(通过 peek()获取数组中最后一个元素，再将其删除)</span></span><br><span class="line">empty()         <span class="comment">// 判断是否为空</span></span><br><span class="line">search(Object)  <span class="comment">// 栈中查找(从栈顶开始查找, 即使用 lastIndexOf(Object))</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>Stack是线程安全的栈</li>
<li>Stack的声明不能指定其容量和扩容递增大小</li>
</ul>
</blockquote>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是基于双向链表的集合，不同于数组类型的集合，它是通过节点依次的链接以达到元素与元素关联成集合的目的。LinkedList中的节点为它的静态内部类<code>Node&lt;E&gt;</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出在LinkedList中的节点除了代表元素本身的<code>item</code>之外还有两个分别指向上一个元素(<code>prev</code>)和指向下一个元素(<code>next</code>)的引用。<br>LinkedList作为链表方式的实现具有在链表两端进行插入和删除操作，同时也能快速的在指定的位置插入和删除元素，LinkedList的常用操作有：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(E)                                  <span class="comment">// 将元素E包装为Node，追加到链表的最后一个</span></span><br><span class="line">add(<span class="keyword">int</span>, E)                             <span class="comment">// 将元素E包装为Node，插入到指定位置，包装好Node的prev指针指向该位置前一个元素，next指针指向原来在该位置的元素</span></span><br><span class="line">addAll(Collection&lt;? extends E&gt;)         <span class="comment">// 将另一集合中的元素包装为Node，并依个追加到链表后面</span></span><br><span class="line">addAll(<span class="keyword">int</span>, Collection&lt;? extends E&gt;)    <span class="comment">// 将另一集合中的元素包装为Node，并依个追加到指定位置后面</span></span><br><span class="line">addFirst(E)                             <span class="comment">// 将元素E包装为Node，追加到链表首部</span></span><br><span class="line">addLast(E)                              <span class="comment">// 同 add(E)</span></span><br><span class="line">offer(E)                                <span class="comment">// 同 add(E)</span></span><br><span class="line">offerFirst(E)                           <span class="comment">// 同 addFirst(E)</span></span><br><span class="line">offerLast(E)                            <span class="comment">// 同 addLast(E)</span></span><br><span class="line"></span><br><span class="line">remove()                                <span class="comment">// 移除链表首部第一个元素</span></span><br><span class="line">remove(<span class="keyword">int</span>)                             <span class="comment">// 移除指定位置的元素</span></span><br><span class="line">removeFirst()                           <span class="comment">// 同 remove()</span></span><br><span class="line">removeLast()                            <span class="comment">// 移除链表尾部的最后一个元素</span></span><br><span class="line">remove(Object)                          <span class="comment">// 从链表首部开始查找，移除指定元素(只移除一个)</span></span><br><span class="line">removeFirstOccurrence(Object)           <span class="comment">// 同 remove(Object)</span></span><br><span class="line">removeLastOccurrence(Object)            <span class="comment">// 从链表尾部开始查找，移除指定元素(只移除一个)</span></span><br><span class="line"></span><br><span class="line">getFirst()                              <span class="comment">// 获取链表首部第一个元素，当链表为空时，抛出NoSuchElementException异常</span></span><br><span class="line">getLast()                               <span class="comment">// 获取链表尾部最后一个元素，当链表为空时，抛出NoSuchElementException异常</span></span><br><span class="line">get(<span class="keyword">int</span>)                                <span class="comment">// 获取指定位置元素</span></span><br><span class="line"></span><br><span class="line">set(<span class="keyword">int</span>, E)                             <span class="comment">// 将指定位置的元素替换</span></span><br><span class="line"></span><br><span class="line">peek()                                  <span class="comment">// 获取链表首部第一个元素，当链表为空时，返回 null</span></span><br><span class="line">peekFirst()                             <span class="comment">// 同 peek()</span></span><br><span class="line">peekLast()                              <span class="comment">// 获取链表尾部最后一个元素，当链表为空时，返回 null</span></span><br><span class="line">element()                               <span class="comment">// 同 getFirst()</span></span><br><span class="line">poll()                                  <span class="comment">// 移除链表首部第一个元素，并返回其值，当链表为空时，返回 null</span></span><br><span class="line">pollFirst()                             <span class="comment">// 同 poll()</span></span><br><span class="line">pollLast()                              <span class="comment">// 移除链表尾部最后一个元素，并返回其值，当链表为空时，返回 null</span></span><br><span class="line"></span><br><span class="line">push(E)                                 <span class="comment">// 同 addFirst(E), 可以通过 push,pop操作实现栈的功能</span></span><br><span class="line">pop()                                   <span class="comment">// 同 removeFirst()</span></span><br><span class="line"></span><br><span class="line">descendingIterator()                    <span class="comment">// 返回从尾部到首部的迭代器</span></span><br><span class="line">listIterator(<span class="keyword">int</span>)                       <span class="comment">// 返回从首部到尾部的迭代器</span></span><br><span class="line">spliterator()                           <span class="comment">// 创建一个可分割迭代器(splitable iterator可分割迭代器)，当前元素指向首部元素</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>LinkedList是非线程安全的线性表</li>
<li>LinkedList是基于节点，通过<code>prev</code>, <code>next</code>指针链接元素实现的双向链表</li>
<li>获取LinkedList中的首部/尾部元素，如果不确定链表是否为空时，应使用<code>peek()</code>,<code>peekFirst()</code>,<code>peekLast()</code>获取，避免<code>NoSuchElementException</code></li>
</ul>
</blockquote>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList是<code>java.util.concurrent</code>包下的基于数组的List的实现，concurrent包是jdk在为多核CPU编程提供一套类库，关于concurrent包的介绍可以参考<a href="http://tutorials.jenkov.com/java-concurrency/index.html" title="java-concurrency" target="_blank" rel="noopener">http://tutorials.jenkov.com/</a>。故名思议，该集合是基于数组的方式通过复制实现的线程安全的集合，查看它的添加元素的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，每有一个元素插入，里面的存储数组都会被拷贝一份，并在目标数组中容量<code>+1</code>。</p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>每插入一个元素都会复制一遍旧数组,即写时复制，是个比较吃性能的动态数组。同时，插入元素时不往原存储容器中插入，而是copy一个新的容器，插入完成后再将容器的引用指向新容器，所以在读的时候，发现并没有给读操作加锁，是一种读写分离的实现。同样适用于CopyOnWriteArraySet。</li>
</ul>
</blockquote>
<h2 id="Set-interface"><a href="#Set-interface" class="headerlink" title="Set(interface)"></a>Set(interface)</h2><p>Set是一个不包含重复元素的集合的根接口</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet用来存储不包含重复元素的单一对象组成的集合，可以通过<code>new HashSet()</code>实例化一个默认容量(16)的集合，<code>new HashSet(int)</code>实例化一个指定初始容量大小集合，<code>new HashSet(int, float)</code>实例化一个指定容量和负荷系数，<code>new HashSet(Collection&lt;? extends E&gt;()</code>使用另一集合为源实例化一个默认容量，负荷系数为该集合的大小的2.33倍与16取较大值。底层的实现却是通过HashMap作为元素的存储对象，使用HashMap&lt;Key, Value&gt;的Key来存储元素，Value是一个空对象(<code>Object PRESENT = new Object()</code>)，因为HashMap是一个Key和Value都可以为null的map类型，故，当Set中插入null时，仅返回false，并不抛出异常:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet的add(E)实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HashSet在移除元素的时候，也是通过在map中移除掉对应的Entity，当移除的元素为null或者map中不存在该key值时，返回false：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet的remove(Object)实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时，由于HashSet是通过HashMap的Key存储数据，即它存储的数据是一个无序的集合，故jdk中并不能提供<code>get(index)</code>、<code>remove(index)</code>的方式访问HashSet中的元素，只能通过迭代器的方式访问：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet的迭代器就是HashMap中键的迭代结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>HashSet是非线程安全的(毕竟用来存储HashSet的数据结构HashMap也是非线性安全的)</li>
<li>HashSet中元素的访问需通过迭代器的方式访问，它的迭代器就是HashMap中的<code>map.keySet().iterator()</code></li>
</ul>
</blockquote>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>LinkedHashSet是HashSet的子类，除了初始容量及负荷系数的初始化上不一样之外，并没有其他的不同。</p>
<h3 id="SortedSet-interface-、NavigableSet-interface"><a href="#SortedSet-interface-、NavigableSet-interface" class="headerlink" title="SortedSet(interface)、NavigableSet(interface)"></a>SortedSet(interface)、NavigableSet(interface)</h3><p>故名思议，SortedSet是有序Set的接口，SortedSet提供以下方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">comparator()            <span class="comment">// 所有有序的Set都需要实现元素的比较器</span></span><br><span class="line">subSet(E, E)            <span class="comment">// 获取两元素之间的子集合</span></span><br><span class="line">headSet(E)              <span class="comment">// 获取该元素E之前的子集合(不包含E本身)</span></span><br><span class="line">tailSet(E)              <span class="comment">// 获取该元素E之后的子集合(包含E本身)</span></span><br><span class="line">first()                 <span class="comment">// 获取Set中的第一个元素</span></span><br><span class="line">last()                  <span class="comment">// 获取Set中的最后一个元素</span></span><br><span class="line"></span><br><span class="line">spliterator()           <span class="comment">// 在这个已排序的集合中创建一个可分割的迭代器</span></span><br></pre></td></tr></table></figure></p>
<p>NavigableSet是Sorted的拓展接口，集合的有序化之外，还增加了有序集合的可操作方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ceiling(E)              <span class="comment">// 返回该Set中大于或等于该元素E的最小元素(包含自身)</span></span><br><span class="line">descendingIterator()    <span class="comment">// 在这个Set中以降序返回一个迭代器</span></span><br><span class="line">descendingSet()         <span class="comment">// 返回该Set的倒序</span></span><br><span class="line">floor(E)                <span class="comment">// 返回该Set中小于或等于该元素E的最大元素(包含自身)</span></span><br><span class="line">higher(E)               <span class="comment">// 返回该Set中大于该元素E的最小元素(不包含自身)</span></span><br><span class="line">lower(E)                <span class="comment">// 返回该Set中小于该元素E的最大元素(不包含自身)</span></span><br><span class="line">pollFirst()             <span class="comment">// 检索并删除第一个元素(最小)，如果该Set为空，则返回null</span></span><br><span class="line">pollLast()              <span class="comment">// 检索并删除最后一个元素(最大)，如果该Set为空，则返回null</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>以上最小意为<code>comparator</code>排序规则中最小的那个</p>
</blockquote>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeMap是SortedMap的实现类，既然需要实现有序的不包含重复元素的集合，自然不能使用HashMap来存储元素，而是通过TreeMap作为元素的存储对象，与HashSet类似，TreeSet也是将元素存储在Map的Key中，Value为空对象。因为TreeMap中的Key不可为null值，故TreeSet中也不允许存储null值的元素。</p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>TreeSet是不允许插入null值的</li>
<li>TreeSet中元素的遍历只能通过iterator迭代</li>
</ul>
</blockquote>
<h4 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h4><p>ConcurrentSkipListSet是<code>java.util.concurrent</code>包下的有序不包含重复元素的集合的实现，基于有序的Map类型<code>ConcurrentSkipListMap</code>实现，除此之外与TreeSet并未有太多不同。</p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>有序的集合中都不能插入null值，因为null并不能调用元素对象中的<code>comparator()</code>方法。</li>
</ul>
</blockquote>
<h2 id="Queue-interface"><a href="#Queue-interface" class="headerlink" title="Queue(interface)"></a>Queue(interface)</h2><p>队列是用来保存待处理数据的集合，是一种先进先出(FIFO)的数据集合。接口提供的操作有：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(E)      <span class="comment">// 进队列(同offer())</span></span><br><span class="line">poll()      <span class="comment">// 出队列，获取并移除队列头元素，如果队列为空时返回 null</span></span><br><span class="line">element()   <span class="comment">// 获取队列头元素，当队列为空时抛出异常</span></span><br><span class="line">offer(E)    <span class="comment">// 如果可以在不违反容量限制的情况下立即将指定的元素插入到这个队列中。</span></span><br><span class="line">peek()      <span class="comment">// 获取队列头元素，当队列为空时返回 null</span></span><br><span class="line">remove()    <span class="comment">// 移除队列头元素，当队列为空时抛出异常</span></span><br></pre></td></tr></table></figure></p>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue是一个基于优先级的无界优先级队列，PriorityQueue是基于数组实现，其中有一个私有属性<code>private final Comparator&lt;? super E&gt; comparator;</code>，且通过<code>add(E)</code>方法的实现可以看出，该队列类型中的元素在每次有新元素插入的时候都会调用一次<code>siftUp(int, E)</code>，当有元素出队列时，调用<code>shftDown(int, E)</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 插入元素前队列的size</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 需要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 出队列元素的位置(poll()操作时k值为0)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 出队列元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上<code>siftUp(int, E)</code>,<code>siftDown(int, E)</code>的实现可以看出，元素的插入之后，siftUp操作并不是将队列中的元素进行排序，而只是在插入的元素放在队列的稍后端，siftDown操作也只是将数组中剩下的最小的元素放到队列头，这样点到即止的操作在非排序的情况下实现出队列的元素是队列已有元素的从小到大（即Priority）可以大大的节省排序带来的消耗。我们再看看它的扩容策略：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，如果插入一个元素，容量不够用的情况下，当前容量小于64时，容量已步长为2的方式递增，如果当前容量大于或等于64，容量增长为当前容量的3/2倍。</p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>队列中插入的元素不能为 null.</li>
<li>每次有元素插入都会部分调整且非排序，故PriorityQueue中的元素是无序存储的。</li>
<li>PriorityQueue并非先进先出类型的队列。</li>
</ul>
</blockquote>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>通过类名就知道，ConcurrentLinkedQueue是基于链接节点，是concurrent包下的队列实现，线程安全的无界队列，该队列遵循先进先出(FIFO)原则。在ConcurrentLinekdQueue中，没有<code>size</code>或<code>lenght</code>记录队列的大小，每次在通过<code>size()</code>获取该队列的大小的时候，都会遍历一次整个队列，统计该队列中元素的个数。可以通过<code>remove(Object)</code>移除队列中的元素，<code>peek()</code>获取队列头部的元素（进入队列最长时间的元素），通过<code>iterator()</code>遍历队列中的元素。</p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>ConcurrentLinkedQueue是线程安全的队列</li>
<li>ConcurrentLinkedQueue是遵循FIFO原则的队列</li>
</ul>
</blockquote>
<h3 id="BlockingQueue-interface"><a href="#BlockingQueue-interface" class="headerlink" title="BlockingQueue(interface)"></a>BlockingQueue(interface)</h3><p>BlockingQueue即阻塞队列，对队列的操作，会发生阻塞的情况有：</p>
<blockquote>
<p>1、当队列满的时候进行入队操作<br>2、当队列为空的时候进行出队操作<br>即当一个线程对该队列操作，遇到阻塞的情况，需要另一线程对该队列操作至该队列达到非阻塞状态，譬如追加元素到已满的队列，发生阻塞，需要另一线程对该队列执行出队操作，入队操作的线程才能跳出阻塞状态继续执行。通过以上特性，阻塞队列是线程安全的。BlockingQueue有以下常用操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(E)                              <span class="comment">// 入队，当队列处于阻塞状态，则等待入队</span></span><br><span class="line">offer(E)                            <span class="comment">// 根据以上线性数据结构的了解，offer操作与add操作一致</span></span><br><span class="line">put(E)                              <span class="comment">// 入队，当队列处于阻塞状态，则等待入队，如果被打断，则抛出 InterruptedException</span></span><br><span class="line">offer(E, <span class="keyword">long</span>, TimeUnit)            <span class="comment">// 入队，指定允许阻塞等待的时间，如果被打断，则抛出InterruptedException</span></span><br><span class="line">take()                              <span class="comment">// 出队，当队列处于阻塞状态，则等待出队，如果被打断，则抛出InterruptedException</span></span><br><span class="line">poll(<span class="keyword">long</span>, TimeUnit)                <span class="comment">// 出队，指定允许阻塞等待的时间，如果被打断，则抛出InterruptedException</span></span><br><span class="line">remainingCapacity()                 <span class="comment">// 返回队列理想的大小（容量），即队列元素超过该大小则入队操作将blocking</span></span><br><span class="line">remove(Object)                      <span class="comment">// 移除指定元素Object</span></span><br><span class="line">contains(Object)                    <span class="comment">// 检查队列中是否包含该元素Object</span></span><br><span class="line">drainTo(Collection&lt;? <span class="keyword">super</span> E&gt;)      <span class="comment">// 移出队列中的所有元素到集合E中，并返回移出元素的数量</span></span><br><span class="line">drainTo(Collection&lt;? <span class="keyword">super</span> E&gt;, <span class="keyword">int</span>) <span class="comment">// 移除指定数量队列中的元素到集合E中，并返回移出元素的数量</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>BlockingQueue是线程安全的队列</li>
</ul>
</blockquote>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>ArrayBlockingQueue是基于数组实现的，遵循先进先出(FIFO)原则的阻塞队列。既然是阻塞队列，那就会有一个理想的容量，超过该容量之后，再要入队操作则进入阻塞状态。可以通过<code>new ArrayBlockingQueue(int)</code>创建一个指定容量的数组类型阻塞队列（默认在队列遇到阻塞情况时，不保证队列的先进先出原则），<code>new ArrayBlockingQueue(int, boolean)</code>创建一个指定容量，并指定当队列遇到阻塞情况是，是否保证队列的FIFO原则，<code>new ArrayBlockingQueue(int, boolean, Collection&lt;? extends E&gt;)</code>从已有集合中创建一个指定容量的，指定在阻塞情况下是否保证FIFO原则的数组阻塞队列。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The queued items */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** items index for next put, offer, or add */</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in the queue */</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过元素的入队实现可以看出，每当有元素入队，入队操作就会使用<code>ReentrantLock</code>上锁。在指定容量的队列中，通过固定数组存储队列的元素，当数组满了（putIndex==items.length）之后，下一个需要入队的元素将追加到数组初始位置，从数组的声明也可看出，已经实例化的队列，其容量是不允许再变更的。元素入队成功之后，给一个signal给<code>notEmpty</code>Condition<a href="http://blog.csdn.net/u011116672/article/details/51064752" title="CSDN blog关于Condition介绍" target="_blank" rel="noopener">Condition的用法参考</a>,通知正在Condition变量等待队列的线程从await方法返回，并且在返回前已经获得了锁。它的出队列操作则相反，当有元素出队列时，给<code>dequeue()</code>操作上锁，取出队列头的元素，将数组中该位置置为null, 给<code>notFull()</code>一个signal。</p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>ArrayBlockingQueue遵循FIFO</li>
<li>ArrayBlockingQueue是有界队列</li>
</ul>
</blockquote>
<blockquote>
<p>BlockingQueue还有如 <strong>DelayQueue</strong>,DelayQueue是一个可以拥有无限容量的阻塞延时队列，该队列的存储通过PriorityQueue实现，拥有PriorityQueue元素优先级的特性，DelayQueue存储的对象都需要实现了Delayed接口。<strong>LinkedBlockingQueue</strong>, 故名思议是通过Node实现的单向链式阻塞队列，遵循FIFO,默认容量为<code>Integer.MAX_VALUE</code>,也可以指定容量，当队列中元素数量达到入量时，再插入元素将失败。PriorityBlockingQueue, PriorityBlockingQueue是PriorityQueue的阻塞实现，是一个无界优先阻塞队列。<strong>SynchronousQueue</strong>, 同步阻塞队列，当有元素进入队列时，必须要等这个元素出队列，才能再有元素入队，反之亦然，SynchronousQueue没有容量这一概念，甚至它的容量不是1. <strong>TransferQueue</strong>, 以及它的实现LinkedTransferQueue, 该类型队列是jdk1.7新增的，有点类似SynchronousQueue, 但功能上比SynchronousQueue丰富，对比可参考<a href="http://puredanger.github.io/tech.puredanger.com/2009/02/28/java-7-transferqueue/" title="Java 7 TransferQueue" target="_blank" rel="noopener">Java 7 TransferQueue - Pure Danger</a>或它的译文<a href="http://ifeve.com/java-transfer-queue/" title="Java 7中的TransferQueue" target="_blank" rel="noopener">ivfeve</a>。</p>
</blockquote>
<h3 id="Deque-interface"><a href="#Deque-interface" class="headerlink" title="Deque(interface)"></a>Deque(interface)</h3><p>Deque(“double ended queue”的简写)，是双向队列的接口，是一种可以两端做同样操作的线性集合。商量双向队列的实现有<strong>ArrayQueue</strong>,<strong>ConcurrentLinkedDeque</strong>, <strong>LinkedList</strong>, 以及它的阻塞双向队列实现<strong>LinkedBlockingDeque</strong>. 很明显，<strong>ArrayDeque</strong>是基于数组的形式实现的大小可变化的双向队列，遵循FIFO原则，可配置初始容量，默认初始容量为16，当容量不够用时使用翻倍策略扩容。<strong>ConcurrentLinkedDeque</strong>是基于双向节点实现的无界链式线程安全的双向队列，遵循FIFO原则。<strong>LinkedList</strong>同时也是List的实现，同时具有双向队列的特性。<strong>LinkedBlockingDeque</strong>是并发包下的BlockingDeque的实现，基于节点，遵循FIFO的双向队列。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/xrq730/p/4979021.html" title="ReentrantLock实现原理深入探究" target="_blank" rel="noopener">(ReentrantLock实现原理深入探究)</a></li>
<li><a href="http://blog.csdn.net/vernonzheng/article/details/8288251" title="ReentrantLock与Condition" target="_blank" rel="noopener">Java多线程（九）之ReentrantLock与Condition</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>set</tag>
        <tag>list</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark集群环境搭建</title>
    <url>/article/2017/06/23/2017-06-23-Spark%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>继上次的<a href="/article/2017/06/17/2017-06-17-Hadoop学习笔记-Hadoop-HDFS环境搭建/" title="Hadoop学习笔记-Hadoop HDFS环境搭建">hadoop环境搭建</a>，现追加安装spark集群。</p>
<a id="more"></a>
<h4 id="安装scala"><a href="#安装scala" class="headerlink" title="安装scala"></a>安装scala</h4><p>以下操作在master主机上完成。spark依赖于scala环境，所以首先安装scala。<a href="http://www.scala-lang.org/" title="scala官网" target="_blank" rel="noopener">下载scala安装包</a><code>scala-2.11.0.tgz</code>，解压到<code>/usr/local/etc/</code>路径下。<br>配置环境变量：编辑<code>/etc/profile</code>文件，在最后面添加如下配置：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> SCALA_HOME=/usr/<span class="built_in">local</span>/etc/scala-2.11.0</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;SCALA_HOME&#125;</span>/bin</span><br></pre></td></tr></table></figure></p>
<p>编辑并保存完成<code>etc/profile</code>文件之后，执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop@master:~$ <span class="built_in">source</span> /etc/profile <span class="comment"># 使生效</span></span><br><span class="line">hadoop@master:~$ scala -version</span><br><span class="line">Scala code runner version 2.11.0 -- Copyright 2002-2013, LAMP/EPFL</span><br></pre></td></tr></table></figure></p>
<h4 id="安装Spark"><a href="#安装Spark" class="headerlink" title="安装Spark"></a>安装Spark</h4><p><a href="http://spark.apache.org/downloads.html" title="spark官网" target="_blank" rel="noopener">下载Spark安装包</a><code>spark-1.6.1-bin-hadoop2.6.tgz</code>，解压到<code>/usr/local/etc/</code>路径下。<br>配置环境变量：编辑<code>/etc/profile</code>文件，在最后面添加如下配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export SPARK_HOME=/usr/local/etc/spark-1.6.1-bin-hadoop2.6</span><br><span class="line">export PATH=$PATH:$&#123;SPARK_HOME&#125;/bin:$&#123;SPARK_HOME&#125;/sbin</span><br></pre></td></tr></table></figure></p>
<p>编辑并保存完成<code>etc/profile</code>文件之后，执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop@master:~$ <span class="built_in">source</span> /etc/profile <span class="comment"># 使生效</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里需要注意一下，因为之前在配置Hadoop环境的时候，在hadoop中已经存在<code>start-all.sh</code>以及<code>stop-all.sh</code>这两个文件，可以更改spark中<code>sbin/</code>的对应文件的名称以避免冲突，甚至还有其他重名的文件，在使用过程中还需多加注意。所以我将spark中的这两个文件改名为对应的<code>spark-start-all.sh</code>和<code>spark-stop-all.sh</code>。</p>
</blockquote>
<hr>
<p>接下来配置spark集群环境<br>转移到spark根目录下的<code>conf</code>文件夹中。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop@master:/usr/<span class="built_in">local</span>/etc/spark-1.6.1-bin-hadoop2.6/conf$ ls</span><br><span class="line">docker.properties.template  metrics.properties.template   spark-env.sh.template</span><br><span class="line">fairscheduler.xml.template  slaves.template</span><br><span class="line">log4j.properties.template   spark-defaults.conf.template</span><br></pre></td></tr></table></figure></p>
<p>复制一份<code>slaves.template</code>文件，其名为<code>slaves</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop@master:/usr/local/etc/spark-1.6.1-bin-hadoop2.6/conf$ sudo cp slaves.template slaves</span><br></pre></td></tr></table></figure></p>
<p>编辑<code>slaves</code>文件，在后面追加：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">master <span class="comment"># 删除这里的 localhost，并改为 master</span></span><br><span class="line">slave01	<span class="comment"># 在hadoop环境配置时已经配置好了两个从属主机的名称，对应的是 192.168.1.201 </span></span><br><span class="line">slave02	<span class="comment"># 192.168.1.202</span></span><br></pre></td></tr></table></figure></p>
<p>复制一份<code>spark-env.sh.template</code>文件，其名为<code>spark-env.sh</code>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop@master:/usr/<span class="built_in">local</span>/etc/spark-1.6.1-bin-hadoop2.6/conf$ sudo cp spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure></p>
<p>编辑<code>spark-env.sh</code>文件，在后面追加：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/java/jdk1.8.0_45</span><br><span class="line"><span class="built_in">export</span> SCALA_HOME=/usr/<span class="built_in">local</span>/etc/scala-2.11.0</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>完成以上操作之后，将该master上的所有操作在slaves（slave01,slave02）主机上也进行同样的操作。确保环境变量，spark的配置信息等，在三台主机上的信息一致。</p>
</blockquote>
<p>完成所有操作之后，使用<code>spark-start-all.sh</code>启动spark。在浏览器地址栏输入：”master:8080”即可查看spark集群状态。</p>
<h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><blockquote>
<ul>
<li>1、下载文件”scala-2.11.0.tgz“、”spark-1.6.1-bin-hadoop2.6.tgz“</li>
<li>2、将这两个文件解压到<code>/usr/local/etc/</code>路径下</li>
<li>3、在<code>/etc/profile</code>文件中添加scala和spark的环境变量</li>
<li>4、配置spark的conf，配置<code>slaves</code>文件添加从属机器，配置<code>spark-env.sh</code>添加两个环境变量。</li>
<li>5、三台主机（master、slave01、slave02）做相同的配置</li>
</ul>
</blockquote>
<h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><blockquote>
<p><a href="http://spark.apache.org/documentation.html" title="官网文档地址" target="_blank" rel="noopener">官方文档地址</a><br><a href="https://yq.aliyun.com/topic/69" title="阿里云社区Spark核心技术与实践" target="_blank" rel="noopener">阿里云社区Spark核心技术与实践</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala之类定义</title>
    <url>/article/2017/07/11/2017-07-11-Scala%E4%B9%8B%E7%B1%BB%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>在scala中，类的声明有 <code>trait</code>, <code>class</code>, <code>object</code> 三种。其中<code>trait</code>声明接口，<code>class</code>为一般类的声明，<code>object</code>声明的类中的属性与方法都为静态，且在scala中没有<code>static</code>关键字。</p>
<a id="more"></a>
<h1 id="接口的定义-trait"><a href="#接口的定义-trait" class="headerlink" title="接口的定义-trait"></a>接口的定义-trait</h1><p><code>trait</code>是接口类的声明，在scala中没有<code>public</code>关键字，因为没有指定为<code>protected</code>或<code>private</code>的对象或方法都是为<code>public</code>的，这一点与java不同。当<code>trait</code>中所有的方法都没有实现时，反编译其编译出的<code>.class</code>文件可知该类其实是一个<code>abstract interface</code>：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Walking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span></span>(from: <span class="type">String</span>, end: <span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>scalac Walking.scala</code>编译成<code>.class</code>，通过<code>jd-gui</code>反编译<code>.class</code>出的内容为：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.reflect.<span class="type">ScalaSignature</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature</span>(bytes=<span class="string">"\006\001\0312q!\001\002\021\002G\005QAA\004XC2\\\027N\\4\013\003\r\tq\001P3naRLhh\001\001\024\005\0011\001CA\004\013\033\005A!\"A\005\002\013M\034\027\r\\1\n\005-A!AB!osJ+g\rC\003\016\001\031\005a\"\001\003xC2\\GcA\b\023?A\021q\001E\005\003#!\021A!\0268ji\")1\003\004a\001)\005!aM]8n!\t)BD\004\002\0275A\021q\003C\007\0021)\021\021\004B\001\007yI|w\016\036 \n\005mA\021A\002)sK\022,g-\003\002\036=\t11\013\036:j]\036T!a\007\005\t\013\001b\001\031\001\013\002\007\025tG\rC\003#\001\031\0051%\001\003uC2\\GCA\b%\021\025)\023\0051\001\025\003\0259xN\0353t\001"</span>)</span><br><span class="line">public <span class="keyword">abstract</span> interface <span class="type">Walking</span></span><br><span class="line">&#123;</span><br><span class="line">  public <span class="keyword">abstract</span> void walk(<span class="type">String</span> paramString1, <span class="type">String</span> paramString2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当<code>trait</code>声明的类中存在实现的方法时，其反编译的<code>.class</code>对象将会包含一个静态初始化方法：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Walking</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">walk</span></span>(from: <span class="type">String</span>, end: <span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">talk</span></span>(words: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">		printf(<span class="string">"talk %s."</span>, words)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反编译内容为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.Predef.;</span><br><span class="line"><span class="keyword">import</span> scala.reflect.ScalaSignature;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature</span>(bytes=<span class="string">"\006\001%2q!\001\002\021\002\007\005QAA\004XC2\\\027N\\4\013\003\r\tq\001P3naRLhh\001\001\024\005\0011\001CA\004\013\033\005A!\"A\005\002\013M\034\027\r\\1\n\005-A!AB!osJ+g\rC\003\016\001\021\005a\"\001\004%S:LG\017\n\013\002\037A\021q\001E\005\003#!\021A!\0268ji\")1\003\001D\001)\005!q/\0317l)\ryQC\t\005\006-I\001\raF\001\005MJ|W\016\005\002\031?9\021\021$\b\t\0035!i\021a\007\006\0039\021\ta\001\020:p_Rt\024B\001\020\t\003\031\001&amp;/\0323fM&amp;\021\001%\t\002\007'R\024\030N\\4\013\005yA\001\"B\022\023\001\0049\022aA3oI\")Q\005\001C\001M\005!A/\0317l)\tyq\005C\003)I\001\007q#A\003x_J$7\017"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">Walking</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(String paramString1, String paramString2)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String words)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Predef..MODULE$.printf(<span class="string">"talk %s."</span>, Predef..MODULE$.genericWrapArray(<span class="keyword">new</span> Object[] &#123; words &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> $init$(Walking $<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意</strong> 这里在<code>import</code>语句中有<code>import scala.Predef.;</code></p>
</blockquote>
<p>当<code>tracit</code>中包含属性或语句块时，其声明的属性getter/setter方法都会是<code>abstract</code>方法，有默认值则在静态初始方法<code>$init$</code>中赋值，<code>trait</code>中的语句块都在<code>$init$</code>静态方法中执行。<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Walking</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">walk</span></span>(from: <span class="type">String</span>, end: <span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> name: <span class="type">String</span> =  <span class="string">"hero"</span></span><br><span class="line">	<span class="keyword">val</span> alias: <span class="type">String</span> = <span class="string">"HERO"</span></span><br><span class="line"></span><br><span class="line">	println(<span class="string">"this is a trait named Walking."</span>)</span><br><span class="line">	println(name)</span><br><span class="line">	println(alias)</span><br><span class="line"><span class="comment">//	alias = "NEW HERO"  // 报错, val声明的属性不可变更, 即使在其反编译内容中含有setter方法(Walking$_setter_$alias_$eq)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其反编译结果为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.Predef.;</span><br><span class="line"><span class="keyword">import</span> scala.reflect.ScalaSignature;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature</span>(bytes=<span class="string">"\006\00192q!\001\002\021\002\007\005QAA\004XC2\\\027N\\4\013\003\r\tq\001P3naRLhh\001\001\024\005\0011\001CA\004\013\033\005A!\"A\005\002\013M\034\027\r\\1\n\005-A!AB!osJ+g\rC\003\016\001\021\005a\"\001\004%S:LG\017\n\013\002\037A\021q\001E\005\003#!\021A!\0268ji\")1\003\001D\001)\005!q/\0317l)\ryQC\t\005\006-I\001\raF\001\005MJ|W\016\005\002\031?9\021\021$\b\t\0035!i\021a\007\006\0039\021\ta\001\020:p_Rt\024B\001\020\t\003\031\001&amp;/\0323fM&amp;\021\001%\t\002\007'R\024\030N\\4\013\005yA\001\"B\022\023\001\0049\022aA3oI\"9Q\005\001a\001\n\0031\023\001\0028b[\026,\022a\006\005\bQ\001\001\r\021\"\001*\003!q\027-\\3`I\025\fHCA\b+\021\035Ys%!AA\002]\t1\001\037\0232\021\035i\003A1A\005\002\031\nQ!\0317jCN\004"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">Walking</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> Walking$_setter_$alias_$eq(String paramString);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(String paramString1, String paramString2)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> name_$eq(String paramString);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">alias</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> $init$(Walking $<span class="keyword">this</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    $<span class="keyword">this</span>.name_$eq(<span class="string">"hero"</span>);</span><br><span class="line">    $<span class="keyword">this</span>.Walking$_setter_$alias_$eq(<span class="string">"HERO"</span>);</span><br><span class="line">    </span><br><span class="line">    Predef..MODULE$.println(<span class="string">"this is a trait named Walking."</span>);</span><br><span class="line">    Predef..MODULE$.println($<span class="keyword">this</span>.name());</span><br><span class="line">    Predef..MODULE$.println($<span class="keyword">this</span>.alias());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意</strong> 以上实例在jdk8环境下使用jd-gui</p>
</blockquote>
<h1 id="类的定义-class"><a href="#类的定义-class" class="headerlink" title="类的定义-class"></a>类的定义-class</h1><p>使用<code>class</code>声明类，实现<code>trait</code>声明的接口：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWalking</span> <span class="keyword">extends</span> <span class="title">Walking</span> </span>&#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">walk</span></span>(from: <span class="type">String</span>, end: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">		printf(<span class="string">"walk from %s to %s."</span>, from, end)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">		name = <span class="string">"NEW NAME"</span></span><br><span class="line">		printf(<span class="string">"new name is %s, alias is %s."</span>, name, alias)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>MyWalking</code>反编译结果为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.Predef.;</span><br><span class="line"><span class="keyword">import</span> scala.reflect.ScalaSignature;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature</span>(bytes=<span class="string">"\006\00112A!\001\002\001\013\tIQ*_,bY.Lgn\032\006\002\007\0059A(Z7qift4\001A\n\004\001\031a\001CA\004\013\033\005A!\"A\005\002\013M\034\027\r\\1\n\005-A!AB!osJ+g\r\005\002\016\0355\t!!\003\002\020\005\t9q+\0317lS:&lt;\007\"B\t\001\t\003\021\022A\002\037j]&amp;$h\bF\001\024!\ti\001\001C\003\026\001\021\005c#\001\003xC2\\GcA\f\033OA\021q\001G\005\0033!\021A!\0268ji\")1\004\006a\0019\005!aM]8n!\tiBE\004\002\037EA\021q\004C\007\002A)\021\021\005B\001\007yI|w\016\036 \n\005\rB\021A\002)sK\022,g-\003\002&amp;M\t11\013\036:j]\036T!a\t\005\t\013!\"\002\031\001\017\002\007\025tG\rC\003+\001\021\0051&amp;\001\003uKN$H#A\f"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWalking</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Walking</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String alias;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> name_$eq(String x$<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = x$<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">alias</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.alias;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> Walking$_setter_$alias_$eq(String x$<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>.alias = x$<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyWalking</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Walking.$init$(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(String from, String end)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Predef..MODULE$.printf(<span class="string">"walk from %s to %s."</span>, Predef..MODULE$.genericWrapArray(<span class="keyword">new</span> Object[] &#123; from, end &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    name_$eq(<span class="string">"NEW NAME"</span>);</span><br><span class="line">    Predef..MODULE$.printf(<span class="string">"new name is %s, alias is %s."</span>, Predef..MODULE$.genericWrapArray(<span class="keyword">new</span> Object[] &#123; name(), alias() &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可见<code>Predef</code>在scala中作用不凡</p>
</blockquote>
<h1 id="单例类-object"><a href="#单例类-object" class="headerlink" title="单例类-object"></a>单例类-object</h1><p>在scala中，没有静态修饰符，一般<code>class</code>声明的类需要通过对象实例操作类中的方法，通过<code>object</code>声明的类，就能通过类名直接调用类中的方法，这点与java语言中的<code>static</code>修饰符有类似的地方。只有通过<code>object</code>声明的类中的<code>main</code>方法才能被当做程序的入口。<br><code>object</code>声明的类，都会具有一个对应的隐式类（虚构类），隐式类的类名即为在该类名后面加<code>$</code>，譬如：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ObjectA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> intVar: <span class="type">Int</span> = <span class="number">12</span></span><br><span class="line">    <span class="keyword">val</span> intVal: <span class="type">Int</span> = <span class="number">23</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(food: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(<span class="string">"eat "</span> + food)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      eat(<span class="string">"apple"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其反编译结果：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反编译object类 ObjectA.class</span></span><br><span class="line"><span class="keyword">import</span> scala.reflect.ScalaSignature;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature</span>(bytes=<span class="string">"\006\001&#125;:Q!\001\002\t\002\025\tqa\0242kK\016$\030IC\001\004\003\035aT-\0349usz\032\001\001\005\002\007\0175\t!AB\003\t\005!\005\021BA\004PE*,7\r^!\024\005\035Q\001CA\006\017\033\005a!\"A\007\002\013M\034\027\r\\1\n\005=a!AB!osJ+g\rC\003\022\017\021\005!#\001\004=S:LGO\020\013\002\013!9Ac\002a\001\n\003)\022AB5oiZ\013'/F\001\027!\tYq#\003\002\031\031\t\031\021J\034;\t\017i9\001\031!C\0017\005Q\021N\034;WCJ|F%Z9\025\005qy\002CA\006\036\023\tqBB\001\003V]&amp;$\bb\002\021\032\003\003\005\rAF\001\004q\022\n\004B\002\022\bA\003&amp;a#A\004j]R4\026M\035\021\t\017\021:!\031!C\001+\0051\021N\034;WC2DaAJ\004!\002\0231\022aB5oiZ\013G\016\t\005\006Q\035!\t!K\001\004K\006$HC\001\017+\021\025Ys\0051\001-\003\0211wn\0343\021\0055\"dB\001\0303!\tyC\"D\0011\025\t\tD!\001\004=e&gt;|GOP\005\003g1\ta\001\025:fI\0264\027BA\0337\005\031\031FO]5oO*\0211\007\004\005\006q\035!\t!O\001\005[\006Lg\016\006\002\035u!)1h\016a\001y\005!\021M]4t!\rYQ\bL\005\003&#125;1\021Q!\021:sCf\004"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectA</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ObjectA..MODULE$.main(paramArrayOfString);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String paramString)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ObjectA..MODULE$.eat(paramString);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">intVal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ObjectA..MODULE$.intVal();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> intVar_$eq(<span class="keyword">int</span> paramInt)</span><br><span class="line">  &#123;</span><br><span class="line">    ObjectA..MODULE$.intVar_$eq(paramInt);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">intVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ObjectA..MODULE$.intVar();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其隐式Object类 Object$.class</span></span><br><span class="line"><span class="keyword">import</span> scala.Predef.;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectA</span>$</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span>  MODULE$;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> intVar;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> intVal;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.intVar;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> intVar_$eq(<span class="keyword">int</span> x$<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>.intVar = x$<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intVal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.intVal;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Predef..MODULE$.println(<span class="string">"eat "</span> + food);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    eat(<span class="string">"apple"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> ObjectA$()</span><br><span class="line">  &#123;</span><br><span class="line">    MODULE$ = <span class="keyword">this</span>;<span class="keyword">this</span>.intVar = <span class="number">12</span>;<span class="keyword">this</span>.intVal = <span class="number">23</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">new</span> ();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看出<code>object</code>声明的类是<code>final</code>的，故继承<code>object</code>是不能被继承的，其中声明的属性和方法都是<code>static</code>的，也就没有必要实例化一个<code>object</code>实例再去调用其中的方法，事实上<code>object</code>也不能使用<code>new</code>关键字去创建一个实例(<code>trait</code>也一样)，即<code>object</code>声明的类是一个<em>单例类</em>。<code>object</code>中的方法内容将在他的隐式类中体现并执行，它本身只是调用它隐式类中的同名方法。同时<code>object</code>类不含有构造方法，它的”构造方法”也将在隐式类中体现，因为<code>object</code>不提供构造方法，故<code>object</code>也不能带有参数，如果<code>object</code>的声明带有参数则会报错，譬如:<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ObjectA</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  ...   <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>其报错内容为<br><img src="/images/coding/trait_object_may_not_have_parameters.png" alt="trait_object_may_not_have_parameters" title="object和trait中带有参数是会报错的，因为他们都不能使用new关键字去创建一个对象"></p>
</blockquote>
<p><strong>伴生类</strong><br>用<code>class</code>声明一个类，再使用<code>object</code>声明一个与其名称一样的单例类，这两个类置于同一个<code>.scala</code>文件中，则这个类就成为这个单例类的伴生类，这个单例类也就是该类的伴生对象（单例）。<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>(): <span class="type">String</span> = <span class="string">"name="</span> + name + <span class="string">", age="</span> + age</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">talk</span></span>(words: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    printf(<span class="string">"Man %s say: \"%s\" \n"</span>, name, words)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>, age: <span class="type">Int</span>): <span class="type">Man</span> = <span class="keyword">new</span> <span class="type">Man</span>(name, age)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Man</span> = <span class="keyword">new</span> <span class="type">Man</span>(<span class="string">"zero"</span>, <span class="number">23</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其反编译内容：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Man.class</span></span><br><span class="line"><span class="keyword">import</span> scala.Predef.;</span><br><span class="line"><span class="keyword">import</span> scala.reflect.ScalaSignature;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature</span>(bytes=<span class="string">"\006\001y2A!\001\002\001\013\t\031Q*\0318\013\003\r\tq\001P3naRLhh\001\001\024\005\0011\001CA\004\013\033\005A!\"A\005\002\013M\034\027\r\\1\n\005-A!AB!osJ+g\r\003\005\016\001\t\005\t\025!\003\017\003\021q\027-\\3\021\005=1bB\001\t\025!\t\t\002\"D\001\023\025\t\031B!\001\004=e&gt;|GOP\005\003+!\ta\001\025:fI\0264\027BA\f\031\005\031\031FO]5oO*\021Q\003\003\005\t5\001\021\t\021)A\0057\005\031\021mZ3\021\005\035a\022BA\017\t\005\rIe\016\036\005\006?\001!\t\001I\001\007y%t\027\016\036 \025\007\005\032C\005\005\002#\0015\t!\001C\003\016=\001\007a\002C\003\033=\001\0071\004C\003'\001\021\005s%\001\005u_N#(/\0338h)\005q\001\"B\025\001\t\003Q\023\001\002;bY.$\"a\013\030\021\005\035a\023BA\027\t\005\021)f.\033;\t\013=B\003\031\001\b\002\013]|'\017Z:\b\013E\022\001\022\001\032\002\0075\013g\016\005\002#g\031)\021A\001E\001iM\0211G\002\005\006?M\"\tA\016\013\002e!)\001h\rC\001s\005)\021\r\0359msR\031\021EO\036\t\01359\004\031\001\b\t\013i9\004\031A\016\t\013a\032D\021A\037\025\003\005\002"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Man <span class="title">apply</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Man..MODULE$.apply();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Man <span class="title">apply</span><span class="params">(String paramString, <span class="keyword">int</span> paramInt)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Man..MODULE$.apply(paramString, paramInt);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"name="</span> + <span class="keyword">this</span>.name + <span class="string">", age="</span> + <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String words)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Predef..MODULE$.printf(<span class="string">"Man %s say: \"%s\" \n"</span>, Predef..MODULE$.genericWrapArray(<span class="keyword">new</span> Object[] &#123; <span class="keyword">this</span>.name, words &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Man$.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span>$</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span>  MODULE$;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">new</span> ();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Man <span class="title">apply</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Man(name, age);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Man <span class="title">apply</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Man(<span class="string">"zero"</span>, <span class="number">23</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Man$()</span><br><span class="line">  &#123;</span><br><span class="line">    MODULE$ = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在使用具有伴生对象的类时<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> man01 = <span class="type">Man</span>(<span class="string">"第一个男人"</span>, <span class="number">23</span>)</span><br><span class="line">    <span class="keyword">val</span> man02 = <span class="keyword">new</span> <span class="type">Man</span>(<span class="string">"第二个男人"</span>, <span class="number">22</span>)</span><br><span class="line">    <span class="keyword">val</span> man03 = <span class="type">Man</span>.apply()</span><br><span class="line">    <span class="keyword">val</span> man04 = <span class="type">Man</span>.apply(<span class="string">"第四个男人"</span>, <span class="number">12</span>)</span><br><span class="line">    println(man01)          <span class="comment">// name=第一个男人, age=23</span></span><br><span class="line">    println(man02)          <span class="comment">// name=第二个男人, age=22</span></span><br><span class="line">    println(man03)          <span class="comment">// name=zero, age=23</span></span><br><span class="line">    println(man04)          <span class="comment">// name=第四个男人, age=12</span></span><br><span class="line">    man03.talk(<span class="string">"Hello!"</span>)    <span class="comment">// Man zero say: "Hello!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>类的伴生对象中的属性和方法都是<code>static</code>的，故使用伴生对象的方式可以拓展类的功能</p>
</blockquote>
<h1 id="scala中的枚举"><a href="#scala中的枚举" class="headerlink" title="scala中的枚举"></a>scala中的枚举</h1><p>在scala中，是没有<code>enum</code>关键字的，那怎么去声明一个枚举类呢。通过<code>object</code>的介绍可知，<code>object</code>中的属性和方法都是<code>static</code>的(其实还是<code>final</code>的)，同时，scala还提供<code>Enumeration</code>这个<code>abstract class</code>用来实现枚举类的声明，所以使用<code>object</code>继承<code>Enumeration</code>可以达到声明枚举类的功能。<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ColorEnum</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">RED</span>, <span class="type">GREEN</span> = <span class="type">Value</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">YELLOW</span> = <span class="type">Value</span>(<span class="number">12</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">BLACK</span> = <span class="type">Value</span>(<span class="string">"黑色"</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">BLUE</span> = <span class="type">Value</span>(<span class="number">99</span>, <span class="string">"蓝色"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="type">ColorEnum</span>.<span class="type">RED</span>)      <span class="comment">// RED</span></span><br><span class="line">    println(<span class="type">ColorEnum</span>.<span class="type">GREEN</span>)    <span class="comment">// GREEN</span></span><br><span class="line">    println(<span class="type">ColorEnum</span>.<span class="type">YELLOW</span>)   <span class="comment">// YELLOW</span></span><br><span class="line">    println(<span class="type">ColorEnum</span>.<span class="type">BLACK</span>)    <span class="comment">// 黑色</span></span><br><span class="line">    println(<span class="type">ColorEnum</span>.<span class="type">BLUE</span>)     <span class="comment">// 蓝色</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其反编译内容为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ColorEnum.class</span></span><br><span class="line"><span class="keyword">import</span> scala.Enumeration.Value;</span><br><span class="line"><span class="keyword">import</span> scala.Enumeration.ValueOrdering.;</span><br><span class="line"><span class="keyword">import</span> scala.Enumeration.ValueSet;</span><br><span class="line"><span class="keyword">import</span> scala.Enumeration.ValueSet.;</span><br><span class="line"><span class="keyword">import</span> scala.reflect.ScalaSignature;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature</span>(bytes=<span class="string">"\006\001\t;Q!\001\002\t\002\025\t\021bQ8m_J,e.^7\013\003\r\tq\001P3naRLhh\001\001\021\005\0319Q\"\001\002\007\013!\021\001\022A\005\003\023\r&#123;Gn\034:F]Vl7CA\004\013!\tYa\"D\001\r\025\005i\021!B:dC2\f\027BA\b\r\005-)e.^7fe\006$\030n\0348\t\013E9A\021\001\n\002\rqJg.\033;?)\005)\001b\002\013\b\005\004%\t!F\001\004%\026#U#\001\f\021\005]AR\"A\004\n\005eq!!\002,bYV,\007BB\016\bA\003%a#\001\003S\013\022\003\003bB\017\b\005\004%\t!F\001\006\017J+UI\024\005\007?\035\001\013\021\002\f\002\r\035\023V)\022(!\021\035\tsA1A\005\002U\ta!W#M\031&gt;;\006BB\022\bA\003%a#A\004Z\0132cuj\026\021\t\017\025:!\031!C\001+\005)!\tT!D\027\"1qe\002Q\001\nY\taA\021'B\007.\003\003bB\025\b\005\004%\t!F\001\005\0052+V\t\003\004,\017\001\006IAF\001\006\0052+V\t\t\005\006[\035!\tAL\001\005[\006Lg\016\006\0020eA\0211\002M\005\003c1\021A!\0268ji\")1\007\fa\001i\005!\021M]4t!\rYQgN\005\003m1\021Q!\021:sCf\004\"\001O \017\005ej\004C\001\036\r\033\005Y$B\001\037\005\003\031a$o\\8u&#125;%\021a\bD\001\007!J,G-\0324\n\005\001\013%AB*ue&amp;twM\003\002?\031\001"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorEnum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ColorEnum..MODULE$.main(paramArrayOfString);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Enumeration.<span class="function">Value <span class="title">BLUE</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ColorEnum..MODULE$.BLUE();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Enumeration.<span class="function">Value <span class="title">BLACK</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ColorEnum..MODULE$.BLACK();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Enumeration.<span class="function">Value <span class="title">YELLOW</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ColorEnum..MODULE$.YELLOW();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Enumeration.<span class="function">Value <span class="title">GREEN</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ColorEnum..MODULE$.GREEN();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Enumeration.<span class="function">Value <span class="title">RED</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ColorEnum..MODULE$.RED();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Enumeration.ValueSet. ValueSet()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> ColorEnum..MODULE$.ValueSet();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Enumeration.ValueOrdering. ValueOrdering()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> ColorEnum..MODULE$.ValueOrdering();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Enumeration.<span class="function">Value <span class="title">withName</span><span class="params">(String paramString)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ColorEnum..MODULE$.withName(paramString);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Enumeration.<span class="function">Value <span class="title">apply</span><span class="params">(<span class="keyword">int</span> paramInt)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ColorEnum..MODULE$.apply(paramInt);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ColorEnum..MODULE$.maxId();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Enumeration.<span class="function">ValueSet <span class="title">values</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ColorEnum..MODULE$.values();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ColorEnum..MODULE$.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ColorEnum$.class</span></span><br><span class="line"><span class="keyword">import</span> scala.Enumeration;</span><br><span class="line"><span class="keyword">import</span> scala.Enumeration.Value;</span><br><span class="line"><span class="keyword">import</span> scala.Predef.;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorEnum</span>$</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Enumeration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span>  MODULE$;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Enumeration.Value RED;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Enumeration.Value GREEN;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Enumeration.Value YELLOW;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Enumeration.Value BLACK;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Enumeration.Value BLUE;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Enumeration.<span class="function">Value <span class="title">RED</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.RED;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Enumeration.<span class="function">Value <span class="title">GREEN</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.GREEN;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Enumeration.<span class="function">Value <span class="title">YELLOW</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.YELLOW;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Enumeration.<span class="function">Value <span class="title">BLACK</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.BLACK;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Enumeration.<span class="function">Value <span class="title">BLUE</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.BLUE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> ColorEnum$()</span><br><span class="line">  &#123;</span><br><span class="line">    MODULE$ = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.RED = Value();<span class="keyword">this</span>.GREEN = Value();</span><br><span class="line">    <span class="keyword">this</span>.YELLOW = Value(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">this</span>.BLACK = Value(<span class="string">"黑色"</span>);</span><br><span class="line">    <span class="keyword">this</span>.BLUE = Value(<span class="number">99</span>, <span class="string">"蓝色"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Predef..MODULE$.println(RED());</span><br><span class="line">    Predef..MODULE$.println(GREEN());</span><br><span class="line">    Predef..MODULE$.println(YELLOW());</span><br><span class="line">    Predef..MODULE$.println(BLACK());</span><br><span class="line">    Predef..MODULE$.println(BLUE());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">new</span> ();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
        <tag>trait</tag>
        <tag>class</tag>
        <tag>object</tag>
      </tags>
  </entry>
  <entry>
    <title>盘点一下那些好玩的位运算</title>
    <url>/article/2017/08/25/2017-08-25-%E7%9B%98%E7%82%B9%E4%B8%80%E4%B8%8B%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%8E%A9%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>程序中的所有数在计算机内存中都是以二进制的形式储存的，位运算即对数据的二进制直接操作，具有效率高的特点。在Java中，位运算有<code>&lt;&lt;</code>(左移),<code>&gt;&gt;</code>(右移),<code>&gt;&gt;&gt;</code>(无符号右移),<code>&amp;</code>(且),<code>|</code>(或),<code>^</code>(异或),<code>~</code>(取反),其中<code>~</code>(按位取反)是单目操作，其他都为双目运算。因为直接的位运算极其高效，通过合理的应用位运算能极大的提高程序的效率。</p>
<a id="more"></a>
<h1 id="求两个正整数的平均数"><a href="#求两个正整数的平均数" class="headerlink" title="求两个正整数的平均数"></a>求两个正整数的平均数</h1><p>计算两个整数的平均数，正常的做法是<code>(a + b) / 2</code>，但是考虑到如果<code>a + b &gt; Integer.MAX_VALUE</code>的情况，可能会出现溢出的情况，数值的溢出不会抛出异常信息，但得到的结果却不是我们想要的，譬如: <code>(Integer.MAX_VALUE + 100) / 2</code>的结果为<code>-1073741774</code>。这个时候，位运算就能派上用场了。所谓求平均，就是两个对象<em>共有的部分</em>加<em>它们各自有的部分之和的一半</em>，这么一来位运算的思路就很明显了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &amp; b) + ((a ^ b) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>即先通过<code>&amp;</code>操作获取两数的<em>共有的部分</em>，使用<code>^</code>操作获取<em>它们各自有的部分之和</em>，通过<code>&gt;&gt;&gt;</code>无符号右移一位达到<em>取一半</em>的作用，它们之和就是这两数的平均数了。如果追求精度，可以把<code>&gt;&gt;&gt; 1</code>操作换成<code>/ 2.0</code>,修改其返回类型为<code>double</code>.</p>
</blockquote>
<h1 id="不使用临时变量的交换"><a href="#不使用临时变量的交换" class="headerlink" title="不使用临时变量的交换"></a>不使用临时变量的交换</h1><p>先上代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;  <span class="comment">// 0011</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;  <span class="comment">// 0101</span></span><br><span class="line">System.out.println(<span class="string">"a="</span> + a + <span class="string">", b="</span> + b);  <span class="comment">// a=3, b=5</span></span><br><span class="line">a ^= b; <span class="comment">// a = a^b = 0011^0101 = 0110;</span></span><br><span class="line">b ^= a; <span class="comment">// b = b^a = 0101^0110 = 0011;</span></span><br><span class="line">a ^= b; <span class="comment">// a = a^b = 0110^0011 = 0101;</span></span><br><span class="line">System.out.println(<span class="string">"a="</span> + a + <span class="string">", b="</span> + b);  <span class="comment">// a=5, b=3</span></span><br></pre></td></tr></table></figure></p>
<p><code>^</code>异或运算是去两个位数上不同的情况为结果为1,否则为0,即两个相同的数异或操作结果是0,譬如<code>1^1=0</code>,<code>0^0=0</code>,<code>0^1=1</code>,<code>1^0=1</code>.第一步<code>a=a^b</code>是将a、b两数的不同位数提取出来,暂存于a,即<code>a=0011^0101; // 0110</code>,第二步操作<code>b = b^(a);</code>可以看成是将a的值赋值给b，即将第一步和第二步合起来其实是<code>b=a^b^b</code>,这里的b在这里参与了两次异或运算，由于<code>x^x=0</code>,同样，第三步和第一步合并的操作为：<code>a=(a^b)^(b)</code>,注意这里的第二个b其实已经成了之前的a，也就是说基于第二步，第三步和第一步的合并操作其实是：<code>a=a^b^a</code>，即就是将之前的b值赋值给了a.</p>
<h1 id="找出成对数组中不成对的元素"><a href="#找出成对数组中不成对的元素" class="headerlink" title="找出成对数组中不成对的元素"></a>找出成对数组中不成对的元素</h1><p>参见<a href="/article/2017/08/20/2017-08-20-找出成对数组中不成对的元素/" title="本站链接">找出成对数组中不成对的元素</a>。</p>
<h1 id="计算绝对值"><a href="#计算绝对值" class="headerlink" title="计算绝对值"></a>计算绝对值</h1><p>在JDK的Math工具类中，<code>Math.abs(a)</code>的实现是<code>return (a&lt;0) ? -a:a;</code>,遇到<code>a=Integer.MIN_VALUE</code>的情况时，其返回结果为<code>-2147483648</code>,这显然不是我们期待的值，为啥呢？这得追溯到计算机存储数值的编码方式，其中有原码、反码和补码。int类型有32bit,太长，我们采用byte类型举例。<br>对于有符号位，二进制的最高位(bit)表示的是符号位，即0表示正数，1表示负数，譬如2的原码为<code>0000 0010</code>,-2的原码为<code>1000 0010</code>,那如果<code>2+(-2)</code>的原码计算式什么呢：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000 0010 + 1000 0010 = 1000 0100</span><br></pre></td></tr></table></figure></p>
<p>结果为-4？！这明显不对，这时候就需要引入反码来解决这种情况。反码编码方式规定：<strong>正数的反码与原码相同，负数则符号位不变，其余位按位取反</strong>。使用反码计算<code>2+(-2)</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000 0010 + 1111 1101 = 1111 1111</span><br></pre></td></tr></table></figure></p>
<p>反码表示的<code>1111 1111</code>是什么，转为原码为<code>1000 0000</code>,就是<code>-0</code>,<code>-0</code>是什么，<code>0</code>的表示不是<code>0000 0000</code>吗，同样是<code>0</code>怎么能有两个编码，然后为了解决这种情况，诞生了补码。补码的规定为：<strong>负数的补码就是对反码加一，而正数的补码不变</strong>，即<strong>正数的原码、反码、补码都是一样的</strong>。那<code>-0</code>的补码表示就成了<code>1 0000 0000</code>这个溢出位咋整——直接舍去，即<code>0000 0000</code>.为什么不把<code>2+(-2)</code>写成<code>2-2</code>，因为计算机只有加法，没有减法，这也是为什么会设计补码这种编码的一个原因。<br>再回到<code>Math.abs(a)</code>,因为JDK的实现只是在原数上添加了一个符号位。<code>Integer.MIN_VALUE</code>在java中的定义是：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_VALUE = <span class="number">0x80000000</span>;</span><br></pre></td></tr></table></figure></p>
<p>即它的补码表示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000 0000  0000 0000  0000 0000  0000 0000  // Integer.toBinaryString(Integer.MIN_VALUE)</span><br></pre></td></tr></table></figure></p>
<p>如果取绝对值，则符号位变为<code>0</code>,然后后面位数取反：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0111 1111  1111 1111  1111 1111  1111 1111</span><br></pre></td></tr></table></figure></p>
<p>再加一：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000 0000  0000 0000  0000 0000  0000 0000</span><br></pre></td></tr></table></figure></p>
<p>又回到<code>Integer.MIN_VALUE</code>本身了。其实也能理解，毕竟int类型的存值区间为-2147483648 ~ 2147483647,而 -2147483648的绝对值已经超过了int的存储范围。<br>回到使用位运算计算绝对值,根据之前对取绝对值的方法描述，使用long类型存储绝对值，这样就能获取到正确的绝对值了:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Math.abs(a)原方法修正</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">mathAbs</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a&lt;<span class="number">0</span>) ? -(<span class="keyword">long</span>)a : (<span class="keyword">long</span>)a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> (a^x) - x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(abs(Integer.MIN_VALUE)); <span class="comment">// 2147483648</span></span><br><span class="line">    System.out.println(mathAbs(Integer.MIN_VALUE)); <span class="comment">// 2147483648</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="统计整数的二进制表示中1的个数"><a href="#统计整数的二进制表示中1的个数" class="headerlink" title="统计整数的二进制表示中1的个数"></a>统计整数的二进制表示中1的个数</h1><p>方法一较为暴力，直接从低位开始统计。第二种不知哪位大神写的，不明觉厉，性能上稍比第一种好。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countbit1</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count ++;</span><br><span class="line">        a &amp;= a - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countbit2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    x = x - ((x &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555_5555</span>);</span><br><span class="line">    x = (x &amp; <span class="number">0x3333_3333</span>) + ((x &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333_3333</span>);</span><br><span class="line">    x = (x + (x &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f_0f0f</span>; </span><br><span class="line">    x = x + (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    x = x + (x &gt;&gt; <span class="number">16</span>); </span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0x0000_003f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的文件遍历</title>
    <url>/article/2017/09/13/2017-09-13-%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>分别使用java中的<code>io</code>和<code>nio</code>遍历文件系统<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.zero.example.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.FileVisitResult;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.SimpleFileVisitor;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileExplorer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String uri = <span class="string">"D:\\apps"</span>;</span><br><span class="line">        walkFileTree(uri);</span><br><span class="line">        System.out.println(<span class="string">"\n*****************************************************"</span>);</span><br><span class="line">        showDirFiles(uri);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri 需要遍历的文件系统根目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDirFiles</span><span class="params">(String uri)</span> </span>&#123;</span><br><span class="line">        _walkDirFiles(<span class="keyword">new</span> File(uri), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用简单的文件访问，递归遍历 file路径下的所有目录及文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> level </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">_walkDirFiles</span><span class="params">(File file, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">"\t|"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(file.getName());</span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">for</span>(File temp : file.listFiles()) &#123;</span><br><span class="line">                _walkDirFiles(temp, level + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用nio包遍历文件系统</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri 需要遍历的文件系统根目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walkFileTree</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = Paths.get(uri);</span><br><span class="line">        <span class="comment">// 当前 uri在文件系统中的深度</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> rootdeep = getLevelByPath(path);</span><br><span class="line">        Files.walkFileTree(path, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// 当前遍历的文件在文件系统中的深度</span></span><br><span class="line">                <span class="keyword">int</span> level = getLevelByPath(file) - rootdeep;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;level; i++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">"\t|"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(file.getFileName().toString());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> level = getLevelByPath(dir) - rootdeep;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;level; i++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">"\t|"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(dir.getFileName().toString());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLevelByPath</span><span class="params">(Path path)</span> </span>&#123;</span><br><span class="line">        String separator = File.separator;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"\\"</span>.equals(separator)) &#123;    <span class="comment">// windows下的 \ 需特殊处理</span></span><br><span class="line">            separator = <span class="string">"\\\\"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path.toString().split(separator).length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>nio</tag>
      </tags>
  </entry>
  <entry>
    <title>找出成对数组中不成对的元素</title>
    <url>/article/2017/08/20/2017-08-20-%E6%89%BE%E5%87%BA%E6%88%90%E5%AF%B9%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%8D%E6%88%90%E5%AF%B9%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>题：2n+1长度的整型数组中，有且仅有一个元素不与其他元素相同，试用最小的资源找出该元素。</p>
<a id="more"></a>
<p>使用位操作，两个相同的数字异或运算之后结果为0的特性，通过异或运算找出2n+1长度的数字数组中的不成对的数字。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdiff</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		j ^= data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">13</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> res = getdiff(arr, <span class="number">11</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"diff in arr[1,3,5,7,9,1,3,5,7,9,13] is: "</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>延伸：在2n长度的整型数组中，找出有且仅有的两个不成对数字。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdiffTwo</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> *res)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j=<span class="number">0</span>, flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		j ^= arr[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找出这两个不成对数字中位上值不同的最低位</span></span><br><span class="line">	<span class="keyword">while</span>(!(j &amp; flag)) &#123;</span><br><span class="line">		flag &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找出其中一个不成对的数</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(flag &amp; arr[i]) &#123;</span><br><span class="line">			res[<span class="number">0</span>] ^= arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 另一个也就显而易见了</span></span><br><span class="line">	res[<span class="number">1</span>] = j ^ res[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">int</span> res[] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	getdiffTwo(arr, n, res);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"two diff in arr is: "</span>&lt;&lt;res[<span class="number">0</span>]&lt;&lt;<span class="string">" and "</span>&lt;&lt;res[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala之隐式转换(implicit)</title>
    <url>/article/2017/07/27/2017-07-27-Scala%E4%B9%8B%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2-implicit/</url>
    <content><![CDATA[<p>Implicits in Scala refers to either a value that can be passed “automatically”, so to speak, or a conversion from one type to another that is made automatically.<br>大意是讲<code>implicit</code>在scala中是指一个可以被自动转换的值，也就是说类型的转换是自动完成的。<br><a id="more"></a></p>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>譬如在方法入参限定为<code>String</code>类型的情况下，在调用该方法之前，通过声明隐式类型转换，就可以使该方法达到“重载”的效果：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span></span>(words: <span class="type">String</span>): <span class="type">Unit</span> = println(words.getClass + <span class="string">": "</span> + words)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convert2String</span></span>(value: <span class="type">Boolean</span>): <span class="type">String</span> = <span class="keyword">if</span> (value) <span class="string">"true"</span> <span class="keyword">else</span> <span class="string">"false"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convert2String</span></span>(value: <span class="type">Int</span>): <span class="type">String</span> = value.toString</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        display(<span class="string">"learning scala."</span>)</span><br><span class="line">        display(<span class="number">2</span>)</span><br><span class="line">        display(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">//      display(2.3)    // 报错,没有Double转String的声明和display(value: Double)的重载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class java.lang.String: learning scala.</span><br><span class="line">class java.lang.String: 2</span><br><span class="line">class java.lang.String: true</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意<br>隐式转换的声明要放置在需要使用隐式转换被调用之前，否则达不到隐式转换的效果，也就会报错。还有，当<code>display</code>这个方法有重载，使其传入的参数为<code>Boolean</code>类型，则scala会自动使用以声明的重载去完成方法的调用。<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span></span>(value: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;<span class="keyword">if</span>(value) println(<span class="string">"real true"</span>) <span class="keyword">else</span> println(<span class="string">"real false"</span>)&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>其运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class java.lang.String: learning scala.</span><br><span class="line">class java.lang.String: 2</span><br><span class="line">real true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>scala能智能的选择在何时使用隐式转换：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span></span>(words: <span class="type">String</span>): <span class="type">Unit</span> = println(words.getClass + <span class="string">": "</span> + words)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span></span>(value: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;<span class="keyword">if</span>(value) println(<span class="string">"real true"</span>) <span class="keyword">else</span> println(<span class="string">"real false"</span>)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convert2String</span></span>(value: <span class="type">Boolean</span>): <span class="type">String</span> = <span class="keyword">if</span> (value) <span class="string">"true"</span> <span class="keyword">else</span> <span class="string">"false"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convert2String</span></span>(value: <span class="type">Int</span>): <span class="type">String</span> = value.toString</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">displayInt1</span></span>(value: <span class="type">Int</span>): <span class="type">Unit</span> = println(value.getClass + <span class="string">": "</span> + value + <span class="number">12</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">displayInt2</span></span>(value: <span class="type">Int</span>): <span class="type">Unit</span> = println(value.getClass + <span class="string">": "</span> + value + <span class="string">"heheda"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        display(<span class="string">"learning scala."</span>)</span><br><span class="line">        display(<span class="number">2</span>)</span><br><span class="line">        display(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在此时虽然已经声明了Int对String的隐式转换，但以下都不会进行隐式转换</span></span><br><span class="line">        displayInt1(<span class="number">12</span>)</span><br><span class="line">        displayInt2(<span class="number">12</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>其运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class java.lang.String: learning scala.</span><br><span class="line">class java.lang.String: 2</span><br><span class="line">real true</span><br><span class="line">int: 1212</span><br><span class="line">int: 12heheda</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="隐式类型声明"><a href="#隐式类型声明" class="headerlink" title="隐式类型声明"></a>隐式类型声明</h2><p>隐式指定方法中参数的类型：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicit</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明foo的参数应为数值类型(BigInt,Long,Int,Char,Short,Byte都是Integral类型,可参见scala.math.Numeric)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>[<span class="type">T</span>](t: <span class="type">T</span>)(<span class="keyword">implicit</span> integral: <span class="type">Integral</span>[<span class="type">T</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(integral)</span><br><span class="line">        println(t.getClass + <span class="string">"\n--------------------------"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        foo(<span class="number">123</span>)</span><br><span class="line">        <span class="keyword">val</span> c: <span class="type">Char</span> = 'a'</span><br><span class="line">        foo(c)</span><br><span class="line">        <span class="keyword">val</span> b: <span class="type">Byte</span> = <span class="number">23</span></span><br><span class="line">        foo(b)</span><br><span class="line">        <span class="keyword">val</span> s: <span class="type">Short</span> = <span class="number">3</span></span><br><span class="line">        foo(s)</span><br><span class="line"><span class="comment">//      以下代码报错</span></span><br><span class="line"><span class="comment">//      val d: Double = 2.3</span></span><br><span class="line"><span class="comment">//      foo(d)</span></span><br><span class="line"><span class="comment">//      val str: String = "string"</span></span><br><span class="line"><span class="comment">//      foo(str)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scala.math.Numeric$IntIsIntegral$@56cbfb61</span><br><span class="line">class java.lang.Integer</span><br><span class="line">--------------------------</span><br><span class="line">scala.math.Numeric$CharIsIntegral$@6bdf28bb</span><br><span class="line">class java.lang.Character</span><br><span class="line">--------------------------</span><br><span class="line">scala.math.Numeric$ByteIsIntegral$@27f674d</span><br><span class="line">class java.lang.Byte</span><br><span class="line">--------------------------</span><br><span class="line">scala.math.Numeric$ShortIsIntegral$@43a25848</span><br><span class="line">class java.lang.Short</span><br><span class="line">--------------------------</span><br></pre></td></tr></table></figure></p>
<h2 id="隐式声明默认值"><a href="#隐式声明默认值" class="headerlink" title="隐式声明默认值"></a>隐式声明默认值</h2><p>在方法参数列表中，对参数使用<code>implicit</code>声明，则在不传该参数的时候，则该参数会使用隐式声明的值：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        printDefault(<span class="string">"hello"</span>)(<span class="string">"world"</span>)</span><br><span class="line">        <span class="comment">// 导入隐式声明</span></span><br><span class="line">        <span class="keyword">import</span> <span class="type">DefaultValueImplicitContext</span>._</span><br><span class="line">        printDefault(<span class="string">"hello"</span>)   <span class="comment">// 第二个参数未赋值,则使用默认值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">object</span> <span class="title">DefaultValueImplicitContext</span> </span>&#123;</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">val</span> defaultString: <span class="type">String</span> = <span class="string">"WORLD"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 柯里化,使用implicit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printDefault</span></span>(prefix: <span class="type">String</span>)(<span class="keyword">implicit</span> suffix: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(prefix + <span class="string">" "</span> + suffix)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello WORLD</span><br></pre></td></tr></table></figure></p>
<h2 id="扩展类的功能"><a href="#扩展类的功能" class="headerlink" title="扩展类的功能"></a>扩展类的功能</h2><p>还可以通过隐式声明，通过非继承的方式扩展类的功能：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicit</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 声明只有一个功能(shot)的类</span></span><br><span class="line"><span class="comment">    * @param bullet 子弹数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Gun</span>(<span class="params">val bullet: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">shot</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            printf(<span class="string">"Gun can shot %d times. \n"</span>, bullet)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查子弹的数量</span></span><br><span class="line"><span class="comment">     * 隐式转换不是通过继承拓展类功能，而是将类作为隐式转换类的参数，传入，并将其功能进行增强</span></span><br><span class="line"><span class="comment">     * @param gun</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">GunExt</span>(<span class="params">gun: <span class="type">Gun</span></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            printf(<span class="string">"Gun has %d bullets. \n"</span>, gun.bullet)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> gun: <span class="type">Gun</span> = <span class="keyword">new</span> <span class="type">Gun</span>(<span class="number">6</span>)</span><br><span class="line">        gun.shot()</span><br><span class="line">        gun.check() <span class="comment">// 通过增强的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Gun can shot 6 times. </span><br><span class="line">Gun has 6 bullets.</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意</p>
<ul>
<li>使用<code>implicit</code>跟声明时候的名称没有关系</li>
<li>声明隐式默认值时,同一种数据类型只能声明一个,以下使用是会报错的：<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DefaultValueImplicitContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> defaultString: <span class="type">String</span> = <span class="string">"WORLD"</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> defaultString2: <span class="type">String</span> = <span class="string">"WORLD2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>一个方法只会有一个隐式参数列表，且置于方法的最后一个参数列表（柯里化）。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
        <tag>implicit</tag>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title>nio的文件读写</title>
    <url>/article/2017/09/26/2017-09-26-nio%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<p>JDK中对IO的操作提供<code>io</code>和<code>nio</code>两个包，在这两个包中可以看到在<code>io</code>包中，类名多以Stream结尾，而<code>nio</code>包中多以<code>Buffer</code>结尾。Java中NIO与IO的最大区别是IO面向<strong>流(Stream)</strong>的，NIO是面向<strong>缓冲(Buffer)</strong>。面向流意味着每次从流中读一个或多个字节，直至读取所有字节，读取的内容没有被缓存在任何地方，而且是顺序读取，它不能前后移动流中的数据，如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法略有不同，数据读取到一个可以稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据（譬如读入缓冲区中的数据不是一条完整的数据，需要与下一次读取的内容拼接），而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<a id="more"></a>
<h1 id="四种IO模型"><a href="#四种IO模型" class="headerlink" title="四种IO模型"></a>四种IO模型</h1><p>同步和异步说的是消息的通知机制，阻塞非阻塞说的是线程的状态。一般来说 I/O 模型可以分为：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞，四种IO模型：</p>
<blockquote>
<p>参考链接：<a href="https://www.zhihu.com/question/27991975/answer/69041973" target="_blank" rel="noopener">https://www.zhihu.com/question/27991975/answer/69041973</a> 作者：郭无心</p>
</blockquote>
<h2 id="同步阻塞-IO"><a href="#同步阻塞-IO" class="headerlink" title="同步阻塞 IO"></a>同步阻塞 IO</h2><p>在此种方式下，用户进程在发起一个 IO 操作以后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作以后，用户进程才能运行。Java传统的 IO 模型属于此种方式。</p>
<h2 id="同步非阻塞-IO"><a href="#同步非阻塞-IO" class="headerlink" title="同步非阻塞 IO"></a>同步非阻塞 IO</h2><p>在此种方式下，用户进程发起一个 IO 操作以后便可返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。其中目前 Java 的 NIO 就属于同步非阻塞 IO。</p>
<h2 id="异步阻塞-IO"><a href="#异步阻塞-IO" class="headerlink" title="异步阻塞 IO"></a>异步阻塞 IO</h2><p>此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问 IO 是否完成，那么为什么说是阻塞的呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式是阻塞的，而采用 select 函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性。</p>
<h2 id="异步非阻塞-IO"><a href="#异步非阻塞-IO" class="headerlink" title="异步非阻塞 IO"></a>异步非阻塞 IO</h2><p>在此种模式下，用户进程只需要发起一个 IO 操作然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为真正的 IO 读取或者写入操作已经由内核完成了。目前 Java 中还没有支持此种 IO 模型。</p>
<blockquote>
<p>所有的Java IO流都是阻塞的，这意味着，当一条线程执行read()或者write()方法时，这条线程会一直阻塞知道读取到了一些数据或者要写出去的数据已经全部写出，在这期间这条线程不能做任何其他的事情。而java NIO的非阻塞模式<strong>(Java NIO有阻塞模式和非阻塞模式，阻塞模式的NIO除了使用Buffer存储数据外和IO基本没有区别)</strong>允许一条线程从channel中读取数据，通过返回值来判断buffer中是否有数据，如果没有数据，NIO不会阻塞，因为不阻塞这条线程就可以去做其他的事情，过一段时间再回来判断一下有没有数据。NIO的写也是一样的，一条线程将buffer中的数据写入channel，它不会等待数据全部写完才会返回，而是调用完write()方法就会继续向下执行。</p>
</blockquote>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><h2 id="io的读写"><a href="#io的读写" class="headerlink" title="io的读写"></a>io的读写</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * io读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadIO</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String path = <span class="string">"build.gradle"</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">try</span>(BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file)))&#123;</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = reader.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">// 顺序读</span></span><br><span class="line">            buffer.append(line).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * io写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restWriteIO</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String path = <span class="string">"dist.tmp"</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">try</span>(BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file))) &#123;</span><br><span class="line">        writer.write(<span class="string">"Writer IO \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nio的读写"><a href="#nio的读写" class="headerlink" title="nio的读写"></a>nio的读写</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nio 使用 channel读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String path = <span class="string">"build.gradle"</span>;</span><br><span class="line">    <span class="comment">// 获取文件流</span></span><br><span class="line">    <span class="keyword">try</span>(FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(path))) &#123;</span><br><span class="line">        <span class="comment">// 获取channel</span></span><br><span class="line">        FileChannel channel = fis.getChannel();</span><br><span class="line">        System.out.println(<span class="string">"file channel size: "</span> + channel.size());</span><br><span class="line">        <span class="comment">// 指定缓冲区(设置合理缓冲区大小)</span></span><br><span class="line">        ByteBuffer bbuffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">        <span class="comment">// channel读取到buffer,可单独对该 bbuffer进行操作</span></span><br><span class="line">        <span class="keyword">int</span> flag = channel.read(bbuffer);</span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        <span class="keyword">while</span>(flag &gt; <span class="number">0</span>) &#123;    <span class="comment">// flag == -1 时表示未读到内容</span></span><br><span class="line">            <span class="comment">// channel读取到buffer</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = bbuffer.array();</span><br><span class="line">            <span class="comment">// byte[] to string(粗略的做法，因为缓冲区中读入的内容可能并不是一个完整的行，甚至包含半个字符——譬如中文字符)</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(bytes));</span><br><span class="line">            bbuffer.clear();    <span class="comment">// 再次读之前清空缓冲区</span></span><br><span class="line">            flag = channel.read(bbuffer);</span><br><span class="line">            bbuffer.flip(); <span class="comment">// 读完之后声明缓冲区待处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nio 使用channel写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String path = <span class="string">"dist.tmp"</span>;</span><br><span class="line">    <span class="keyword">try</span>(FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(path), <span class="keyword">true</span>);</span><br><span class="line">            FileChannel channel = fos.getChannel()) &#123;</span><br><span class="line">        channel.write(ByteBuffer.wrap(<span class="string">"Hello, world! \n"</span>.getBytes()));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>nio</tag>
      </tags>
  </entry>
  <entry>
    <title>Java关于线程的小知识</title>
    <url>/article/2017/10/10/2017-10-10-Java%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>关于<code>Thread</code>的一些tips。</p>
<a id="more"></a>
<h1 id="处理未捕捉的异常"><a href="#处理未捕捉的异常" class="headerlink" title="处理未捕捉的异常"></a>处理未捕捉的异常</h1><p>在JVM运行时，当一个线程抛出一个运行时异常，JVM是怎么处理这个异常的，遇到这种情况，这种“漏网”的异常又该怎么正确处理。我们可以通过实现<code>UncaghtExceptionHandler</code>接口，处理用户未catch，且逃脱到JVM的异常。首先声明<code>UncaghtExceptionHandler</code>的实现类，将该<code>Handler</code>注册到程序中：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread.UncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"Thead: name[%s], status[%s] \n"</span>, t.getName(), t.getState());</span><br><span class="line">            System.out.printf(<span class="string">"Exception: [%s] \n"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExceptionThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"Thread [%s] is running. \n"</span>, getName());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Man made exception for "</span> + getName() + <span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> ExceptionThread(<span class="string">"sama"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>以上通过<code>Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</code>向程序中注册默认的未捕捉异常处理Handler，其运行结果如下，可以看到在<code>MyUncaughtExceptionHandler</code>中对未手动<code>catch</code>到的异常信息进行处理。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main thread terminated.</span><br><span class="line">Thread [sama0] is running. </span><br><span class="line">Thead: name[sama0], status[RUNNABLE] </span><br><span class="line">Exception: [Man made exception for sama0.] </span><br><span class="line">Thread [sama5] is running. </span><br><span class="line">Thead: name[sama5], status[RUNNABLE] </span><br><span class="line">Exception: [Man made exception for sama5.] </span><br><span class="line">Thread [sama4] is running. </span><br><span class="line">Thead: name[sama4], status[RUNNABLE] </span><br><span class="line">Exception: [Man made exception for sama4.] </span><br><span class="line">Thread [sama3] is running. </span><br><span class="line">Thread [sama2] is running. </span><br><span class="line">Thead: name[sama2], status[RUNNABLE] </span><br><span class="line">Exception: [Man made exception for sama2.] </span><br><span class="line">Thread [sama1] is running. </span><br><span class="line">Thead: name[sama3], status[RUNNABLE] </span><br><span class="line">Exception: [Man made exception for sama3.] </span><br><span class="line">Thead: name[sama1], status[RUNNABLE] </span><br><span class="line">Exception: [Man made exception for sama1.]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="What-is-a-shutdown-hook"><a href="#What-is-a-shutdown-hook" class="headerlink" title="What is a shutdown hook?"></a>What is a shutdown hook?</h1><p>“终止钩子”是什么，终止钩子是在JVM终止运行时会执行的一个线程，它可以通过获取运行时环境的<code>addShutdownHook(Thread)</code>添加，如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestShutdownHook</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">"Sleep thread execute over."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">        runtime.addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"The first shutdown hook executing."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        runtime.addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"The second shutdown hook executing."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> SleepThread().start();</span><br><span class="line">        System.out.println(<span class="string">"main thread execute over."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>运行结果为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main thread execute over.</span><br><span class="line">Sleep thread execute over.</span><br><span class="line">The first shutdown hook executing.</span><br><span class="line">The second shutdown hook executing.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>如果将第一个hook thread的休眠时间设的比第二个长，则执行结果为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main thread execute over.</span><br><span class="line">Sleep thread execute over.</span><br><span class="line">The second shutdown hook executing.</span><br><span class="line">The first shutdown hook executing.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>因为<code>Runtime.addShutdownHook(Thread)</code>中，是调用<code>ApplicationShutdownHooks.add(Thread)</code>将Hook Thread添加到<code>IdentityHashMap&lt;Thread, Thread&gt; hooks</code>中，而执行终止钩子线程的方法为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runHooks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;Thread&gt; threads;</span><br><span class="line">    <span class="keyword">synchronized</span>(ApplicationShutdownHooks<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        threads = hooks.keySet();</span><br><span class="line">        hooks = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        hook.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hook.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException x) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>是将所有的终结钩子线程一起启动，然后通过<code>join()</code>等待他们都执行完成，<code>runHooks()</code>才结束。</p>
</blockquote>
<h1 id="Thread-amp-Runnable"><a href="#Thread-amp-Runnable" class="headerlink" title="Thread &amp; Runnable"></a>Thread &amp; Runnable</h1><p>继承Thread或实现Runnable并将实现传入Thread都可以声明一个线程，不同的是，调用Runnable的<code>run()</code>方法是不会起一个线程：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadRunnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"thread01"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"this is thread01. name: "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="string">"thread02"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"this is thread02. name: "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的执行结果如下，可知在调用Runnable的<code>run()</code>方法，在<code>run()</code>方法体内获取到的当前线程还是主线程 main，所以正确的启动一个线程的方法是调用Thread的<code>start()</code>方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is thread01. name: thread01</span><br><span class="line">this is thread02. name: main</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>盘点一下JDK中的那些工具类-Arrays</title>
    <url>/article/2017/11/01/2017-11-01-%E7%9B%98%E7%82%B9%E4%B8%80%E4%B8%8BJDK%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB-Arrays/</url>
    <content><![CDATA[<p><code>java.util.Arrays</code>工具类是对集合操作的工具集合，其中包含的工具主要有排序，查找，比较，填充，拷贝，计算Hash值，集合转字符串，枚举，以及集合转流。作为一个工具类，它的构造方法为私有，这样就避免了工具方法被用户实例化的尴尬，同时，它的工具方法都是公开的静态方法。</p>
<a id="more"></a>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>数组的排序是编程界比较基础的算法，Arrays提供常用数据类型byte, char, short, int, long, double的排序方法，同时提供实现了<code>Comparable</code>的类型数组的排序，以及能通过<code>Comparator</code>外排序类型的数组的排序。所有通过<code>sort</code>排序的结果都为升序(ascending numerical order).排序方法的实现采用<strong>双枢轴快速排序</strong>(1.7)，时间复杂度为<code>O(n log(n))</code>.除了一半的排序实现，在jdk1.8中，提供了并行排序的方法实现<code>parallelSort</code>，在需要排序的数组长度小于等于8192时仍采用以上单线程(串行)排序算法实现，当需要排序的数组长度大于8192时则采用</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Object中的wait/notify</title>
    <url>/article/2017/10/13/2017-10-13-Object%E4%B8%AD%E7%9A%84wait-notify/</url>
    <content><![CDATA[<p>Java中的基类Object中，有 <code>notify()</code>, <code>notifyAll()</code>, <code>wait(long)</code>, <code>wait(long, int)</code>, <code>wait()</code>方法，在非Thread类型中，可以通过这些方法实现多线程之间的通信和互斥。</p>
<a id="more"></a>
<p>在以上方法中，前三个为native实现，<code>wait(long, int)</code>和<code>wait()</code>是对<code>wait(long)</code>的拓展，其中<code>wait()</code>即是<code>wait(0)</code>，而<code>wait(long, int)</code>第二个int类型参数是传入纳秒值，实际情况是当该值大于0的情况下，第一个long型参数值加一，并不会具体实现纳秒级的wait操作。<br>对象的<code>wait</code>操作会引起当前线程让出锁，直到该对象的<code>notify</code>或<code>notifyAll</code>被调用，或者<code>wait</code>操作传入的时间过期之后才会重新竞争锁，并在获取到锁之后再继续执行。<strong>换一种说法就是调用<code>wait()</code>方法的线程必须在一个已获取到锁的代码块中调用</strong>。按理来说，在<code>synchronized</code>代码块中能保持属于的一致性，但是在同步代码块中有被锁的对象调用<code>wait()</code>的情况下，在被锁对象调用<code>wait()</code>方法时候会释放掉已拥有的锁，在再次获取到锁之后继续执行，也就是说，在有被锁对象的<code>wait()</code>操作的同步代码块中，从<code>wait()</code>操作到同步代码块结束才是一个单位的操作，<strong>所以如果在同步代码块中被锁对象调用<code>wait()</code>方法之前对该对象进行的更改都属于非法的操作</strong>，即无法保证操作的一致性，但它的其他操作确实允许的，因为该<code>synchronized</code>只对被锁的对象保证线程安全。<br>如下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> Integer obj = Integer.valueOf(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> Integer ext = Integer.valueOf(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoWaitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line"><span class="comment">//                  obj++;  // 该操作会在obj调用wait时引起 IllegalMonitorStateException 异常</span></span><br><span class="line">                    ext++;</span><br><span class="line">                    System.out.println(<span class="string">"DoWaitThread: before wait... obj="</span> + obj + <span class="string">", ext="</span> + ext);</span><br><span class="line">                    obj.wait();</span><br><span class="line">                    obj++;</span><br><span class="line">                    ext++;</span><br><span class="line">                    System.out.println(<span class="string">"DoWaitThread: after wait... obj="</span> + obj + <span class="string">", ext="</span> + ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"DoWaitThread: exception occurred"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoNotifyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"DoNotifyThread: before notify... obj="</span> + obj + <span class="string">", ext="</span> + ext);</span><br><span class="line">                    obj.notifyAll();    <span class="comment">// 该通知释放锁是要在该同步块结束之后才会正式释放锁，若无该操作则DoWaitThread的wait之后的操作仍继续等待。</span></span><br><span class="line">                    obj++;</span><br><span class="line">                    ext++;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"DoNotifyThread: after notify... obj="</span> + obj + <span class="string">", ext="</span> + ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"DoNotifyThread: exception occurred"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWaitNotify</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread w = <span class="keyword">new</span> DoWaitThread();</span><br><span class="line">        Thread n = <span class="keyword">new</span> DoNotifyThread();</span><br><span class="line">        w.start();</span><br><span class="line">        n.start();</span><br><span class="line">        w.join();</span><br><span class="line">        n.join();</span><br><span class="line">        System.out.println(<span class="string">"obj="</span> + obj + <span class="string">", ext="</span> + ext);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上测试执行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DoWaitThread: before wait... obj=0, ext=1</span><br><span class="line">DoNotifyThread: before notify... obj=0, ext=1</span><br><span class="line">DoNotifyThread: after notify... obj=1, ext=2</span><br><span class="line">DoWaitThread: after wait... obj=2, ext=3</span><br><span class="line">obj=2, ext=3</span><br></pre></td></tr></table></figure></p>
<p>可见是在DoWaitThread中<code>obj.wait()</code>之后就让出了锁，由DoNotifyThread获取到锁，在DoNotifyThread中notify，当DoNotifyThread释放锁之后，DoWaitThread继续执行。如果注释掉DoNotifyThread中的<code>obj.notifyAll();</code>则DoWaitThread将一直处于等待状态。如果将DoWaitThread中的<code>wait()</code>替换成<code>wait(2000L)</code>,则在DoNotifyThread执行完之后，DoWaitThread可再次获取到锁，并在超时之后继续执行。如果DoWaitThread中的<code>wait()</code>替换成<code>wait(500L)</code>，即DoWaitThread可在DoNotifyThread还未获取到锁之前等待时间超时，则可再获取到锁，则其执行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DoWaitThread: before wait... obj=0, ext=1</span><br><span class="line">DoWaitThread: after wait... obj=1, ext=2</span><br><span class="line">DoNotifyThread: before notify... obj=1, ext=2</span><br><span class="line">DoNotifyThread: after notify... obj=2, ext=3</span><br><span class="line">obj=2, ext=3</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Object的<code>wait()</code>方法的线程需在该对象上锁的情况下被调用。<br>notify是唤醒单个正在等待中的线程，如果有多个线程正在等待，则值唤醒一个，而notifyAll是唤醒所有等待的线程，且不管会由哪个线程能竞争到该对象的锁。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>thread</tag>
        <tag>jdk阅读计划</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven生命周期</title>
    <url>/article/2017/10/16/2017-10-16-Maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>Maven生命周期。</p>
<a id="more"></a>
<h2 id="maven生命周期"><a href="#maven生命周期" class="headerlink" title="maven生命周期"></a>maven生命周期</h2><ol>
<li>process-resources# resources:resources</li>
</ol>
<p>复制<code>src/main/resources</code>下的文件到<code>target/resources</code>目录下</p>
<p>compile# compiler:compile</p>
<blockquote>
<p>process-classes<br>process-test-resources# resources:testResources<br>test-compile<br>test-compile<br>test<br>prepare-package<br>package</p>
</blockquote>
]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>盘点一下JDK中的那些工具类-Math</title>
    <url>/article/2017/11/01/2017-11-01-%E7%9B%98%E7%82%B9%E4%B8%80%E4%B8%8BJDK%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB-Math/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>盘点一下JDK中的那些工具类-Collections</title>
    <url>/article/2017/11/01/2017-11-07-%E7%9B%98%E7%82%B9%E4%B8%80%E4%B8%8BJDK%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB-Collections/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>盘点一下JDK中的那些工具类-Collectors</title>
    <url>/article/2017/11/01/2017-11-14-%E7%9B%98%E7%82%B9%E4%B8%80%E4%B8%8BJDK%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB-Collectors/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap剖析</title>
    <url>/article/2017/12/13/2017-12-13-HashMap%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>HashMap在Java中除了集合(Collection)类型应该是用得最多的处理K-V（键值对）映射关系数据的数据结构，如其名HashMap，其中比较重要的”Hash”部分即为了表示元素被哈希存储到指定位置，也通过哈希去重，譬如HashSet所用的存储方案就是通过HashMap的key部分存储元素，而所有value都是一个空对象(<code>private static final Object PRESENT = new Object();</code>).对于一个出现频率极高的数据结构，了解其底层实现有助于更优雅、高效地使用它。<br><a id="more"></a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>几乎所有Key-Value结构的数据结构都实现<code>java.util.Map&lt;K, V&gt;</code>接口，且实现对键值对的集合常用的操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">size()</span><br><span class="line">isEmpty()</span><br><span class="line">containsKey(Object)</span><br><span class="line">containsValue(Object)</span><br><span class="line">get(Object)</span><br><span class="line">put(K, V)</span><br><span class="line">putAll(Map&lt;K, V&gt;)</span><br><span class="line">remove(Object)</span><br><span class="line">clear()</span><br><span class="line">keySet()</span><br><span class="line">values()</span><br><span class="line">entrySet()</span><br></pre></td></tr></table></figure></p>
<p>而在jdk中Map的实现主要有以下几种：HashMap, LinkedHashMap, TreeMap, WeakHash, Ident ityHashMap, 继承字典的 Hashtable和 Properties, 以及并发包下的实现 ConcurrentHashMap以及 ConcurrentSkipListMap.<br><img src="/images/coding/Map-Class-Diagram.png" alt="Map-Class-Diagram" title="JDK中Map类继承关系图"></p>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap作为最常用的K-V数据结构，</p>
<h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><h1 id="ConcurrentMap"><a href="#ConcurrentMap" class="headerlink" title="ConcurrentMap"></a>ConcurrentMap</h1><h1 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h1>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk阅读计划</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal剖析</title>
    <url>/article/2017/12/20/2017-12-20-ThreadLocal%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>ThrealLocal顾名思义是提供在当前线程内存中增加并操作对象的一个工具类，也即是对当前线程内存空间的一个掌控，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定[1]。对象的绑定或者隐射很容易就让人想到这事Map类型的操作，ThreadLocal中的确对象的绑定是通过map的方式，只不过并没有直接使用到jdk中常用Map的实现。通过阅读源码，让我再一次重温了引用(Reference)[2]相关的知识。</p>
<a id="more"></a>
<p><em>以下分析基于jdk1.8</em></p>
<h1 id="ThreadLocal对象的唯一性"><a href="#ThreadLocal对象的唯一性" class="headerlink" title="ThreadLocal对象的唯一性"></a>ThreadLocal对象的唯一性</h1><p>既然对象是绑定在线程上，基于Map的设计思想，线程作为Key，绑定的对象为Value，即必须保证Key在绑定关系表上是唯一性的，ThreadLocal通过三个简单的属性轻松解决了这个问题：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每产生一个ThreadLocal实例，就更新下一次的 hashCode</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原子操作(CAS)并自动更新产生下一个 hashCode，保证唯一性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">// hashCode 每次更新增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get and update</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以知道第一个ThreadLocal实例的hashCode为0(hashCode的数据类型为 int), 增量是 0x61c88647, 这已经是一个很大的数了，也就是说即之后第 N个 ThreadLocal实例的 hashCode为 <code>(N-1)*0x61c88647</code>, 但第二个ThreadLocal的实例就已经超过 <code>Integer.MAX_VALUE</code>了，也就是数据范围溢出了，回到Map的设计思想上来，我们都知道HashMap为什么一般使用String作为Key就是因为String的Hash算法在去重上面足够严谨（这里就不讨论了，毕竟扩展太多），也就是说，这个增量肯定是有考究的，也就考虑到在该hashCode值溢出的情况下仍能尽量保证不重复（重复是必然的，毕竟int存储范围也就 Integer.MIN_VALUE[-2147483648]~Integer.MAX_VALUE[2147483647]），通过实际计算也证明了这是一个很具有魔力的数字。既然知道了意图，那就验证一下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = Integer.MAX_VALUE &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span>(; n &lt; size; n++) &#123;</span><br><span class="line">        set.add(nextHashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"n: "</span> + n + <span class="string">", size: "</span> + set.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法有点笨，不敢size直接等于Integer.MAX_VALUE，在尝试降到 <code>33554431(Integer.MAX_VALUE &gt;&gt; 6)</code>（此时堆的使用达到近 3.5个G，再翻个番我机器就要受不鸟了）的情况下仍能保证唯一性（数学好的可以从数学维度上给点提示，先感谢），即：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n: 33554431, size: 33554431</span><br></pre></td></tr></table></figure></p>
<h1 id="ThreadLocal详情"><a href="#ThreadLocal详情" class="headerlink" title="ThreadLocal详情"></a>ThreadLocal详情</h1><p>保证了ThreadLocal对象（即Map的Key）hashCode的唯一性，作为其值（Value）的生命周期应与键（Key）一致，ThreadLocal中用来保存对象的类型是<code>ThreadLocal.ThreadLocalMap.Entry</code>，这个<code>Entry</code>继承<code>java.lang.ref.WeakReference&lt;T&gt;</code>即弱引用，且将ThreadLocal对象作为弱引用类型<code>T</code>，弱引用的性质就是当它没有被引用时就立即清除，而对ThreadLocalMap对象的引用是属于Thread对象中的属性，故Thread对象被destory之后该引用即失效，从而达到能被及时清除的效果。而ThradLocalMap是ThreadLocal的内部静态类，<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ThreadLocal的构造方法"><a href="#ThreadLocal的构造方法" class="headerlink" title="ThreadLocal的构造方法"></a>ThreadLocal的构造方法</h2><p>构造方法体中内容为空，却注释让我们查看<code>#withInitial(java.util.function.Supplier)</code>，即除了通过<code>new ThreadLocal()</code>的方式，还可以通过调用 ThreadLocal的静态方法<code>public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier)</code>获取ThreadLocal实例。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a thread local variable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #withInitial(java.util.function.Supplier)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Supplier(@FunctionalInterface)即为ThreadLocal绑定对象的产生器(since 1.8)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在对ThreadLocal绑定的对象的set/get方法处理上：</p>
<h2 id="ThreadLocalMap的”put”"><a href="#ThreadLocalMap的”put”" class="headerlink" title="ThreadLocalMap的”put”"></a>ThreadLocalMap的”put”</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  @Thread#ThreadLocal.ThreadLocalMap threadLocals = null; threadLocals是Thread对象中的一个 "friendly"的属性。</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map.set(this, value) </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">            e != <span class="keyword">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ThreadLocalMap.nextIndex(i, len)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// replaceStaleEntry(key, value, i)</span></span><br><span class="line"><span class="comment">// 有点长，略</span></span><br></pre></td></tr></table></figure>
<p>ThreadLocalMap也是通过数组<code>Entry[] table</code>的方式存放（初始化容量是16，在ThreadLocalMap对象实例化的时候指定），通过ThreadLocal的 hashCode确定对象存放的位置，与HashMap不同的是，在Hash冲突的时候，通过环的方式，从hash到的位置开始，一次向后遍历，如果发现有空的位置（可能是本来就为空的位置，或者已经过期的线程占有的位置）就将这个值存放进去（这里用的是 replace）。<strong>每有一个Entry加入，都要重新检查并调整数组的结构</strong>，即先清理一些已经无效的Entry，<strong>当ThreadLocal中没有绑定对象了，这个Entry会被认为是无效的</strong>，<strong>如果ThreadLocal引用已经失效了，但对应的Entry仍存在，则也需要将这个Entry标识为失效</strong>，失效的Entry占有的位置将会被清理出来，这也就是所谓的”启发式的垃圾清理”；<strong>当数组中的元素达到数组容量的2/3（即容量的阈值，参考Collection结构的阈值）时，对数组进行rehash，在rehash过程中又会进行一次”垃圾清理”，清理过后如果size还大于阈值的3/4，则会对存储的数组扩容。</strong></p>
<h2 id="ThreadLocalMap的”get”"><a href="#ThreadLocalMap的”get”" class="headerlink" title="ThreadLocalMap的”get”"></a>ThreadLocalMap的”get”</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map.getEntry(this) </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get</code>方法，先通过<code>Thread.currentThread()</code>获取到当前线程，通过<code>getMap(t)</code>取得当前线程具有的 ThreadLocalMap对象，然后根据hash到table中获取这个Entry，如果发现没找到，即可能在容量有变更的情况下（resize过），采取<code>getEntryAfterMiss</code>的方式，从应该出现的位置开始依次遍历查找，这里需要注意的是，每次遍历到<code>k</code>为null的情况下，都会进行一次<code>expungeStaleEntry(i)</code>操作。如果<code>getMap(t)</code>获取到的值为null的情况，即还没调用<code>set</code>的情况下先<code>get</code>了，则会通过<code>setInitialValue()</code>方法进行初始化：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();   <span class="comment">// initialValue() 方法是提供给 ThreadLocal子类实现的初始化方法</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即主要是创建 ThreadLocalMap对象，并把这个对象赋给当前线程的<code>threadLocals</code>变量。</p>
<h2 id="ThreadLocalMap的”remove”"><a href="#ThreadLocalMap的”remove”" class="headerlink" title="ThreadLocalMap的”remove”"></a>ThreadLocalMap的”remove”</h2><p>ThreadLocal的remove方法会触发ThreadLocalMap的<code>remove(ThreadLocal)</code>方法，这样就会将该Entry&lt;ThreadLocal, Object&gt;从ThreadLocalMap的table中清除。关于remove的描述:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the current thread's value for this thread-local</span></span><br><span class="line"><span class="comment">     * variable.  If this thread-local variable is subsequently</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span></span><br><span class="line"><span class="comment">     * reinitialized by invoking its &#123;<span class="doctag">@link</span> #initialValue&#125; method,</span></span><br><span class="line"><span class="comment">     * unless its value is &#123;<span class="doctag">@linkplain</span> #set set&#125; by the current thread</span></span><br><span class="line"><span class="comment">     * in the interim.  This may result in multiple invocations of the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> initialValue&#125; method in the current thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"># InheritableThreadLocal</span><br><span class="line">在ThreadLocal的`getMap(t)`方法中可以知道`threadLocals`是Thread类的属性，与`threadLocals`属性并列的还有`inheritableThreadLocals`，InheritableThreadLocal是ThreadLocal的子类，通过名称也可以推断出来，与ThreadLocal不同的是，**InheritableThreadLocal允许一个线程以及该线程创建的所有子线程都可以访问它保存的值。**对应的，TheadLocal中也有创建InheritableThreadLocal的静态方法，且创建的对象会包含其父线程中具有的 ThreadLocalMap数据。</span><br><span class="line">```java</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>ThreadLocal是提供放置一个同一个线程在任何时候访问结果都是一致的本地变量的工具。</li>
<li>线程结束，ThreadLocalMap新的元素set、set(null)，remove()被调用，等情况都会导致ThreadLocalMap中的Entry对象被标识为staled(过期)，从而会在新元素插入时被清理。</li>
</ul>
<p>ThreadLocal使用到的场景很多，主要是可以用它来取代方法调用之间使用的传参传递线程中需要用到的参数，譬如单机应用的requestNo的传递，分布式锁的使用场景[3]（即在释放锁操作中通过验证该锁是否为当前线程获取的锁来判断本次锁的释放是否拥有权限，如果不是当前线程获取的锁，那当前线程就没有权限去释放这个锁）。</p>
<p>参考：<br>[1] <a href="http://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/" title="借鉴-sczyh30的表述" target="_blank" rel="noopener">并发编程 | ThreadLocal源码深入分析</a><br>[2] <a href="/article/2018/01/26/2018-01-26-Java引用类型/" title="站内文章-Java引用类型">引用类型</a><br>[3] <a href="/article/2018/01/23/2018-01-23-Redis实现分布式锁/" title="站内文章-Redis实现分布式锁">Redis实现分布式锁</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
        <tag>jdk阅读计划</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>对象创建模式Builder</title>
    <url>/article/2017/12/26/2017-12-26-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8FBuilder/</url>
    <content><![CDATA[<p>前两天听到有同事抱怨有人的代码中使用<code>and属性名(属性值)</code>的方式创建对象，很不方便，还是提供属性的<code>Getter</code>/<code>Setter</code>方法更好些，听到他这样抱怨的时候我还花了点时间给他讲了采用这种方式创建对象的好处——这种对象创建的方式是为了保护对象在创建之后就不允许被更改。同时也想到这么好的设计模式时很值得学习的，且做个记录。</p>
<a id="more"></a>
<h1 id="一般对象实例化"><a href="#一般对象实例化" class="headerlink" title="一般对象实例化"></a>一般对象实例化</h1><p>一般对象通过构造方法进行实例化，即通过<code>new Object()</code>的方式，在不声明构造方法的情况下，java默认会有无参的构造方法，也可以通过<code>public T(Object ...)</code>的方式创建具有构造参数的构造方法。</p>
<h1 id="私有构造方法的情况"><a href="#私有构造方法的情况" class="headerlink" title="私有构造方法的情况"></a>私有构造方法的情况</h1><p>一般情况下，枚举类型应采用私有构造方法的情况，毕竟枚举类型中的枚举值是应在枚举类创建好之后就应指定（不排除其他的需求），那么会将枚举类型的构造方法设为私有，以保证枚举列表不被破坏。</p>
<h1 id="Builder-对象创建模式"><a href="#Builder-对象创建模式" class="headerlink" title="Builder 对象创建模式"></a>Builder 对象创建模式</h1><p>什么情况下需要使用到 Builder的方式去构建对象。如果说只是为了去掉过多的<code>Setter</code>方法去为属性赋值，那完全可以公有其属性（即用public修饰），也就是说，<strong>Builder方式创建的对象一般是需要对属性保护的对象，一旦对象被创建，其内容将不可变</strong>，为了达到该目的，很容易让人想到被保护的属性需私有化，而能够访问其私有属性的<code>Setter</code>方法的只有通过内部类的方式实现，譬如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Builder模式创建对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年12月26日 上午1:04:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 名字(被保护的属性,无Setter方法) */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/** 性别(被保护的属性,无Setter方法) */</span></span><br><span class="line">    <span class="keyword">private</span> String gendar;</span><br><span class="line">    <span class="comment">/** 年龄(可变的属性) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 私有化其构造方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGendar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gendar;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 创建构造器 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Builder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 静态内部类-Builder */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Person person = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/** 创建Builder的时候创建 Person实例 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            person = <span class="keyword">new</span> Person();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 赋予属性-名字 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            person.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 赋予属性-性别 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">gendar</span><span class="params">(String gendar)</span> </span>&#123;</span><br><span class="line">            person.gendar = gendar;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 赋予属性-年龄(冗余，提供方便) */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            person.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 返回实例化的Person对象 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Person target = person;</span><br><span class="line">            person = <span class="keyword">null</span>;    <span class="comment">// 防止第二次 build，即build一次之后，这个Builder对象就失效了</span></span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person中<code>name</code>和<code>gendar</code>是受保护的属性，即在Person对象实例化之后，这两个属性值不应该被改变，而<code>age</code>是可变的，提供公有的<code>Setter</code>改变其值。Builder模式可以通过一个静态内部类作为工厂的方式访问私有属性，组装私有属性值之后通过<code>build()</code>方法产出对象，并销毁当前”胚胎”，可以类比为鸡蛋里孵出小鸡，一颗鸡蛋只能孵出一只小鸡。</p>
<p><strong> 注意 </strong></p>
<ul>
<li>既然是受保护的对象，一般私有化其构造方法</li>
<li>受保护的对象也可以有可变的属性</li>
<li>Builder中容许冗余填充可变的属性方法</li>
<li><code>build()</code>只能产出一次</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实现分布式锁</title>
    <url>/article/2018/01/23/2018-01-23-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p>分布式锁总是一个热点讨论的话题，在涉及到多个系统调用，或者多台服务并行提供服务的情况下，对竞争资源的保护一般都会采用乐观锁，或分布式锁的方式实现，对单条资源的竞争一般选择乐观锁/悲观锁，而对过程的竞争往往是通过分布式锁的方式加以保护。实现分布式锁的方案也有很多。在实现分布式锁的过程中，往往有很多人会忽略一个细节，即<strong>只有加锁的人才具备释放锁的权利</strong>。这也是在公司中看一个”前人”在2015年实现的一个分布式锁源码，发现具有这个漏洞，特重新实现，以做记录。</p>
<a id="more"></a>
<p>话不多说，先上实现，这是一个基于redis实现的具备阻塞功能的，通用的分布式锁：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.zero.boot.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.zero.boot.web.init.context.ApplicationContextHolder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加锁工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年1月23日 下午4:01:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LockUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Redis操作api</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RedisTemplate&lt;?, ?&gt; redisTemplate = (RedisTemplate&lt;?, ?&gt;) ApplicationContextHolder.application.getBean(<span class="string">"redisTemplate"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_KEY_PREFIX = <span class="string">"lock:"</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_LOCKING_TIME = <span class="number">30_000L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_WAITING_FOR_LOCK_TIME = <span class="number">10_000L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取默认配置的阻塞锁</span></span><br><span class="line"><span class="comment">     * 阻塞容许时间 10s，取得锁时锁定时间 30s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lock(key, DEFAULT_WAITING_FOR_LOCK_TIME, DEFAULT_LOCKING_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取阻塞锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            上锁资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waittimeout    阻塞时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockingtime    锁定时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">long</span> waittimeout, <span class="keyword">long</span> lockingtime)</span> </span>&#123;</span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">final</span> String lockKey = LOCK_KEY_PREFIX + key;</span><br><span class="line">        <span class="keyword">long</span> timeoutpoing = System.currentTimeMillis() + waittimeout;</span><br><span class="line">        <span class="keyword">while</span>(timeoutpoing &gt; System.currentTimeMillis()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> setnx = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] skey = ((RedisSerializer&lt;String&gt;) redisTemplate.getKeySerializer()).serialize(lockKey);</span><br><span class="line">                    <span class="keyword">byte</span>[] svalue = ( (RedisSerializer&lt;String&gt;) redisTemplate.getValueSerializer()).serialize(uuid);</span><br><span class="line">                    <span class="keyword">return</span> connection.setNX(skey, svalue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(setnx) &#123;</span><br><span class="line">                <span class="comment">// 获取锁成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 随机阻塞时间，提升锁竞争公平性，同时防止饥饿线程等待</span></span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (<span class="number">100</span> + random.nextInt(<span class="number">300</span>)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  锁定的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String lockKey = LOCK_KEY_PREFIX + key;</span><br><span class="line">        <span class="keyword">if</span>(uuid == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] skey = ((RedisSerializer&lt;String&gt;) redisTemplate.getKeySerializer()).serialize(lockKey);</span><br><span class="line">                    String lockuuid = ((RedisSerializer&lt;String&gt;) redisTemplate.getValueSerializer()).deserialize(connection.get(skey));</span><br><span class="line">                    <span class="keyword">if</span>(lockuuid == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(uuid.equals(lockuuid)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> connection.del(skey) &gt; <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 及时清理 ThreadLocalMap</span></span><br><span class="line">            LOCK_OWNER_UUID.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完全释放锁，不需要权限认证（即非本线程获取的锁也能释放）[慎用，最好别用]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 锁定的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">superUnlock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String lockKey = LOCK_KEY_PREFIX + key;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] skey = ((RedisSerializer&lt;String&gt;) redisTemplate.getKeySerializer()).serialize(lockKey);</span><br><span class="line">                    <span class="keyword">return</span> connection.del(skey) &gt; <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java引用类型</title>
    <url>/article/2018/01/26/2018-01-26-Java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>在jdk1.2之后，位于<code>java.lang.ref</code>包下有<code>Reference</code>的实现<code>SoftReference</code>(软引用),<code>WeakReference</code>(弱引用),<code>PhantomReference</code>(虚引用),<code>FinalReference</code>(即强引用StrongReference),在jdk1.2之前所有的引用皆为强引用。<code>Reference</code>作为一个<code>abstract</code>修饰的类，是所有引用类型的基类，此类定义了常用于所有引用对象的操作。因为引用对象(*Reference)是通过与垃圾回收器的密切合作来实现的，所以不能由程序员直接为此类(<code>Reference</code>)创建子类。Reference类型的使用主要是为了增强jvm内存管理功能，通过使用不同的引用类型，程序员可以在一定程度上与GC交互，通过定义不同对象的引用类型改善GC的效率。被强引用类型引用的对象即使在OOM的情况下也不会被GC掉，软引用的对象在内存吃紧的情况下触发的GC过程中会被清除，弱引用的对象只要触动了GC就会被清除，虚引用的对象引用并不影响对象的生命时间，虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p>
<a id="more"></a>
<h1 id="Reference预读"><a href="#Reference预读" class="headerlink" title="Reference预读"></a>Reference预读</h1><p>需要了解引用怎么作用的，需先了解它的两个关键类，<code>Reference</code>和<code>ReferenceQueue</code>。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>作为所有引用类型的基类，Reference定义了所有引用对象的常用操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;           <span class="comment">// 清除此引用对象。调用此方法不会导致对象被加入队列。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">()</span></span>;      <span class="comment">// 将此引用对象添加到引用对象已向其注册的队列（如果有）。如果成功将此引用对象加入队列中，则返回 true；如果它已经加入队列或者在创建时没有在队列中注册它，则返回 false。</span></span><br><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span></span>;                <span class="comment">// 返回此引用对象的指示对象。如果此引用对象已经由程序或垃圾回收器清除，则此方法将返回 null。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEnqueue</span><span class="params">()</span></span>;    <span class="comment">// 由程序或垃圾回收器通知是否已将此引用对象加入队列。当且仅当此引用对象已经加入队列时返回 true。</span></span><br></pre></td></tr></table></figure></p>
<p>每个引用都有以下属性：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T referent;         <span class="comment">/* Treated specially by GC */</span>       <span class="comment">// 定义引用的对象</span></span><br><span class="line"><span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;                       <span class="comment">// 引用队列</span></span><br><span class="line">Reference next;                                                 <span class="comment">// 作为引用队列的下一个元素指针</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* used by VM */</span></span><br></pre></td></tr></table></figure></p>
<h2 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h2><p>引用对象队列，是用来保存注册为引用对象的队列。在检测到引用对象的可到达性被变更后，垃圾回收器会将已注册的引用对象添加到该队列中。引用队列是一个线程安全的单向队列类型，通过<code>volatile</code>声明的Reference类型的<code>head</code>指针作为队列的入口，属性<code>queueLength</code>记录队列长度，对该队列的所有操作都会通过<code>synchronized</code>关键字锁住队列本身，即每个引用队列都具备一个锁维护出入队的线程安全：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123; &#125;;</span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> Lock();</span><br></pre></td></tr></table></figure></p>
<p>ReferenceQueue的所有入队方法为<code>friendly</code>修饰的，即所有引用队列元素的入队操作都是由该队列所在的引用对象完成的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReferenceQueue的入队(Called only by Reference class)</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;? extends T&gt; r)</span> </span>&#123; <span class="comment">/* Called only by Reference class */</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// Check that since getting the lock this reference hasn't already been</span></span><br><span class="line">        <span class="comment">// enqueued (and even then removed)</span></span><br><span class="line">        ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">        <span class="keyword">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> queue == <span class="keyword">this</span>;</span><br><span class="line">        r.queue = ENQUEUED;</span><br><span class="line">        r.next = (head == <span class="keyword">null</span>) ? r : head;</span><br><span class="line">        head = r;</span><br><span class="line">        queueLength++;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 仅在 Reference中被调用(Reference.enqueue())</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.enqueue(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了被引用掌控的入队操作，ReferenceQueue还具有以下操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Reference&lt;? extends T&gt; poll();               <span class="comment">// 轮询此队列，查看是否存在可用的引用对象。如果存在一个立即可用的对象，则从该队列中移除此对象并返回。否则此方法立即返回 null。</span></span><br><span class="line"><span class="keyword">public</span> Reference&lt;? extends T&gt; remove(<span class="keyword">long</span> timeout); <span class="comment">// 移除此队列中的下一个引用对象，阻塞到有一个对象变得可用或者给定的超时期(ms)满了为止。如果超时值为零，则无限期地阻塞。</span></span><br><span class="line"><span class="keyword">public</span> Reference&lt;? extends T&gt; remove()              <span class="comment">// 移除此队列中的下一个引用对象，阻塞到某个对象变得可用为止。即超时值被设为0。</span></span><br></pre></td></tr></table></figure></p>
<h1 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h1><h2 id="SoftReference-软引用"><a href="#SoftReference-软引用" class="headerlink" title="SoftReference 软引用"></a>SoftReference 软引用</h2><p>软引用对象，在响应内存需要时，由垃圾回收器决定是否清除此对象。<strong>软引用对象最常用于实现内存敏感的缓存</strong>。假定垃圾回收器确定在某一时间点某个对象是软可到达对象，这时，它可以选择自动清除针对该对象的所有软引用，以及通过强引用链，从其可以到达该对象的针对任何其他软可到达对象的所有软引用。在同一时间或晚些时候，它会将那些已经向引用队列注册的新清除的软引用加入队列。软可到达对象的所有软引用都要保证在虚拟机抛出 OutOfMemoryError 之前已经被清除。否则，清除软引用的时间或者清除不同对象的一组此类引用的顺序将不受任何约束。然而，虚拟机倾向于反对清除最近访问或使用过的软引用。<br>此类的直接实例可用于实现简单缓存；该类或其派生的子类还可用于更大型的数据结构，以实现更复杂的缓存。只要软引用的指示对象是强可到达对象，即正在实际使用的对象，就不会清除软引用。例如，通过保持最近使用的项的强指示对象，并由垃圾回收器决定是否放弃剩余的项，复杂的缓存可以防止放弃最近使用的项。 </p>
<h2 id="WeakReference-弱引用"><a href="#WeakReference-弱引用" class="headerlink" title="WeakReference 弱引用"></a>WeakReference 弱引用</h2><p>弱引用对象，在弱引用对象没有任何强引用的情况下，触发GC时弱引用对象就会被清除。对应使用到弱引用的数据结构有<code>WeakHashMap</code>，该Map的元素类即继承自<code>WeakReference</code>，通常该类型Map也被用来作为缓存。</p>
<h2 id="PhantomReference-虚引用"><a href="#PhantomReference-虚引用" class="headerlink" title="PhantomReference 虚引用"></a>PhantomReference 虚引用</h2><p>虚引用对象，在垃圾回收器决定它引用的对象可能要被回收时就会将其添加到队列(构造方法中的那个ReferenceQueue)中，虚引用经常被用于比Java的finalization机制更灵活的方式来调度预验(pre-mortem)清除操作。为了确保可回收的对象仍然保持原状，虚引用的指示对象不能被获取，即虚引用的<code>get</code>方法总是返回<code>null</code>（阻止其指向的几乎被销毁的对象重新复活）。通过虚引用可到达的对象将仍然保持原状，直到所有这类引用都被清除，或者它们都变得不可到达。虚引用和前面的软引用、弱引用不同，虚引用在加入队列时并没有通过垃圾回收器自动清除，它并不影响对象的生命周期。<strong>虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动（即前文提及的预验(pre-mortem)清除操作）。</strong></p>
<h2 id="FinalReference-StrongReference-强引用"><a href="#FinalReference-StrongReference-强引用" class="headerlink" title="FinalReference(StrongReference)强引用"></a>FinalReference(StrongReference)强引用</h2><p>强引用其实就是默认的引用类型，是指创建一个对象并把这个对象赋给一个引用变量，譬如<code>String a = new String(&quot;a is a strong reference.&quot;);</code>，则<code>a</code>这个引用即是强引用，虚拟机将这类引用就通过<code>FinalReference</code>包装处理。<strong>强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象</strong>。如果需要强制释放强引用引用的对象，可以将强引用引用到<code>null</code>，那该对象在没有被引用的情况下就能响应GC操作，被清理掉了。</p>
<h3 id="Finalizer"><a href="#Finalizer" class="headerlink" title="Finalizer"></a>Finalizer</h3><p>关于 Finalizer类的描述，祥见<a href="https://yq.aliyun.com/articles/2947?spm=0.0.0.0.At14xp" title="JVM源码分析之FinalReference完全解读-寒泉子" target="_blank" rel="noopener">JVM源码分析之FinalReference完全解读</a>。综合文章描述有以下几点：<br>1、Finalizer是FinalReference的继承，package(包)访问权限，final不可扩展类。<br>2、通过类中是否存在一个参数为空，返回void的非空<code>void finalize()</code>方法判断该类是否为一个 Finalizer类。<br>3、Finalizer类对象在构造函数返回之前调用<code>Finalizer.register</code>方法，可通过配置<code>-XX:-RegisterFinalizersAtInit</code>关闭，并将在对象空间分配好之后调用<code>Finalizer.register</code>，将强引用类型对象引用注册为<code>Finalizer</code>类型引用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Finalizer</span><span class="params">(Object finalizee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(finalizee, queue);</span><br><span class="line">    add();  <span class="comment">// 即将 this添加到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Invoked by VM */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object finalizee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Finalizer(finalizee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当通过clone的方式复制一个对象时，如果当前类是一个f类，那么在clone完成时将调用<code>Finalizer.register</code>方法进行注册。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实 SoftReference, WeakReference 以及 PhantomReference 的构造函数都可以接收一个 ReferenceQueue 对象。当 SoftReference 以及 WeakReference 被清空的同时，也就是 Java 垃圾回收器准备对它们所指向的对象进行回收时，调用对象的<code>finalize()</code>方法之前，它们自身会被加入到这个 ReferenceQueue 对象中，此时可以通过 ReferenceQueue 的<code>poll()</code>方法取到它们。而 PhantomReference 只有当 Java 垃圾回收器对其所指向的对象真正进行回收时，会将其加入到这个 ReferenceQueue 对象中，这样就可以追综对象的销毁情况。</p>
<table>
<thead>
<tr>
<th style="text-align:center">引用类型</th>
<th style="text-align:center">取得目标对象的方式</th>
<th style="text-align:center">垃圾回收条件</th>
<th style="text-align:center">是否可能内存泄露</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强引用</td>
<td style="text-align:center">直接引用</td>
<td style="text-align:center">不回收</td>
<td style="text-align:center">可能</td>
</tr>
<tr>
<td style="text-align:center">软引用</td>
<td style="text-align:center">通过get()取得</td>
<td style="text-align:center">视内存情况(OOM前)</td>
<td style="text-align:center">不可能</td>
</tr>
<tr>
<td style="text-align:center">弱引用</td>
<td style="text-align:center">通过get()取得</td>
<td style="text-align:center">有GC即回收</td>
<td style="text-align:center">不可能</td>
</tr>
<tr>
<td style="text-align:center">虚引用</td>
<td style="text-align:center">无法获取</td>
<td style="text-align:center">不回收</td>
<td style="text-align:center">可能</td>
</tr>
</tbody>
</table>
<p>感谢：</p>
<ul>
<li>JVM源码分析之FinalReference完全解读: <a href="https://yq.aliyun.com/articles/2947" title="JVM源码分析之FinalReference完全解读-寒泉子" target="_blank" rel="noopener">https://yq.aliyun.com/articles/2947</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk阅读计划</tag>
        <tag>Reference</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat系统架构</title>
    <url>/article/2018/03/03/2018-03-03-Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Boot启动过程-配置信息</title>
    <url>/article/2018/10/18/2018-10-18-Spring-Boot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Boot启动过程-事件</title>
    <url>/article/2018/10/17/2018-10-17-Spring-Boot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>Spring中的监听器<code>listeners</code>是负责在应用启动过程中对各个阶段，对容器的启动过程监听并处理各阶段的动作，它的生命周期也只存在于应用开启启动到启动完成。监听器接收的信号即“事件(event)”在spring项目启动过程中主要分为四个阶段——开始启动、环境参数加载完成、准备完毕、启动成功|失败。</p>
<p>spring的启动过程是通过一系列的事件(event)在spring context启动的各个阶段通知并告知各组件，Spring事件继承<code>org.springframework.context.ApplicationEvent</code>，在springframework中事件类型主要包含如下:</p>
<ul>
<li><code>ApplicationContextEvent</code> (abstract)  以下四种容器生命节点事件的父类</li>
<li><code>ContextStartEvent</code>        容器开始启动时触发</li>
<li><code>ContextRefreshEvent</code>      容器刷新时触发</li>
<li><code>ContextStopEvent</code>         容器开启停止时触发</li>
<li><code>ContextClosedEvent</code>       容器关闭后触发</li>
<li><code>PayloadApplicationEvent&lt;T&gt;</code>  广泛的（通过泛型定义）可处理的事件，需要提供事件的处理（即T）</li>
<li><code>RequestHandledEvent</code>         在web环境中接收到请求事件</li>
<li><code>ServletRequestHandledEvent</code> 在web环境中接收到请求事件，包含servlet信息，是<code>RequestHandledEvent</code>事件的拓展</li>
</ul>
<p>在SpringBoot中，容器启动过程使用另一套事件，即继承<code>org.springframework.boot.context.event.SpringApplicationEvent</code>：</p>
<ul>
<li><code>ApplicationStartingEvent</code>  应用开始启动时触发（等于 <code>ApplicationStartedEvent</code>）</li>
<li><code>ApplicationEvironmentPreparedEvent</code>  应用环境（参数加载）准备完成时触发</li>
<li><code>ApplicationPreparedEvent</code>  应用准备完成时触发，准备完成包含。。。</li>
<li><code>ApplicationFailedEvent</code>  应用启动失败的情况下触发</li>
<li><code>ApplicationReadyEvent</code> 应用启动成功后触发</li>
</ul>
<p>除此之外还有其他事件：</p>
<ul>
<li><code>AuditApplicationEvent</code> ？</li>
<li><code>DataSourceInitializedEvent</code>  数据库连接建立完成时触发</li>
<li><code>EmbeddedServletContainerInitializedEvent</code>  在web环境下，内嵌的servlet容器初始化完成后触发</li>
<li><code>ExitCodeEvent</code> 应用收到关闭信号时触发，一般只在应用启动过程中收到此事件。</li>
<li><code>JobExecutionEvent</code> 有定时任务执行时触发</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>网络模型之OSI七层和TCP/IP四层</title>
    <url>/article/2020/03/01/2020-03-01-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B9%8BOSI%E4%B8%83%E5%B1%82%E5%92%8CTCP-IP%E5%9B%9B%E5%B1%82/</url>
    <content><![CDATA[<p>开放系统互连体系(OSI, Open System Interconnection)标准参考模型，也叫七层模型，是国际标准化组织(ISO, International Organization for Standardization)制定的一个用于计算机或通信系统间互联的标准体系，它是一个七层的、抽象的模型体，分别为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层，七层模型不仅包括一系列抽象的术语或概念，也包括具体的协议。<br>TCP/IP四层协议是一组用于实现网络互连的通信协议，Internet网络体系结构以TCP/IP为核心，参考OSI七层模型将协议分为4个层次，分别为应用层、传输层、网络层、数据链路层。</p>
<a id="more"></a>
<p>七层模型和TPC/IP四层协议映射</p>
<table><br>    <tr><br>        <td style="text-align:center;font-weight:bolder">OSI七层模型</td><br>        <td style="text-align:center;font-weight:bolder">TCP/IP四层协议</td><br>        <td style="text-align:center;font-weight:bolder">对应网络协议</td><br>        <td style="text-align:center;font-weight:bolder">功能</td><br>    </tr><br>    <tr><br>        <td>应用层(Application)</td><br>        <td rowspan="3">应用层</td><br>        <td>HTTP,TFTP,FTP,NFS,WAIS,SMTP</td><br>        <td>文件传输，电子邮件，虚拟终端</td><br>    </tr><br>    <tr><br>        <td>表示层(Presentation)</td><br>        <td>Telnet,Rlogin,SNMP,Gopher</td><br>        <td>数据格式化，数据加密</td><br>    </tr><br>    <tr><br>        <td>会话层(Session)</td><br>        <td>SMTP,DNS</td><br>        <td>建立或解除与其他节点的连接</td><br>    </tr><br>    <tr><br>        <td>传输层(Transport)</td><br>        <td>传输层</td><br>        <td>TCP,UDP</td><br>        <td>提供端对端的接口</td><br>    </tr><br>    <tr><br>        <td>网络层(Network)</td><br>        <td>网络层</td><br>        <td>IP,ICMP,ARP,RARP,AKP,UUCP</td><br>        <td>为数据包选择路由</td><br>    </tr><br>    <tr><br>        <td>数据链路层(Data Link)</td><br>        <td rowspan="2">数据链路层</td><br>        <td>FDDI,Ethernet,Arpanet,PDN,SLIP,PPP</td><br>        <td>传输有地址的帧及勘错</td><br>    </tr><br>    <tr><br>        <td>物理层(Physical)</td><br>        <td>IEEE 802.1A,IEEE 802.2~IEEE 802.11</td><br>        <td>物理媒介传输二进制数据</td><br>    </tr><br></table>


<p><img src="/images/coding/osi7.gif" alt="七层模型"></p>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>网络分层</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Boot启动过程-Bean初始化</title>
    <url>/article/2018/10/17/2018-10-17-Spring-Boot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-Bean%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>《卧虎藏龙》-影评</title>
    <url>/article/2018/12/05/2018-12-05-%E3%80%8A%E5%8D%A7%E8%99%8E%E8%97%8F%E9%BE%99%E3%80%8B-%E5%BD%B1%E8%AF%84/</url>
    <content><![CDATA[<p>江湖里卧虎藏龙，人心里何尝不是。刀剑里藏凶，人情里何尝不是。</p>
<a id="more"></a>
<p>江南水乡，一湖波澜，山如眉黛。武当剑侠李慕白素袍裹身，闲庭信步的走向雄远镖局，他此行是去拜访相识多年的红颜知己俞秀莲。秀莲是个外强内柔的女子，接下父亲的衣钵后，主持镖局的大小事务，李慕白则是江湖中收人尊敬的武林高手，一把青冥剑，半生江湖怨。已到中年的李慕白一心想要追求内心的平静，然而闭关修炼之后仍然无法放下心里的一些事。第一件事就是他打算退隐江湖，回归本真。听闻秀莲正要押镖进京，慕白便托她把青冥剑赠予贝勒爷。青冥剑乃先秦宝物，神兵利刃，削铁如泥，是慕白的贴身配剑。与青冥剑斩断关系，也是表明他退隐江湖的决心。第二件事就是师傅多年前遭碧眼狐狸暗算，师仇一直未报，慕白决定先去给师傅扫墓，稍后再前往北京与秀莲会合。<br>走镖入京交完货后，秀莲直接去了贝勒爷府。贝勒爷性情豪放，喜欢结交江湖朋友，与秀莲的福清乃是故友，与慕白也是忘年之交。得知秀莲的来意后他只是答应暂时保管青冥剑。谈到秀莲和慕白的感情，贝勒爷忍不住感慨“两人相识多年，互相爱慕，但他们行事太过小心翼翼，这么多年过去了，他们一直不敢向对方承认这份感情”。贝勒爷说：“这次慕白交出了青冥剑，又决定退出江湖，或许他是在向你暗示些什么。”秀莲双手交错，似乎有意避开这个话题。<br>秀莲被贝勒爷留下来小住几日，接着在书房偶遇了玉家大小姐玉娇龙。她是九门提督的女儿，端庄秀丽惹人怜爱。秀莲一时兴起，向玉大小姐展示了青冥剑，宝剑出鞘的一刹那，如蛟龙跃海，似猛虎下山，缭绕之音犹如龙鸣虎啸。娇龙的眼睛直勾勾地盯着宝剑，像是见到了勾魂摄魄之物。当晚入夜以后，一袭黑影略过房檐，贝勒爷府家丁老刘觉察到异常，与蒙面人打了照面后一路追到了九门提督府。被惊醒的秀莲抄近路截住了黑衣人，交手时发现那人用的竟然是武当派的招式，而且身法和武艺都不弱，秀莲一心想要搞清楚对方的身份，然而黑衣人却无心恋战。一番缠斗之后，秀莲渐渐占据上风，正打算揭开对方的面纱时，城楼上却突然飞来一支暗箭，黑衣人趁机逃得无影无踪。第二天一早，秀莲就去拜访玉娇龙，从她握笔转腕的力度来看，娇龙很可能是懂剑法的，这就应证了她的猜测。接着两人谈起闺房私话，娇龙说她就要成婚了，但她不喜欢父母安排的婚事，她喜欢武侠小说里的英雄儿女，就像俞秀莲和李慕白这样的，她想要自由自在的生活，选择心爱的人，用自己的方式去爱他。秀莲笑了笑，讲起了自己的往事。她小时候家里给订过亲，那个人就是李慕白的结义兄弟孟思昭，在一次意外中，孟思昭为救李慕白牺牲，后来两人虽情愫暗生，但他们都不敢表露心声，道德的约束让他们不敢跨过孟思昭的那一纸婚约。娇龙却是直来直去的说，这事儿你和李慕白都没错啊，爱就爱了呗，怪就怪你那个孟大侠没福气。<br>当晚入夜以后玉府迎来了新的“客人”，陕北捕头蔡九因为妻子被碧眼狐狸杀害，所以和女儿一起一路追踪碧眼狐狸到了玉府，并在玉府外墙贴了碧眼狐狸的缉捕告示，目的就是把她逼出来。终于碧眼狐狸忍不住了，主动邀父女两人黄土岗一决生死。此时慕白也赶到京城，从秀莲口中得知了宝剑失窃和碧眼狐狸的事，秀莲以为慕白要责怪她弄丢了宝剑，但慕白却说我来北京是因为，我以为我们已经讲好了。这里暗指他想要正视这段感情，和秀莲一起归隐山林。当晚黄土岗上，秋意肃杀，惊起一片寒鸦，原来这碧眼狐狸正是玉大小姐的师父，当年犯下不少事儿，就改头换面一直混在玉府中。愁人见面分外眼红，一番拼死搏斗后，几人并非碧眼狐狸的对手，接着慕白赶了过来，将碧眼狐狸打败后，正准备为师父报仇时，娇龙却蒙着面纱拿着青冥剑出现。慕白发现眼前的黑衣女子竟然会武当派的玄牝剑法。随后打斗中，蔡捕头被杀，碧眼狐狸和玉娇龙趁机逃走。<br>几日后娇龙母女应邀来到贝勒爷府作客，此时秀莲已经越来越怀疑娇龙，趁机试探了她的功夫，并暗示娇龙知错悔改才不会连累家人。随后慕白跟随贝勒爷会见了娇龙母女，听说娇龙即将出阁，慕白看了她一眼，眉眼清纯，别有几分娇俏，慕白只是说道，福气福气。当晚娇龙潜入贝勒府还剑，慕白早已等候多时，两人一路追逐，来到一座古庙，慕白说“你天分不错，但对武当心决领悟的路子不正，你需要良师的指导，帮你重理剑路”。娇龙却并不领情，招招凛冽，慕白以棍代剑，处处占先。慕白有意收娇龙为徒，传承武当派的“玄牝剑法”。四目相望时，眼神深处有他们极力掩饰的东西，娇龙大骂武当是酒馆娼窑，而后扬长而去。回到家后，娇龙又和师父闹翻，因为他的功夫早就超过了师父，当年碧眼狐狸盗得武当剑法后，她不识字只能按图谱练，而娇龙则按心决来练，最终悟出了剑法奥义，并隐瞒了实力。得知真相的碧眼狐狸怅然若失，只得落寞离开了玉府。月光下独自练剑的李慕白心事重重，秀莲远远的看着他，她欲言又止，但慕白却频繁提到，那个女孩儿。秀莲说，慕白，她不是我们这种江湖中人，她会安安分分的嫁人，但慕白却说，她不是那种人，她应该到武当山来做徒弟。<br>本以为交出青冥剑，他就可以退出江湖，但即使审身已退，此时的心却再也难以平复，而这时的娇龙也是心事重重，难以入眠，忽觉窗外有动静，原来是她的初恋情人小虎，不远万里从新疆到北京来找她。两人一见面，小虎悔不当初，娇龙却思绪万千。事情还得从一年前说起，娇龙一家人在回京图中，遭到马匪罗小虎的抢劫，被戏耍的娇龙和小虎展开追逐战，性子野不服输的娇龙和小虎在沙漠中你追我赶，正所谓不打不相识，年纪相仿，性格相近的两人，在打斗中渐渐产生了微妙的情感，小虎不远万里挑来水让她洗澡，为她挑脚底上的刺儿，当晚两人偷尝禁果，升华了他们的感情。娇龙在这里感受到了自由自在，无拘无束，可寻找娇龙的官兵越来越多，小虎劝娇龙跟父亲回家，他说自己会干一番事业，让娇龙的父母看得起。小虎指着远处的雪山对娇龙说，这里有一个传说，谁敢从那个山上跳下来，天神就会满足他一个愿望，真心的愿望就一定会实现，心诚则灵。第二天娇龙离开了那片草原，小胡说，我每前进一步，就会有阻碍，我真的尽了力。少年为爱情斗志昂扬，转眼却被现实浇了个透心凉。娇龙知道眼前的他终究只是一个马匪，他不是英雄，给不了她一个江湖梦，更无法征服她的内心。出嫁那天，大红嫁衣，龙凤盖头，小虎大闹了迎亲队伍，大喊道，小龙，你是我的。接着他被官兵追捕，慕白和秀莲匆忙将他带离现场，随后慕白让小虎去武当山避难并等他消息。<br>当晚娇龙逃离洞房，然后潜入贝勒爷府盗走青冥剑，此时的她已经没有了依靠，师父的离去，恋人的幼稚，父母的不理解，她开始仗剑走天涯，天地任潇洒。初生牛犊，追逐着心中的江湖，怀揣梦想，挥洒着满腔的热血，她高调行事，拿着青冥剑恃才傲物，行事待人骄横无礼，自以为能力无限大，可以天下任我行，江湖任我闯。她以为世界触手可及，看不起江湖三教九流，歇个脚的功夫都要给人一个下马威，而慕白和秀莲却一路寻找娇龙的下落，希望可以通过她找到碧眼狐狸。竹林小舍休息时，慕白握着秀莲有些粗糙的手说“我们能触摸的东西没有永远，把手握紧，里面什么也没有，把手松开，你拥有的是一切。秀莲，江湖里卧虎藏龙，人心里何尝不是，刀剑里藏凶，人情里何尝不是。我交出青冥剑，却惹来更多烦恼”，秀莲意味深长的说，“压抑只会让感情更强烈，我也阻止不了我的欲望。我想跟你在一起，就像这样坐着，我反而能感觉到一种平静。”说这话的时候，慕白没有看着秀莲，而是看向远方。<br>娇龙的高调行事引来了不少江湖人士的注意，聚星楼的一场武斗，让娇龙一战成名，只不过这名声是恶名，这江湖不是你武功高就可以随便乱闯。手上挂彩的各路豪杰不服气，找来李慕白主持稿公道。几日之后，闯了祸的娇龙主动来到了雄远镖局，她伏在秀莲怀里，梨花带雨，可怜楚楚，秀莲一边为她擦眼泪，一边劝她先回北京。提及罗小虎，秀莲说他被慕白安排在武当山了，娇龙觉得这是他们给自己下的套，想让自己拜李慕白为师。羞怒之下与秀莲闹翻，两人准备决一高下。招式只是发泄，两人各有不满，内心深处都有他们怒气的原因。秀莲十八般武器轮番上阵，却都被青冥剑斩断，娇龙虽有青冥剑在手，但武艺修为还不足以驾驭宝剑，数个回合下来，秀莲仍然占据上风，最后秀莲的断刃架在了娇龙的脖子上，娇龙却气急败坏的陈秀莲不备砍伤了她。慕白及时赶到，娇龙转身逃走，两个身影如同笔尖掠过湖面，他们穿梭在青翠的竹林之巅，轻如飞羽。慕白说当日留一步给你，是要见你的本心。娇龙倔强的回到，你们这些老江湖，怎么见得到本心。这是一场剑法的对决，也是一场情欲的博弈。从第一次见面他就被扰乱，别人或许无从知晓，她却能够真切感受。她生性狂野，奔放不羁，他内敛沉稳，含蓄克制，痴缠到溪水中的石块之上，娇龙问为什么一定要缠着我，慕白执意要当她的师父传授她心决，可娇龙心里知道，这些不过是说给外人听的体面话，眼前的男人内心深处有他自己都不敢面对的东西。一把剑横在他们之间，两人心里都是翻江倒海，她的倔强终于被他的沉稳压倒，或许她也渴望能有人征服她的内心。但她又不甘心就这样被征服，思虑片刻，她终于妥协了，她说三招之内你能拿回青冥剑，我就跟你走。他笑了笑，一招就夺回了剑，她猛的一愣随即反悔。慕白将剑扔进绝壁深渊，然而娇龙却毫不犹豫的跟着跳了下去，等慕白赶到时，娇龙已被碧眼狐狸救起。碧眼狐狸将娇龙藏在一个土窑里，点燃迷香后匆匆离去。接着她冒着大雨在雄远镖局周围徘徊，引起了秀莲的警觉，随后慕白也被引入洞中，而此时的娇龙已是意乱情迷。她浑身湿透，扯开衣襟问慕白，你要剑还是要我。慕白满头大汗，努力调着自己的呼吸，接着娇龙瘫软在他怀里，他故作镇定的看了她一眼，很快发现娇龙是中了迷香，他踢翻香炉，给娇龙闻了解药，然后运气为她疗伤。片刻之后秀莲赶了过来，听慕白说娇龙中了迷香，秀莲瞥视左右，顿觉不妙，她也是被碧眼狐狸引过来的。众人刚反应过来，暗处就出现了无数根九转紫阴针，电光火石之间，毒针就如风驰电掣一般倾斜而来，碧眼狐狸带着毒针腾空跃起冲杀而来，暗箭对准的却是娇龙。慕白急忙挺身护住她，青冥剑瞬间将碧眼狐狸的兵器绞碎，慕白一跃而起补上最后一剑。但不幸的是慕白的脖颈处也中了一针。碧眼狐狸临死之前控诉徒弟不肖，隐瞒心决，害她苦练不成，而娇龙却剑艺精进，什么是毒，一个十八岁的孩子就有这种心机，这就是毒，说完便咽了气。此时娇龙内心受到极大触动，仿佛一瞬间她就明白了一切，她知道解药的配方，决定马上赶回镖局为慕白配解药，但慕白最多只能撑一个时辰，到了最后慕白已经支撑不住，仅有一息尚存。秀莲知道已经无力回天，她劝慕白提升最后一口气，解脱得到，达到他这一生所追求的境地。慕白说，我已经浪费了这一生，我要用最后一口气对你说，我一直深爱着你，说完他便倒了下去，秀莲抱住他印上一个吻。这是他们之间的第一个吻，也是最后一个吻。等娇龙匆匆赶来为时已晚，只能跪在地上不知所措。秀莲扶起她，并让他去武当山找小虎，并说道，答应我，不论你对此生的决定为何，已经要真诚的对待自己。<br>武当山上云雾缭绕，娇龙背上行囊拾级而上，见到了小虎，然而她却出奇的平静，拥吻之时她心不在焉，动情之处她却眼角含泪，一夜缠绵后小虎发现娇龙不见了，接着他看到她正站在石桥之上，痴痴的遥望眼前的幻境。她问小虎，还记得你说的那个故事吗。小虎说，心诚则灵，娇龙说道，小虎许个愿吧，小虎闭上眼睛，一起回新疆。娇龙纵身一跃，跳入茫茫云海，江湖梦已经破碎，该偿还的情已经偿还，你看那山崖之间的云朵，自由自在，人那，要是能那样该多好。<br>《卧虎藏龙》是李安导演2000年上映的作品，电影获得第73届奥斯卡最佳外语片，最佳摄影，最佳艺术指导以及最佳原创配乐四项大奖，这也是华语电影第一次在奥斯卡上获此殊荣，也是美国电影史上第一部超过1亿美元偏方的外语片，它将中国人的武侠世界美轮美奂的呈现给西方观众，不可否认的是，电影暗合了西方观众的审美需求，但其中的情，其中的理则完完全全是东方文化所特有的思想。接下来我将用较长的篇幅来详细解析这部电影里的“江湖”。<br>私认为，这是一部披着武侠外壳的中国人情感伦理片，表面上是在讲武侠世界，讲江湖恩怨，实则是在讲人性，讲情欲伦理。正所谓江湖里藏的是龙和虎，人心里藏的是情和欲。李慕白是个有着较高社会地位的成功人士，他信奉道家思想，同时也深受儒家思想的影响，道家偏好自然与自觉，儒家崇尚理性和修身，这就使得李慕白陷入矛盾之中，他在闭关时感觉周围只有光，他想要冲破世俗却发现陷入其中，甚至充满了悲哀。为什么？因为如果直面内心的话，势必要承受道德层面的压力，作为一个成功人士，要想放下打拼伴生得来的社会地位，去寻求内心的平静，这是非常非常难得一件事。不过好在李慕白终于下了这个决心，交出了青冥剑退隐江湖。然后直面内心的情感打算和俞秀莲共度余生。但俞秀莲也正面临这这样的抉择，在直面感情和到的谴责中挣扎。她对娇龙说，我虽然不是出生高贵，但一个女人一生应该服从的道德和礼教并不会少于你们，三纲五常要求她从一而终，她和李慕白之间横着的不是死去的孟思昭，而是道德和礼教。如果说这是两人的纠缠，事情可能还有解决的希望，但李安不满足于此，玉娇龙的出现彻底打乱了这个局面。从第一次见面，李慕白已经对玉娇龙产生了情愫或者是情欲，听说娇龙即将出嫁，他喃喃的说，福气福气，可能他说的是即将要娶娇龙的那个人好福气。紧接着慕白就决意冲出江湖，一方面是为了报师仇，但更多的是为了那个女孩，这种没来由的情欲最为要命。李慕白必须要说服自己这只是一种惜才之情。此刻，他和秀莲之间又多了一道更大的鸿沟，很明显，秀莲也能感受到那种难以言说的东西，她是懂情的，她也是懂慕白的。她说我也想过平静的日子，我不知道该怎么帮你。慕白说本以为交出青冥剑就可以退出江湖，没想到又引来了新仇旧恨。可哪有什么江湖，江湖从在都只在人心里，又有什么新仇旧恨，只不过是新情旧爱。情不知所起，一往而深，谁又能控制得了呢。贝勒爷说，面对情字，再大的英雄也是莫可奈何，慕白执意要收娇龙为徒，只不过是求一个形式上的圆满，既可以把她留在身边，又能约束自己对她的情欲。他终究无法得道，因为他绝不可能直面对娇龙的感情，他藏的很深，但却瞒不过对娇龙的眼睛。从一开始她就知道，所以她说武当是酒馆娼窑，因为她看得见慕白的情欲。竹林小舍中，慕白说我们能触摸的东西没有永远，或许他想说的是感情其实也一样。慕白说我阻止不了我的欲望，秀莲何尝不知话中的意思，只是淡淡说了一句，压抑只会让感情更强烈。看到这里会有观众可能觉得会不会过度解读，要知道李安是个很克制的导演，无论是描写男女情欲，还是悲欢离合，都是点到即止，会不会嚎啕控诉，更不会用大篇幅去刷悲伤脸。只需一个眼神，一句话，内里却是波涛汹涌的情感，此处没有表明孰好孰坏，只是每个导演风格不同而已。后来娇龙和秀莲武馆里的打斗，其实是一场感情冲突的戏。两个女人之间的爱恨情仇，秀莲是爱中夹杂着不甘和嫉妒，娇龙是不远感情被人操控和对慕白复杂的情感。竹林里慕白和娇龙的追逐则是一次心照不宣的征服与被征服（或者试探和被试探）。慕白说要见娇龙的本心，娇龙却说你们这些老江湖，如何见得本心。岩石之上，当娇龙面对强势的慕白，终于妥协，她说的是，如果你抢回青冥剑，我就跟你走，而不是我就拜你为师，跟你走是一个很暧昧带有挑逗性的词儿，此时的李慕白一抹邪魅的笑，此刻他们都已经心知肚明。所以才有山洞里娇龙问慕白，你是要我还是要剑，如果没有看懂前面的细节铺垫，你肯定会觉得很突兀。其实两人的情欲纠缠从一开始就存在，最终李慕白的情欲和伦理伴随着他的死亡被永远隐藏。道德和情欲，世俗礼仪和听从内心，到底该如何抉择，这是东方文化中最艰难的命题。临终之时，带着没有答案的问题，慕白回归了，秀莲留给娇龙一句话，无论怎样，都要真诚的对待自己，这是慕白和她心理一直想要做却始终无法做到的。而对于娇龙而言，独自闯荡江湖，想要的不过是创造自己的江湖梦，然而师父临死之前的那几句话，让娇龙瞬间明白了，原来江湖不在别处，江湖在人的心里，情欲爱恨，八岁时她已在江湖中，可依旧做着江湖梦。小虎抢亲的时候大喊，你是我的，但在娇龙心里，她就是她，她不是任何人的，可小虎怎么能懂，他心里的江湖跟她的不一样。最后一夜的缠绵也只是为了偿还情债，她以为自己自由自在，可终究，她也逃不过世俗的束缚。站在武当山顶，小虎的愿望是回新疆，可娇龙的愿望却还是无拘无束自由自在，但这个江湖却容不下这份自由。生命诚可贵，爱情价更高，若为自由故，两者皆可抛，这是西方人的信仰，却也是东方人的浪漫。人在江湖，身不由己，心在凡尘，情难自已。<br>最后总给依旧保持勇气听从内心的人们一句话“但愿你们依然能爱恨坦荡，真诚对待自己，切莫白白浪费了这一生。”。</p>
<p>—— 来自“越哥说电影”</p>
]]></content>
      <categories>
        <category>影评</category>
      </categories>
      <tags>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title>QUIC上手初体验</title>
    <url>/article/2020/07/01/2020-07-01-QUIC%E4%B8%8A%E6%89%8B%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>安装支持HTTP3的nginx,通过cloudflare云服务开源的quiche实现,其中主要涉及内容包括</p>
<ul>
<li>nginx源码</li>
<li>由cloudflare开源于github的quiche项目(quiche从nginx-1.16.x版本开始支持)</li>
<li>由google开源于github的boringssl项目(在quiche项目中引用了该项目)</li>
<li>Rust语言环境(cloudflare/quiche项目build需要)</li>
<li>Golang语言环境(google/boringssl项目make需要)</li>
<li>支持https的curl最新版本</li>
<li>SSL证书生成</li>
</ul>
<a id="more"></a>
<p>首先确定工作路径为<code>~/tools</code>.</p>
<p>安装nginx可能涉及模块的各项依赖，以及用于生成证书的openssl工具:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install make cmake libssl-dev libpcre3 libpcre3-dev zlib1g-dev openssl autoconf libtool golang-go</span><br></pre></td></tr></table></figure></p>
<p>注:整个安装过程须全程连网。</p>
<h1 id="一、安装Rust语言环境"><a href="#一、安装Rust语言环境" class="headerlink" title="一、安装Rust语言环境"></a>一、安装Rust语言环境</h1><p>通过官方安装方式，执行以下命令之后，将下载对应语言环境安装包(大约170MB)，期间有部分操作需人为干预，按提示输入对应内容回车即可。<a href="https://www.rust-lang.org/tools/install" title="Rust环境安装向导" target="_blank" rel="noopener">参考官方文档</a>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl --proto &apos;=https&apos; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure></p>
<p>一般情况下，Rust安装在用户目录的<code>.cargo/bin</code>路径下，需将该路径加入到PATH变量中，可在<code>/etc/profile</code>文件最后追加如下内容:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/home/zero/.cargo/bin</span><br></pre></td></tr></table></figure></p>
<p>除此之外，还需指定默认工具链：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rustup default stable</span><br></pre></td></tr></table></figure></p>
<p>随后可通过如下命令验证Rust语言环境是否安装成功:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zero@zero:~$ rustc --version</span><br><span class="line">rustc 1.44.1 (c7087fe00 2020-06-17)</span><br><span class="line">zero@zero:~$ cargo --version</span><br><span class="line">cargo 1.44.1 (88ba85757 2020-06-11)</span><br><span class="line">zero@zero:~$</span><br></pre></td></tr></table></figure></p>
<p><strong>注：</strong> 国内访问<code>create.io</code>站点较慢，在后续使用中将从该站点下载必要文件，故采用配置使用镜像站，在<code>~/.cargo</code>目录下创建<code>config</code>文件，输入并保存以下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class="line">replace-with = &apos;ustc&apos;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="二、下载quiche项目源码"><a href="#二、下载quiche项目源码" class="headerlink" title="二、下载quiche项目源码"></a>二、下载quiche项目源码</h1><p>通过git直接将<code>cloudflare/quiche</code>项目源码克隆到本地，直接使用master分支:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --recursive https://github.com/cloudflare/quiche</span><br></pre></td></tr></table></figure></p>
<p>注: <code>--recursive</code> 参数是用于处理git依赖的子项目，在quiche项目clone完成并检出master分支之后可在项目目录下看到<code>.gitmodule</code>文件，其中即是关联子模块的git配置信息，即<a href="#" title="--recursive官方解释: Submodules are initialized and cloned using their default settings. This is equivalent to running git submodule update --init --recursive &lt;pathspec&gt; immediately after the clone is finished. This option is ignored if the cloned repository does not have a worktree/checkout (i.e. if any of --no-checkout/-n, --bare, or --mirror is given).">在clone完成主项目之后立即执行子项目clone至默认配置的目录</a></p>
<p><strong>注：</strong> 网络环境较差情况下，由于<code>google/boringssl</code>项目文件内容较多(大于100MB)，直接使用<code>--recursive</code>可能失败，如果在 <code>quiche/deps/boringssl</code>目录下无<code>.git</code>等相关文件（即前面的<code>--revursice</code>执行失败了），则可单独到<code>quiche/deps</code>目录下，首先删除<code>boringssl</code>空文件夹，单独clone<code>google/boringssl</code>项目到<code>deps</code>目录下，并在quiche项目下使用git的子模块修复命令修复：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cdo ~/tools/quiche/deps</span><br><span class="line"></span><br><span class="line">rmdir boringssl</span><br><span class="line"></span><br><span class="line">git clone https://github.com/google/boringssl.git</span><br><span class="line"></span><br><span class="line">cd ../</span><br><span class="line"></span><br><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure></p>
<p>如果修复成功会有类似如下提示(<em>后面的commitId可能不同，可以忽略</em>)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zero@zero:~/tools/quiche$ git submodule update --init </span><br><span class="line">Submodule path &apos;deps/boringssl&apos;: checked out &apos;88024df12147e56b6abd66b743ff441a0aaa09a8&apos;</span><br></pre></td></tr></table></figure></p>
<h1 id="三、准备CA证书文件"><a href="#三、准备CA证书文件" class="headerlink" title="三、准备CA证书文件"></a>三、准备CA证书文件</h1><p>确定存放CA证书文件的路径为<code>~/tools/openssl</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/tools/openssl</span><br></pre></td></tr></table></figure></p>
<p>1、使用openssl使用des3算法生成2048位的rsa私钥，此处需输入预置解析密码(需记下以备后用，譬如 ‘123456’)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -des3 -out server.key 2048</span><br></pre></td></tr></table></figure></p>
<p>注：查看刚生成的私钥(需键入解析密码)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl rsa -text -in server.key</span><br></pre></td></tr></table></figure></p>
<p>2、根据刚生成的私钥创建证书签名请求CSR文件，此处需键入包含公司、国家编码、地区编码等信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure></p>
<p>注：查看生成CSR文件详情：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -text -in server.csr -noout</span><br></pre></td></tr></table></figure></p>
<p>3、删除密钥中的密码，避免在使用该证书的应用加载时需要输入解析密码的操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl rsa -in server.key -out server.key</span><br></pre></td></tr></table></figure></p>
<p>4、生成时间为10年(尽量长一点时间)的CA证书：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure></p>
<p>以上一顿操作之后便能在<code>~/tools/openssl</code>目录下看到如下文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zero@zero:~$ ls -a -l -h tools/openssl/</span><br><span class="line">total 20K</span><br><span class="line">drwxrwxr-x 2 zero zero 4.0K Jul  4 03:39 .</span><br><span class="line">drwxrwxr-x 8 zero zero 4.0K Jul  4 03:36 ..</span><br><span class="line">-rw-rw-r-- 1 zero zero 1.3K Jul  4 03:39 server.crt</span><br><span class="line">-rw-rw-r-- 1 zero zero 1.1K Jul  4 03:39 server.csr</span><br><span class="line">-rw------- 1 zero zero 1.7K Jul  4 03:42 server.key</span><br></pre></td></tr></table></figure></p>
<h1 id="四、编译支持HTTP3的nginx"><a href="#四、编译支持HTTP3的nginx" class="headerlink" title="四、编译支持HTTP3的nginx"></a>四、编译支持HTTP3的nginx</h1><p>转至nginx工作目录下载并解压源码，下载大于或等于1.16.x的nginx版本皆适用，此处使用当前最新稳定版本<code>1.18.0</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/tools</span><br><span class="line"></span><br><span class="line">curl -O https://nginx.org/download/nginx-1.18.0.tar.gz </span><br><span class="line"></span><br><span class="line">tar -zxf nginx-1.18.0.tar.gz</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/cloudflare/quiche/tree/master/extras/nginx" title="操作文档" target="_blank" rel="noopener">参考</a>转到nginx源码目录，将<code>cloudflare/quiche</code>项目有关nginx的源码附加到nginx源码中:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">patch -p01 &lt; ../quiche/extras/nginx/nginx-1.16.patch</span><br></pre></td></tr></table></figure></p>
<p>配置编译的nginx支持HTTP/3:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure                                    \</span><br><span class="line">       --prefix=/usr/local/etc/nginx-1.18.0    \</span><br><span class="line">       --build=&quot;quiche-$(git --git-dir=../quiche/.git rev-parse --short HEAD)&quot; \</span><br><span class="line">       --with-http_ssl_module                  \</span><br><span class="line">       --with-http_v2_module                   \</span><br><span class="line">       --with-http_v3_module                   \</span><br><span class="line">       --with-openssl=../quiche/deps/boringssl \</span><br><span class="line">       --with-quiche=../quiche</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<p>将安装nginx的路径加入到PATH变量，并启动nginx:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/etc/nginx-1.18.0/sbin</span><br></pre></td></tr></table></figure></p>
<p>或编辑<code>/etc/sudoers</code>文件，在’secure_path’后面增加nginx安装路径:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Defaults	secure_path=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin:/usr/local/etc/nginx-1.18.0/sbin&quot;</span><br></pre></td></tr></table></figure></p>
<p>查看编译的nginx版本信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zero@zero:~/tools/nginx-1.18.0$ nginx -V </span><br><span class="line">nginx version: nginx/1.18.0 (quiche-c25a595)</span><br><span class="line">built by gcc 9.3.0 (Ubuntu 9.3.0-10ubuntu2) </span><br><span class="line">built with OpenSSL 1.1.0 (compatible; BoringSSL) (running with BoringSSL)</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/usr/local/etc/nginx-1.18.0 --build=quiche-c25a595 --with-http_ssl_module --with-http_v2_module --with-http_v3_module --with-openssl=../quiche/deps/boringssl --with-quiche=../quiche</span><br><span class="line">zero@zero:~/tools/nginx-1.18.0$</span><br></pre></td></tr></table></figure></p>
<p>编辑配置文件<code>/usr/local/etc/nginx-1.18.0/conf/nginx.conf</code>，配置监听端口并启用QUIC监听443端口：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        # Enable QUIC and HTTP/3.</span><br><span class="line">        listen 443 quic reuseport;</span><br><span class="line"></span><br><span class="line">        # Enable HTTP/2 (optional).</span><br><span class="line">        listen 443 ssl http2;</span><br><span class="line"></span><br><span class="line">        ssl_certificate      /home/zero/tools/openssl/server.crt;</span><br><span class="line">        ssl_certificate_key  /home/zero/tools/openssl/server.key;</span><br><span class="line"></span><br><span class="line">        # Enable all TLS versions (TLSv1.3 is required for QUIC).</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class="line"></span><br><span class="line">        # Request buffering in not currently supported for HTTP/3.</span><br><span class="line">        proxy_request_buffering off;</span><br><span class="line"></span><br><span class="line">        # Add Alt-Svc header to negotiate HTTP/3.</span><br><span class="line">        add_header alt-svc &apos;h3-29=&quot;:443&quot;; ma=86400&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动nginx,并查看端口监听情况：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zero@zero:/usr/local/etc/nginx-1.18.0$ sudo nginx -c /usr/local/etc/nginx-1.18.0/conf/nginx.conf</span><br><span class="line">zero@zero:/usr/local/etc/nginx-1.18.0$ ps -ef |grep nginx </span><br><span class="line">root       88516       1  0 07:24 ?        00:00:00 nginx: master process nginx -c /usr/local/etc/nginx-1.18.0/conf/nginx.conf</span><br><span class="line">nobody     88517   88516  0 07:24 ?        00:00:00 nginx: worker process</span><br><span class="line">zero       88519    4508  0 07:24 pts/1    00:00:00 grep --color=auto nginx</span><br><span class="line">zero@zero:/usr/local/etc/nginx-1.18.0$ </span><br><span class="line">zero@zero:/usr/local/etc/nginx-1.18.0$ ss -lunt |egrep &apos;:80|:443&apos;</span><br><span class="line">udp   UNCONN 0       0                 0.0.0.0:443         0.0.0.0:*            </span><br><span class="line">tcp   LISTEN 0       511               0.0.0.0:443         0.0.0.0:*</span><br></pre></td></tr></table></figure></p>
<h1 id="五、编译支持HTTP-3的curl工具"><a href="#五、编译支持HTTP-3的curl工具" class="headerlink" title="五、编译支持HTTP/3的curl工具"></a>五、编译支持HTTP/3的curl工具</h1><p>首先到quiche目录下编译quiche和BoringSSL：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/tools/quiche</span><br><span class="line"></span><br><span class="line">sudo cargo build --release --features pkg-config-meta,qlog</span><br><span class="line"></span><br><span class="line">mkdir deps/boringssl/lib</span><br><span class="line"></span><br><span class="line">sudo ln -vnf $(find target/release -name libcrypto.a -o -name libssl.a) deps/boringssl/lib/</span><br></pre></td></tr></table></figure></p>
<p>转至<code>~/tools/</code>目录下通过git将<code>curl/curl</code>项目源码下载到<code>~/tools</code>工作目录下，直接使用master分支即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/tools</span><br><span class="line"></span><br><span class="line">git clone https://github.com/curl/curl.git</span><br></pre></td></tr></table></figure></p>
<p>转到<code>curl</code>目录下编译curl：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd curl</span><br><span class="line"></span><br><span class="line">./buildconf</span><br><span class="line"></span><br><span class="line">./configure LDFLAGS=&quot;-Wl,-rpath,$PWD/../quiche/target/release&quot; --with-ssl=$PWD/../quiche/deps/boringssl --with-quiche=$PWD/../quiche/target/release --enable-alt-svc --prefix=/usr/local/etc/curl</span><br><span class="line"> </span><br><span class="line"> sudo make</span><br></pre></td></tr></table></figure></p>
<p>先卸载原有的curl，再将安装curl的路径加入到PATH变量:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt remove curl</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/usr/local/etc/curl/bin</span><br></pre></td></tr></table></figure></p>
<p>编译成功后，curl工具在src目录下，通过curl请求HTTP/3示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zero@zero:~/tools/curl$ curl --http3 https://localhost -k -I </span><br><span class="line">HTTP/3 200</span><br><span class="line">server: nginx/1.18.0</span><br><span class="line">date: Sat, 04 Jul 2020 05:28:15 GMT</span><br><span class="line">content-type: text/html</span><br><span class="line">content-length: 612</span><br><span class="line">last-modified: Tue, 21 Apr 2020 14:09:01 GMT</span><br><span class="line">etag: <span class="string">"5e9efe7d-264"</span></span><br><span class="line">alt-svc: h3-29=<span class="string">":443"</span>; ma=86400</span><br><span class="line">accept-ranges: bytes</span><br><span class="line">zero@zero:~/tools/curl$</span><br></pre></td></tr></table></figure></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://github.com/cloudflare/quiche/tree/master/extras/nginx" title="cloudflare/quiche" target="_blank" rel="noopener">nginx集成quiche</a><br><a href="https://github.com/curl/curl/blob/master/docs/HTTP3.md" title="curl/curl" target="_blank" rel="noopener">编译curl</a><br><a href="https://github.com/google/boringssl &quot;google/boringssl" target="_blank" rel="noopener">boringssl</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP/3</tag>
        <tag>QUIC</tag>
      </tags>
  </entry>
  <entry>
    <title>OPENSSL命令参考</title>
    <url>/article/2020/06/30/2020-06-30-OPENSSL%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<p>一般使用openssl生成证书步骤：<br>1、使用openssl使用des3算法生成2048位的rsa私钥，此处需输入预置解析密码(需记下以备后用，譬如<code>123456</code>)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -des3 -out server.key 2048</span><br></pre></td></tr></table></figure></p>
<p>注：查看刚生成的私钥(需键入解析密码)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl rsa -text -in server.key</span><br></pre></td></tr></table></figure></p>
<p>2、根据刚生成的私钥创建证书签名请求CSR文件，此处需键入包含公司、国家编码、地区编码等信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure></p>
<p>注：查看生成CSR文件详情：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -text -in server.csr -noout</span><br></pre></td></tr></table></figure></p>
<p>3、删除密钥中的密码，避免在使用该证书的应用加载时需要输入解析密码的操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl rsa -in server.key -out server.key</span><br></pre></td></tr></table></figure></p>
<p>4、生成时间为10年(尽量长一点时间)的CA证书：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure></p>
<p>以上一顿操作之后便能在<code>~/tools/openssl</code>目录下看到如下文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zero@zero:~$ ls -a -l -h tools/openssl/</span><br><span class="line">total 20K</span><br><span class="line">drwxrwxr-x 2 zero zero 4.0K Jul  4 03:39 .</span><br><span class="line">drwxrwxr-x 8 zero zero 4.0K Jul  4 03:36 ..</span><br><span class="line">-rw-rw-r-- 1 zero zero 1.3K Jul  4 03:39 server.crt</span><br><span class="line">-rw-rw-r-- 1 zero zero 1.1K Jul  4 03:39 server.csr</span><br><span class="line">-rw------- 1 zero zero 1.7K Jul  4 03:42 server.key</span><br></pre></td></tr></table></figure></p>
<p>另：如果有需要PEM格式证书，可通过以下方式生成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -in server.crt  -outform PEM -out server.pem</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="openssl-list-standard-commands-标准命令"><a href="#openssl-list-standard-commands-标准命令" class="headerlink" title="openssl list-standard-commands(标准命令)"></a>openssl list-standard-commands(标准命令)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1) asn1parse: asn1parse用于解释用ANS.1语法书写的语句(ASN一般用于定义语法的构成) </span><br><span class="line">    2) ca: ca用于CA的管理 </span><br><span class="line">    openssl ca [options]:</span><br><span class="line">        2.1) -selfsign</span><br><span class="line">        使用对证书请求进行签名的密钥对来签发证书。即&quot;自签名&quot;，这种情况发生在生成证书的客户端、签发证书的CA都是同一台机器(也是我们大多数实验中的情况)，我们可以使用同一个</span><br><span class="line">密钥对来进行&quot;自签名&quot;</span><br><span class="line">        2.2) -in file</span><br><span class="line">        需要进行处理的PEM格式的证书</span><br><span class="line">        2.3) -out file</span><br><span class="line">        处理结束后输出的证书文件</span><br><span class="line">        2.4) -cert file</span><br><span class="line">        用于签发的根CA证书</span><br><span class="line">        2.5) -days arg </span><br><span class="line">        指定签发的证书的有效时间</span><br><span class="line">        2.6) -keyfile arg   </span><br><span class="line">        CA的私钥证书文件</span><br><span class="line">        2.7) -keyform arg</span><br><span class="line">        CA的根私钥证书文件格式:</span><br><span class="line">            2.7.1) PEM</span><br><span class="line">            2.7.2) ENGINE </span><br><span class="line">        2.8) -key arg   </span><br><span class="line">        CA的根私钥证书文件的解密密码(如果加密了的话)</span><br><span class="line">        2.9) -config file    </span><br><span class="line">        配置文件</span><br><span class="line">    example1: 利用CA证书签署请求证书</span><br><span class="line">    openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key  </span><br><span class="line"></span><br><span class="line">    3) req: X.509证书签发请求(CSR)管理</span><br><span class="line">    openssl req [options] &lt;infile &gt;outfile</span><br><span class="line">        3.1) -inform arg</span><br><span class="line">        输入文件格式</span><br><span class="line">            3.1.1) DER</span><br><span class="line">            3.1.2) PEM</span><br><span class="line">        3.2) -outform arg   </span><br><span class="line">        输出文件格式</span><br><span class="line">            3.2.1) DER</span><br><span class="line">            3.2.2) PEM</span><br><span class="line">        3.3) -in arg</span><br><span class="line">        待处理文件</span><br><span class="line">        3.4) -out arg</span><br><span class="line">        待输出文件</span><br><span class="line">        3.5) -passin        </span><br><span class="line">        用于签名待生成的请求证书的私钥文件的解密密码</span><br><span class="line">        3.6) -key file</span><br><span class="line">        用于签名待生成的请求证书的私钥文件</span><br><span class="line">        3.7) -keyform arg  </span><br><span class="line">            3.7.1) DER</span><br><span class="line">            3.7.2) NET</span><br><span class="line">            3.7.3) PEM</span><br><span class="line">        3.8) -new</span><br><span class="line">        新的请求</span><br><span class="line">        3.9) -x509          </span><br><span class="line">        输出一个X509格式的证书 </span><br><span class="line">        3.10) -days</span><br><span class="line">        X509证书的有效时间  </span><br><span class="line">        3.11) -newkey rsa:bits </span><br><span class="line">        生成一个bits长度的RSA私钥文件，用于签发  </span><br><span class="line">        3.12) -[digest]</span><br><span class="line">        HASH算法</span><br><span class="line">            3.12.1) md5</span><br><span class="line">            3.12.2) sha1</span><br><span class="line">            3.12.3) md2</span><br><span class="line">            3.12.4) mdc2</span><br><span class="line">            3.12.5) md4</span><br><span class="line">        3.13) -config file   </span><br><span class="line">        指定openssl配置文件</span><br><span class="line">        3.14) -text: text显示格式</span><br><span class="line">    example1: 利用CA的RSA密钥创建一个自签署的CA证书(X.509结构) </span><br><span class="line">    openssl req -new -x509 -days 3650 -key server.key -out ca.crt </span><br><span class="line">    example2: 用server.key生成证书签署请求CSR(这个CSR用于之外发送待CA中心等待签发)</span><br><span class="line">    openssl req -new -key server.key -out server.csr</span><br><span class="line">    example3: 查看CSR的细节</span><br><span class="line">    openssl req -noout -text -in server.csr</span><br><span class="line"></span><br><span class="line">    4) genrsa: 生成RSA参数</span><br><span class="line">    openssl genrsa [args] [numbits]</span><br><span class="line">        [args]</span><br><span class="line">        4.1) 对生成的私钥文件是否要使用加密算法进行对称加密:</span><br><span class="line">            4.1.1) -des: CBC模式的DES加密</span><br><span class="line">            4.1.2) -des3: CBC模式的DES加密</span><br><span class="line">            4.1.3) -aes128: CBC模式的AES128加密</span><br><span class="line">            4.1.4) -aes192: CBC模式的AES192加密</span><br><span class="line">            4.1.5) -aes256: CBC模式的AES256加密</span><br><span class="line">        4.2) -passout arg: arg为对称加密(des、des、aes)的密码(使用这个参数就省去了console交互提示输入密码的环节)</span><br><span class="line">        4.3) -out file: 输出证书私钥文件</span><br><span class="line">        [numbits]: 密钥长度</span><br><span class="line">    example: 生成一个1024位的RSA私钥，并用DES加密(密码为1111)，保存为server.key文件</span><br><span class="line">    openssl genrsa -out server.key -passout pass:1111 -des3 1024 </span><br><span class="line"></span><br><span class="line">    5) rsa: RSA数据管理</span><br><span class="line">    openssl rsa [options] &lt;infile &gt;outfile</span><br><span class="line">        5.1) -inform arg</span><br><span class="line">        输入密钥文件格式:</span><br><span class="line">            5.1.1) DER(ASN1)</span><br><span class="line">            5.1.2) NET</span><br><span class="line">            5.1.3) PEM(base64编码格式)</span><br><span class="line">         5.2) -outform arg</span><br><span class="line">         输出密钥文件格式</span><br><span class="line">            5.2.1) DER</span><br><span class="line">            5.2.2) NET</span><br><span class="line">            5.2.3) PEM</span><br><span class="line">        5.3) -in arg</span><br><span class="line">        待处理密钥文件 </span><br><span class="line">        5.4) -passin arg</span><br><span class="line">        输入这个加密密钥文件的解密密钥(如果在生成这个密钥文件的时候，选择了加密算法了的话)</span><br><span class="line">        5.5) -out arg</span><br><span class="line">        待输出密钥文件</span><br><span class="line">        5.6) -passout arg  </span><br><span class="line">        如果希望输出的密钥文件继续使用加密算法的话则指定密码 </span><br><span class="line">        5.7) -des: CBC模式的DES加密</span><br><span class="line">        5.8) -des3: CBC模式的DES加密</span><br><span class="line">        5.9) -aes128: CBC模式的AES128加密</span><br><span class="line">        5.10) -aes192: CBC模式的AES192加密</span><br><span class="line">        5.11) -aes256: CBC模式的AES256加密</span><br><span class="line">        5.12) -text: 以text形式打印密钥key数据 </span><br><span class="line">        5.13) -noout: 不打印密钥key数据 </span><br><span class="line">        5.14) -pubin: 检查待处理文件是否为公钥文件</span><br><span class="line">        5.15) -pubout: 输出公钥文件</span><br><span class="line">    example1: 对私钥文件进行解密</span><br><span class="line">    openssl rsa -in server.key -passin pass:111 -out server_nopass.key</span><br><span class="line">    example:2: 利用私钥文件生成对应的公钥文件</span><br><span class="line">    openssl rsa -in server.key -passin pass:111 -pubout -out server_public.key</span><br><span class="line"></span><br><span class="line">    6) x509:</span><br><span class="line">    本指令是一个功能很丰富的证书处理工具。可以用来显示证书的内容，转换其格式，给CSR签名等X.509证书的管理工作</span><br><span class="line">    openssl x509 [args]    </span><br><span class="line">        6.1) -inform arg</span><br><span class="line">        待处理X509证书文件格式</span><br><span class="line">            6.1.1) DER</span><br><span class="line">            6.1.2) NET</span><br><span class="line">            6.1.3) PEM</span><br><span class="line">        6.2) -outform arg   </span><br><span class="line">        待输出X509证书文件格式</span><br><span class="line">            6.2.1) DER</span><br><span class="line">            6.2.2) NET</span><br><span class="line">            6.2.3) PEM</span><br><span class="line">        6.3) -in arg </span><br><span class="line">        待处理X509证书文件</span><br><span class="line">        6.4) -out arg       </span><br><span class="line">        待输出X509证书文件</span><br><span class="line">        6.5) -req            </span><br><span class="line">        表明输入文件是一个&quot;请求签发证书文件(CSR)&quot;，等待进行签发 </span><br><span class="line">        6.6) -days arg       </span><br><span class="line">        表明将要签发的证书的有效时间 </span><br><span class="line">        6.7) -CA arg </span><br><span class="line">        指定用于签发请求证书的根CA证书 </span><br><span class="line">        6.8) -CAform arg     </span><br><span class="line">        根CA证书格式(默认是PEM) </span><br><span class="line">        6.9) -CAkey arg      </span><br><span class="line">        指定用于签发请求证书的CA私钥证书文件，如果这个option没有参数输入，那么缺省认为私有密钥在CA证书文件里有</span><br><span class="line">        6.10) -CAkeyform arg  </span><br><span class="line">        指定根CA私钥证书文件格式(默认为PEM格式)</span><br><span class="line">        6.11) -CAserial arg   </span><br><span class="line">        指定序列号文件(serial number file)</span><br><span class="line">        6.12) -CAcreateserial </span><br><span class="line">        如果序列号文件(serial number file)没有指定，则自动创建它     </span><br><span class="line">    example1: 转换DER证书为PEM格式</span><br><span class="line">    openssl x509 -in cert.cer -inform DER -outform PEM -out cert.pem</span><br><span class="line">    example2: 使用根CA证书对&quot;请求签发证书&quot;进行签发，生成x509格式证书</span><br><span class="line">    openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt</span><br><span class="line">    example3: 打印出证书的内容</span><br><span class="line">    openssl x509 -in server.crt -noout -text </span><br><span class="line"></span><br><span class="line">    7) crl: crl是用于管理CRL列表 </span><br><span class="line">    openssl crl [args]</span><br><span class="line">        7.1) -inform arg</span><br><span class="line">        输入文件的格式</span><br><span class="line">            7.1.1) DER(DER编码的CRL对象)</span><br><span class="line">            7.1.2) PEM(默认的格式)(base64编码的CRL对象)</span><br><span class="line">        7.2) -outform arg</span><br><span class="line">        指定文件的输出格式 </span><br><span class="line">            7.2.1) DER(DER编码的CRL对象)</span><br><span class="line">            7.2.2) PEM(默认的格式)(base64编码的CRL对象)</span><br><span class="line">        7.3) -text: </span><br><span class="line">        以文本格式来打印CRL信息值。</span><br><span class="line">        7.4) -in filename</span><br><span class="line">        指定的输入文件名。默认为标准输入。</span><br><span class="line">        7.5) -out filename</span><br><span class="line">        指定的输出文件名。默认为标准输出。</span><br><span class="line">        7.6) -hash</span><br><span class="line">        输出颁发者信息值的哈希值。这一项可用于在文件中根据颁发者信息值的哈希值来查询CRL对象。</span><br><span class="line">        7.7) -fingerprint</span><br><span class="line">        打印CRL对象的标识。</span><br><span class="line">        7.8) -issuer</span><br><span class="line">        输出颁发者的信息值。</span><br><span class="line">        7.9) -lastupdate</span><br><span class="line">        输出上一次更新的时间。</span><br><span class="line">        7.10) -nextupdate</span><br><span class="line">        打印出下一次更新的时间。 </span><br><span class="line">        7.11) -CAfile file</span><br><span class="line">        指定CA文件，用来验证该CRL对象是否合法。 </span><br><span class="line">        7.12) -verify</span><br><span class="line">        是否验证证书。        </span><br><span class="line">    example1: 输出CRL文件，包括(颁发者信息HASH值、上一次更新的时间、下一次更新的时间)</span><br><span class="line">    openssl crl -in crl.crl -text -issuer -hash -lastupdate –nextupdate </span><br><span class="line">    example2: 将PEM格式的CRL文件转换为DER格式</span><br><span class="line">    openssl crl -in crl.pem -outform DER -out crl.der  </span><br><span class="line"></span><br><span class="line">    8) crl2pkcs7: 用于CRL和PKCS#7之间的转换 </span><br><span class="line">    openssl crl2pkcs7 [options] &lt;infile &gt;outfile</span><br><span class="line">    转换pem到spc</span><br><span class="line">    openssl crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc</span><br><span class="line">    https://www.openssl.org/docs/apps/crl2pkcs7.html</span><br><span class="line"></span><br><span class="line">    9) pkcs12: PKCS#12数据的管理</span><br><span class="line">    pkcs12文件工具，能生成和分析pkcs12文件。PKCS#12文件可以被用于多个项目，例如包含Netscape、 MSIE 和 MS Outlook</span><br><span class="line">    openssl pkcs12 [options] </span><br><span class="line">    http://blog.csdn.net/as3luyuan123/article/details/16105475</span><br><span class="line">    https://www.openssl.org/docs/apps/pkcs12.html</span><br><span class="line"></span><br><span class="line">    10) pkcs7: PCKS#7数据的管理 </span><br><span class="line">    用于处理DER或者PEM格式的pkcs#7文件</span><br><span class="line">    openssl pkcs7 [options] &lt;infile &gt;outfile</span><br><span class="line">    http://blog.csdn.net/as3luyuan123/article/details/16105407</span><br><span class="line">    https://www.openssl.org/docs/apps/pkcs7.html</span><br></pre></td></tr></table></figure>
<h1 id="openssl-list-message-digest-commands-消息摘要命令"><a href="#openssl-list-message-digest-commands-消息摘要命令" class="headerlink" title="openssl list-message-digest-commands(消息摘要命令)"></a>openssl list-message-digest-commands(消息摘要命令)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) dgst: dgst用于计算消息摘要 </span><br><span class="line">openssl dgst [args]</span><br><span class="line">    1.1) -hex           </span><br><span class="line">    以16进制形式输出摘要</span><br><span class="line">    1.2) -binary        </span><br><span class="line">    以二进制形式输出摘要</span><br><span class="line">    1.3) -sign file    </span><br><span class="line">    以私钥文件对生成的摘要进行签名</span><br><span class="line">    1.4) -verify file    </span><br><span class="line">    使用公钥文件对私钥签名过的摘要文件进行验证 </span><br><span class="line">    1.5) -prverify file  </span><br><span class="line">    以私钥文件对公钥签名过的摘要文件进行验证</span><br><span class="line">    verify a signature using private key in file</span><br><span class="line">    1.6) 加密处理</span><br><span class="line">        1.6.1) -md5: MD5 </span><br><span class="line">        1.6.2) -md4: MD4         </span><br><span class="line">        1.6.3) -sha1: SHA1 </span><br><span class="line">        1.6.4) -ripemd160</span><br><span class="line">example1: 用SHA1算法计算文件file.txt的哈西值，输出到stdout</span><br><span class="line">openssl dgst -sha1 file.txt</span><br><span class="line">example2: 用dss1算法验证file.txt的数字签名dsasign.bin，验证的private key为DSA算法产生的文件dsakey.pem</span><br><span class="line">openssl dgst -dss1 -prverify dsakey.pem -signature dsasign.bin file.txt</span><br><span class="line"></span><br><span class="line">2) sha1: 用于进行RSA处理</span><br><span class="line">openssl sha1 [args] </span><br><span class="line">    2.1) -sign file</span><br><span class="line">    用于RSA算法的私钥文件 </span><br><span class="line">    2.2) -out file</span><br><span class="line">    输出文件爱你</span><br><span class="line">    2.3) -hex   </span><br><span class="line">    以16进制形式输出</span><br><span class="line">    2.4) -binary</span><br><span class="line">    以二进制形式输出  </span><br><span class="line">example1: 用SHA1算法计算文件file.txt的HASH值,输出到文件digest.txt</span><br><span class="line">openssl sha1 -out digest.txt file.txt</span><br><span class="line">example2: 用sha1算法为文件file.txt签名,输出到文件rsasign.bin，签名的private key为RSA算法产生的文件rsaprivate.pem</span><br><span class="line">openssl sha1 -sign rsaprivate.pem -out rsasign.bin file.txt</span><br></pre></td></tr></table></figure>
<h1 id="openssl-list-cipher-commands-Cipher命令的列表"><a href="#openssl-list-cipher-commands-Cipher命令的列表" class="headerlink" title="openssl list-cipher-commands (Cipher命令的列表)"></a>openssl list-cipher-commands (Cipher命令的列表)</h1><blockquote>
</blockquote>
<pre><code>1) aes-128-cbc
2) aes-128-ecb
3) aes-192-cbc
4) aes-192-ecb
5) aes-256-cbc
6) aes-256-ecb
7) base64
8) bf
9) bf-cbc
10) bf-cfb
11) bf-ecb
12) bf-ofb
13) cast
14) cast-cbc
15) cast5-cbc
16) cast5-cfb
17) cast5-ecb
18) cast5-ofb
19) des
20) des-cbc
21) des-cfb
22) des-ecb
23) des-ede
24) des-ede-cbc
25) des-ede-cfb
26) des-ede-ofb
27) des-ede3
28) des-ede3-cbc
29) des-ede3-cfb
30) des-ede3-ofb
31) des-ofb
32) des3
33) desx
34) rc2
35) rc2-40-cbc
36) rc2-64-cbc
37) rc2-cbc
38) rc2-cfb
39) rc2-ecb
40) rc2-ofb
41) rc4
42) rc4-40
</code></pre><p>引用：<a href="https://www.openssl.org/" title="https://www.openssl.org" target="_blank" rel="noopener">https://www.openssl.org/</a></p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>CA证书</tag>
        <tag>OPENSSL</tag>
      </tags>
  </entry>
</search>
