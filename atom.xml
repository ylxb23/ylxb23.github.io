<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>摇蒲小笙</title>
  
  <subtitle>天地不仁，以万物为刍狗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="xn--4gq28lcrm21g.cc/"/>
  <updated>2020-07-04T06:01:06.598Z</updated>
  <id>xn--4gq28lcrm21g.cc/</id>
  
  <author>
    <name>Zero.Zeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>QUIC上手初体验</title>
    <link href="xn--4gq28lcrm21g.cc/article/2020/07/01/2020-07-01-QUIC%E4%B8%8A%E6%89%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>xn--4gq28lcrm21g.cc/article/2020/07/01/2020-07-01-QUIC上手初体验/</id>
    <published>2020-07-01T15:27:33.000Z</published>
    <updated>2020-07-04T06:01:06.598Z</updated>
    
    <content type="html"><![CDATA[<p>安装支持HTTP3的nginx,通过cloudflare云服务开源的quiche实现,其中主要涉及内容包括</p><ul><li>nginx源码</li><li>由cloudflare开源于github的quiche项目(quiche从nginx-1.16.x版本开始支持)</li><li>由google开源于github的boringssl项目(在quiche项目中引用了该项目)</li><li>Rust语言环境(cloudflare/quiche项目build需要)</li><li>Golang语言环境(google/boringssl项目make需要)</li><li>支持https的curl最新版本</li><li>SSL证书生成</li></ul><a id="more"></a><p>首先确定工作路径为<code>~/tools</code>.</p><p>安装nginx可能涉及模块的各项依赖，以及用于生成证书的openssl工具:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install make cmake libssl-dev libpcre3 libpcre3-dev zlib1g-dev openssl autoconf libtool golang-go</span><br></pre></td></tr></table></figure></p><p>注:整个安装过程须全程连网。</p><h1 id="一、安装Rust语言环境"><a href="#一、安装Rust语言环境" class="headerlink" title="一、安装Rust语言环境"></a>一、安装Rust语言环境</h1><p>通过官方安装方式，执行以下命令之后，将下载对应语言环境安装包(大约170MB)，期间有部分操作需人为干预，按提示输入对应内容回车即可。<a href="https://www.rust-lang.org/tools/install" title="Rust环境安装向导" target="_blank" rel="noopener">参考官方文档</a>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto &apos;=https&apos; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure></p><p>一般情况下，Rust安装在用户目录的<code>.cargo/bin</code>路径下，需将该路径加入到PATH变量中，可在<code>/etc/profile</code>文件最后追加如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/zero/.cargo/bin</span><br></pre></td></tr></table></figure></p><p>除此之外，还需指定默认工具链：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rustup default stable</span><br></pre></td></tr></table></figure></p><p>随后可通过如下命令验证Rust语言环境是否安装成功:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zero@zero:~$ rustc --version</span><br><span class="line">rustc 1.44.1 (c7087fe00 2020-06-17)</span><br><span class="line">zero@zero:~$ cargo --version</span><br><span class="line">cargo 1.44.1 (88ba85757 2020-06-11)</span><br><span class="line">zero@zero:~$</span><br></pre></td></tr></table></figure></p><p><strong>注：</strong> 国内访问<code>create.io</code>站点较慢，在后续使用中将从该站点下载必要文件，故采用配置使用镜像站，在<code>~/.cargo</code>目录下创建<code>config</code>文件，输入并保存以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class="line">replace-with = &apos;ustc&apos;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br></pre></td></tr></table></figure></p><h1 id="二、下载quiche项目源码"><a href="#二、下载quiche项目源码" class="headerlink" title="二、下载quiche项目源码"></a>二、下载quiche项目源码</h1><p>通过git直接将<code>cloudflare/quiche</code>项目源码克隆到本地，直接使用master分支:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/cloudflare/quiche</span><br></pre></td></tr></table></figure></p><p>注: <code>--recursive</code> 参数是用于处理git依赖的子项目，在quiche项目clone完成并检出master分支之后可在项目目录下看到<code>.gitmodule</code>文件，其中即是关联子模块的git配置信息，即<a href="#" title="--recursive官方解释: Submodules are initialized and cloned using their default settings. This is equivalent to running git submodule update --init --recursive &lt;pathspec&gt; immediately after the clone is finished. This option is ignored if the cloned repository does not have a worktree/checkout (i.e. if any of --no-checkout/-n, --bare, or --mirror is given).">在clone完成主项目之后立即执行子项目clone至默认配置的目录</a></p><p><strong>注：</strong> 网络环境较差情况下，由于<code>google/boringssl</code>项目文件内容较多(大于100MB)，直接使用<code>--recursive</code>可能失败，如果在 <code>quiche/deps/boringssl</code>目录下无<code>.git</code>等相关文件（即前面的<code>--revursice</code>执行失败了），则可单独到<code>quiche/deps</code>目录下，首先删除<code>boringssl</code>空文件夹，单独clone<code>google/boringssl</code>项目到<code>deps</code>目录下，并在quiche项目下使用git的子模块修复命令修复：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cdo ~/tools/quiche/deps</span><br><span class="line"></span><br><span class="line">rmdir boringssl</span><br><span class="line"></span><br><span class="line">git clone https://github.com/google/boringssl.git</span><br><span class="line"></span><br><span class="line">cd ../</span><br><span class="line"></span><br><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure></p><p>如果修复成功会有类似如下提示(<em>后面的commitId可能不同，可以忽略</em>)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zero@zero:~/tools/quiche$ git submodule update --init </span><br><span class="line">Submodule path &apos;deps/boringssl&apos;: checked out &apos;88024df12147e56b6abd66b743ff441a0aaa09a8&apos;</span><br></pre></td></tr></table></figure></p><h1 id="三、准备CA证书文件"><a href="#三、准备CA证书文件" class="headerlink" title="三、准备CA证书文件"></a>三、准备CA证书文件</h1><p>确定存放CA证书文件的路径为<code>~/tools/openssl</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/tools/openssl</span><br></pre></td></tr></table></figure></p><p>1、使用openssl使用des3算法生成2048位的rsa私钥，此处需输入预置解析密码(需记下以备后用，譬如 ‘123456’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -des3 -out server.key 2048</span><br></pre></td></tr></table></figure></p><p>注：查看刚生成的私钥(需键入解析密码)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -text -in server.key</span><br></pre></td></tr></table></figure></p><p>2、根据刚生成的私钥创建证书签名请求CSR文件，此处需键入包含公司、国家编码、地区编码等信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure></p><p>注：查看生成CSR文件详情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -text -in server.csr -noout</span><br></pre></td></tr></table></figure></p><p>3、删除密钥中的密码，避免在使用该证书的应用加载时需要输入解析密码的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in server.key -out server.key</span><br></pre></td></tr></table></figure></p><p>4、生成时间为10年(尽量长一点时间)的CA证书：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure></p><p>以上一顿操作之后便能在<code>~/tools/openssl</code>目录下看到如下文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zero@zero:~$ ls -a -l -h tools/openssl/</span><br><span class="line">total 20K</span><br><span class="line">drwxrwxr-x 2 zero zero 4.0K Jul  4 03:39 .</span><br><span class="line">drwxrwxr-x 8 zero zero 4.0K Jul  4 03:36 ..</span><br><span class="line">-rw-rw-r-- 1 zero zero 1.3K Jul  4 03:39 server.crt</span><br><span class="line">-rw-rw-r-- 1 zero zero 1.1K Jul  4 03:39 server.csr</span><br><span class="line">-rw------- 1 zero zero 1.7K Jul  4 03:42 server.key</span><br></pre></td></tr></table></figure></p><h1 id="四、编译支持HTTP3的nginx"><a href="#四、编译支持HTTP3的nginx" class="headerlink" title="四、编译支持HTTP3的nginx"></a>四、编译支持HTTP3的nginx</h1><p>转至nginx工作目录下载并解压源码，下载大于或等于1.16.x的nginx版本皆适用，此处使用当前最新稳定版本<code>1.18.0</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ~/tools</span><br><span class="line"></span><br><span class="line">curl -O https://nginx.org/download/nginx-1.18.0.tar.gz </span><br><span class="line"></span><br><span class="line">tar -zxf nginx-1.18.0.tar.gz</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/cloudflare/quiche/tree/master/extras/nginx" title="操作文档" target="_blank" rel="noopener">参考</a>转到nginx源码目录，将<code>cloudflare/quiche</code>项目有关nginx的源码附加到nginx源码中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -p01 &lt; ../quiche/extras/nginx/nginx-1.16.patch</span><br></pre></td></tr></table></figure></p><p>配置编译的nginx支持HTTP/3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./configure                                    \</span><br><span class="line">       --prefix=$PWD                           \</span><br><span class="line">       --build=&quot;quiche-$(git --git-dir=../quiche/.git rev-parse --short HEAD)&quot; \</span><br><span class="line">       --with-http_ssl_module                  \</span><br><span class="line">       --with-http_v2_module                   \</span><br><span class="line">       --with-http_v3_module                   \</span><br><span class="line">       --with-openssl=../quiche/deps/boringssl \</span><br><span class="line">       --with-quiche=../quiche</span><br></pre></td></tr></table></figure></p><p>编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure></p><p>编辑成功提示的日志信息结尾部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ... </span><br><span class="line">-ldl -lpthread -lcrypt -lpcre ../quiche/deps/boringssl/.openssl/lib/libssl.a ../quiche/deps/boringssl/.openssl/lib/libcrypto.a -ldl -lpthread ../quiche/target/release/libquiche.a -lpthread -lz \</span><br><span class="line">-Wl,-E</span><br><span class="line">make[1]: Leaving directory &apos;/home/zero/tools/nginx-1.18.0&apos;</span><br><span class="line">zero@zero:~/tools/nginx-1.18.0$</span><br></pre></td></tr></table></figure></p><p>编译成功后不要忘了在nginx工作目录下创建<code>logs</code>文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir logs</span><br></pre></td></tr></table></figure></p><p>查看编译的nginx版本信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zero@zero:~/tools/nginx-1.18.0$ objs/nginx -V </span><br><span class="line">nginx version: nginx/1.18.0 (quiche-c25a595)</span><br><span class="line">built by gcc 9.3.0 (Ubuntu 9.3.0-10ubuntu2) </span><br><span class="line">built with OpenSSL 1.1.0 (compatible; BoringSSL) (running with BoringSSL)</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/home/zero/tools/nginx-1.18.0 --build=quiche-c25a595 --with-http_ssl_module --with-http_v2_module --with-http_v3_module --with-openssl=../quiche/deps/boringssl --with-quiche=../quiche</span><br><span class="line">zero@zero:~/tools/nginx-1.18.0$</span><br></pre></td></tr></table></figure></p><p>创建日志目录<code>mkdir logs</code>，编辑配置文件，配置监听端口并启用QUIC：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        # Enable QUIC and HTTP/3.</span><br><span class="line">        listen 443 quic reuseport;</span><br><span class="line"></span><br><span class="line">        # Enable HTTP/2 (optional).</span><br><span class="line">        listen 443 ssl http2;</span><br><span class="line"></span><br><span class="line">        ssl_certificate      /home/zero/tools/openssl/server.crt;</span><br><span class="line">        ssl_certificate_key  /home/zero/tools/openssl/server.key;</span><br><span class="line"></span><br><span class="line">        # Enable all TLS versions (TLSv1.3 is required for QUIC).</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class="line"></span><br><span class="line">        # Request buffering in not currently supported for HTTP/3.</span><br><span class="line">        proxy_request_buffering off;</span><br><span class="line"></span><br><span class="line">        # Add Alt-Svc header to negotiate HTTP/3.</span><br><span class="line">        add_header alt-svc &apos;h3-29=&quot;:443&quot;; ma=86400&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="五、编译支持HTTP-3的curl工具"><a href="#五、编译支持HTTP-3的curl工具" class="headerlink" title="五、编译支持HTTP/3的curl工具"></a>五、编译支持HTTP/3的curl工具</h1><p>首先到quiche目录下编译quiche和BoringSSL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~/tools/quiche</span><br><span class="line"></span><br><span class="line">sudo cargo build --release --features pkg-config-meta,qlog</span><br><span class="line"></span><br><span class="line">mkdir deps/boringssl/lib</span><br><span class="line"></span><br><span class="line">sudo ln -vnf $(find target/release -name libcrypto.a -o -name libssl.a) deps/boringssl/lib/</span><br></pre></td></tr></table></figure></p><p>转至<code>~/tools/</code>目录下通过git将<code>curl/curl</code>项目源码下载到<code>~/tools</code>工作目录下，直接使用master分支即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/tools</span><br><span class="line"></span><br><span class="line">git clone https://github.com/curl/curl.git</span><br></pre></td></tr></table></figure></p><p>转到<code>curl</code>目录下编译curl：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd curl</span><br><span class="line"></span><br><span class="line">./buildconf</span><br><span class="line"></span><br><span class="line">./configure LDFLAGS=&quot;-Wl,-rpath,$PWD/../quiche/target/release&quot; --with-ssl=$PWD/../quiche/deps/boringssl --with-quiche=$PWD/../quiche/target/release --enable-alt-svc</span><br><span class="line"> </span><br><span class="line"> sudo make</span><br></pre></td></tr></table></figure></p><p>编译成功后，curl工具在src目录下，通过curl请求HTTP/3示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">zero@zero:~/tools/curl$ src/curl --http3 https://localhost -k -I </span><br><span class="line">HTTP/3 200</span><br><span class="line">server: nginx/1.18.0</span><br><span class="line">date: Sat, 04 Jul 2020 05:28:15 GMT</span><br><span class="line">content-type: text/html</span><br><span class="line">content-length: 612</span><br><span class="line">last-modified: Tue, 21 Apr 2020 14:09:01 GMT</span><br><span class="line">etag: <span class="string">"5e9efe7d-264"</span></span><br><span class="line">alt-svc: h3-29=<span class="string">":443"</span>; ma=86400</span><br><span class="line">accept-ranges: bytes</span><br><span class="line">zero@zero:~/tools/curl$</span><br></pre></td></tr></table></figure></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://github.com/cloudflare/quiche/tree/master/extras/nginx" title="cloudflare/quiche" target="_blank" rel="noopener">nginx集成quiche</a><br><a href="https://github.com/curl/curl/blob/master/docs/HTTP3.md" title="curl/curl" target="_blank" rel="noopener">编译curl</a><br><a href="https://github.com/google/boringssl &quot;google/boringssl" target="_blank" rel="noopener">boringssl</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装支持HTTP3的nginx,通过cloudflare云服务开源的quiche实现,其中主要涉及内容包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nginx源码&lt;/li&gt;
&lt;li&gt;由cloudflare开源于github的quiche项目(quiche从nginx-1.16.x版本开始支持)&lt;/li&gt;
&lt;li&gt;由google开源于github的boringssl项目(在quiche项目中引用了该项目)&lt;/li&gt;
&lt;li&gt;Rust语言环境(cloudflare/quiche项目build需要)&lt;/li&gt;
&lt;li&gt;Golang语言环境(google/boringssl项目make需要)&lt;/li&gt;
&lt;li&gt;支持https的curl最新版本&lt;/li&gt;
&lt;li&gt;SSL证书生成&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTTP" scheme="xn--4gq28lcrm21g.cc/dist/categories/HTTP/"/>
    
    
      <category term="HTTP/3" scheme="xn--4gq28lcrm21g.cc/dist/tags/HTTP-3/"/>
    
      <category term="QUIC" scheme="xn--4gq28lcrm21g.cc/dist/tags/QUIC/"/>
    
  </entry>
  
  <entry>
    <title>OPENSSL命令参考</title>
    <link href="xn--4gq28lcrm21g.cc/article/2020/06/30/2020-06-30-OPENSSL%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83/"/>
    <id>xn--4gq28lcrm21g.cc/article/2020/06/30/2020-06-30-OPENSSL命令参考/</id>
    <published>2020-06-30T04:51:05.000Z</published>
    <updated>2020-07-04T05:11:34.856Z</updated>
    
    <content type="html"><![CDATA[<p>一般使用openssl生成证书步骤：<br>1、使用openssl使用des3算法生成2048位的rsa私钥，此处需输入预置解析密码(需记下以备后用，譬如<code>123456</code>)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -des3 -out server.key 2048</span><br></pre></td></tr></table></figure></p><p>注：查看刚生成的私钥(需键入解析密码)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -text -in server.key</span><br></pre></td></tr></table></figure></p><p>2、根据刚生成的私钥创建证书签名请求CSR文件，此处需键入包含公司、国家编码、地区编码等信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure></p><p>注：查看生成CSR文件详情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -text -in server.csr -noout</span><br></pre></td></tr></table></figure></p><p>3、删除密钥中的密码，避免在使用该证书的应用加载时需要输入解析密码的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in server.key -out server.key</span><br></pre></td></tr></table></figure></p><p>4、生成时间为10年(尽量长一点时间)的CA证书：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure></p><p>以上一顿操作之后便能在<code>~/tools/openssl</code>目录下看到如下文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zero@zero:~$ ls -a -l -h tools/openssl/</span><br><span class="line">total 20K</span><br><span class="line">drwxrwxr-x 2 zero zero 4.0K Jul  4 03:39 .</span><br><span class="line">drwxrwxr-x 8 zero zero 4.0K Jul  4 03:36 ..</span><br><span class="line">-rw-rw-r-- 1 zero zero 1.3K Jul  4 03:39 server.crt</span><br><span class="line">-rw-rw-r-- 1 zero zero 1.1K Jul  4 03:39 server.csr</span><br><span class="line">-rw------- 1 zero zero 1.7K Jul  4 03:42 server.key</span><br></pre></td></tr></table></figure></p><p>另：如果有需要PEM格式证书，可通过以下方式生成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in server.crt  -outform PEM -out server.pem</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="openssl-list-standard-commands-标准命令"><a href="#openssl-list-standard-commands-标准命令" class="headerlink" title="openssl list-standard-commands(标准命令)"></a>openssl list-standard-commands(标准命令)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line">    1) asn1parse: asn1parse用于解释用ANS.1语法书写的语句(ASN一般用于定义语法的构成) </span><br><span class="line">    2) ca: ca用于CA的管理 </span><br><span class="line">    openssl ca [options]:</span><br><span class="line">        2.1) -selfsign</span><br><span class="line">        使用对证书请求进行签名的密钥对来签发证书。即&quot;自签名&quot;，这种情况发生在生成证书的客户端、签发证书的CA都是同一台机器(也是我们大多数实验中的情况)，我们可以使用同一个</span><br><span class="line">密钥对来进行&quot;自签名&quot;</span><br><span class="line">        2.2) -in file</span><br><span class="line">        需要进行处理的PEM格式的证书</span><br><span class="line">        2.3) -out file</span><br><span class="line">        处理结束后输出的证书文件</span><br><span class="line">        2.4) -cert file</span><br><span class="line">        用于签发的根CA证书</span><br><span class="line">        2.5) -days arg </span><br><span class="line">        指定签发的证书的有效时间</span><br><span class="line">        2.6) -keyfile arg   </span><br><span class="line">        CA的私钥证书文件</span><br><span class="line">        2.7) -keyform arg</span><br><span class="line">        CA的根私钥证书文件格式:</span><br><span class="line">            2.7.1) PEM</span><br><span class="line">            2.7.2) ENGINE </span><br><span class="line">        2.8) -key arg   </span><br><span class="line">        CA的根私钥证书文件的解密密码(如果加密了的话)</span><br><span class="line">        2.9) -config file    </span><br><span class="line">        配置文件</span><br><span class="line">    example1: 利用CA证书签署请求证书</span><br><span class="line">    openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key  </span><br><span class="line"></span><br><span class="line">    3) req: X.509证书签发请求(CSR)管理</span><br><span class="line">    openssl req [options] &lt;infile &gt;outfile</span><br><span class="line">        3.1) -inform arg</span><br><span class="line">        输入文件格式</span><br><span class="line">            3.1.1) DER</span><br><span class="line">            3.1.2) PEM</span><br><span class="line">        3.2) -outform arg   </span><br><span class="line">        输出文件格式</span><br><span class="line">            3.2.1) DER</span><br><span class="line">            3.2.2) PEM</span><br><span class="line">        3.3) -in arg</span><br><span class="line">        待处理文件</span><br><span class="line">        3.4) -out arg</span><br><span class="line">        待输出文件</span><br><span class="line">        3.5) -passin        </span><br><span class="line">        用于签名待生成的请求证书的私钥文件的解密密码</span><br><span class="line">        3.6) -key file</span><br><span class="line">        用于签名待生成的请求证书的私钥文件</span><br><span class="line">        3.7) -keyform arg  </span><br><span class="line">            3.7.1) DER</span><br><span class="line">            3.7.2) NET</span><br><span class="line">            3.7.3) PEM</span><br><span class="line">        3.8) -new</span><br><span class="line">        新的请求</span><br><span class="line">        3.9) -x509          </span><br><span class="line">        输出一个X509格式的证书 </span><br><span class="line">        3.10) -days</span><br><span class="line">        X509证书的有效时间  </span><br><span class="line">        3.11) -newkey rsa:bits </span><br><span class="line">        生成一个bits长度的RSA私钥文件，用于签发  </span><br><span class="line">        3.12) -[digest]</span><br><span class="line">        HASH算法</span><br><span class="line">            3.12.1) md5</span><br><span class="line">            3.12.2) sha1</span><br><span class="line">            3.12.3) md2</span><br><span class="line">            3.12.4) mdc2</span><br><span class="line">            3.12.5) md4</span><br><span class="line">        3.13) -config file   </span><br><span class="line">        指定openssl配置文件</span><br><span class="line">        3.14) -text: text显示格式</span><br><span class="line">    example1: 利用CA的RSA密钥创建一个自签署的CA证书(X.509结构) </span><br><span class="line">    openssl req -new -x509 -days 3650 -key server.key -out ca.crt </span><br><span class="line">    example2: 用server.key生成证书签署请求CSR(这个CSR用于之外发送待CA中心等待签发)</span><br><span class="line">    openssl req -new -key server.key -out server.csr</span><br><span class="line">    example3: 查看CSR的细节</span><br><span class="line">    openssl req -noout -text -in server.csr</span><br><span class="line"></span><br><span class="line">    4) genrsa: 生成RSA参数</span><br><span class="line">    openssl genrsa [args] [numbits]</span><br><span class="line">        [args]</span><br><span class="line">        4.1) 对生成的私钥文件是否要使用加密算法进行对称加密:</span><br><span class="line">            4.1.1) -des: CBC模式的DES加密</span><br><span class="line">            4.1.2) -des3: CBC模式的DES加密</span><br><span class="line">            4.1.3) -aes128: CBC模式的AES128加密</span><br><span class="line">            4.1.4) -aes192: CBC模式的AES192加密</span><br><span class="line">            4.1.5) -aes256: CBC模式的AES256加密</span><br><span class="line">        4.2) -passout arg: arg为对称加密(des、des、aes)的密码(使用这个参数就省去了console交互提示输入密码的环节)</span><br><span class="line">        4.3) -out file: 输出证书私钥文件</span><br><span class="line">        [numbits]: 密钥长度</span><br><span class="line">    example: 生成一个1024位的RSA私钥，并用DES加密(密码为1111)，保存为server.key文件</span><br><span class="line">    openssl genrsa -out server.key -passout pass:1111 -des3 1024 </span><br><span class="line"></span><br><span class="line">    5) rsa: RSA数据管理</span><br><span class="line">    openssl rsa [options] &lt;infile &gt;outfile</span><br><span class="line">        5.1) -inform arg</span><br><span class="line">        输入密钥文件格式:</span><br><span class="line">            5.1.1) DER(ASN1)</span><br><span class="line">            5.1.2) NET</span><br><span class="line">            5.1.3) PEM(base64编码格式)</span><br><span class="line">         5.2) -outform arg</span><br><span class="line">         输出密钥文件格式</span><br><span class="line">            5.2.1) DER</span><br><span class="line">            5.2.2) NET</span><br><span class="line">            5.2.3) PEM</span><br><span class="line">        5.3) -in arg</span><br><span class="line">        待处理密钥文件 </span><br><span class="line">        5.4) -passin arg</span><br><span class="line">        输入这个加密密钥文件的解密密钥(如果在生成这个密钥文件的时候，选择了加密算法了的话)</span><br><span class="line">        5.5) -out arg</span><br><span class="line">        待输出密钥文件</span><br><span class="line">        5.6) -passout arg  </span><br><span class="line">        如果希望输出的密钥文件继续使用加密算法的话则指定密码 </span><br><span class="line">        5.7) -des: CBC模式的DES加密</span><br><span class="line">        5.8) -des3: CBC模式的DES加密</span><br><span class="line">        5.9) -aes128: CBC模式的AES128加密</span><br><span class="line">        5.10) -aes192: CBC模式的AES192加密</span><br><span class="line">        5.11) -aes256: CBC模式的AES256加密</span><br><span class="line">        5.12) -text: 以text形式打印密钥key数据 </span><br><span class="line">        5.13) -noout: 不打印密钥key数据 </span><br><span class="line">        5.14) -pubin: 检查待处理文件是否为公钥文件</span><br><span class="line">        5.15) -pubout: 输出公钥文件</span><br><span class="line">    example1: 对私钥文件进行解密</span><br><span class="line">    openssl rsa -in server.key -passin pass:111 -out server_nopass.key</span><br><span class="line">    example:2: 利用私钥文件生成对应的公钥文件</span><br><span class="line">    openssl rsa -in server.key -passin pass:111 -pubout -out server_public.key</span><br><span class="line"></span><br><span class="line">    6) x509:</span><br><span class="line">    本指令是一个功能很丰富的证书处理工具。可以用来显示证书的内容，转换其格式，给CSR签名等X.509证书的管理工作</span><br><span class="line">    openssl x509 [args]    </span><br><span class="line">        6.1) -inform arg</span><br><span class="line">        待处理X509证书文件格式</span><br><span class="line">            6.1.1) DER</span><br><span class="line">            6.1.2) NET</span><br><span class="line">            6.1.3) PEM</span><br><span class="line">        6.2) -outform arg   </span><br><span class="line">        待输出X509证书文件格式</span><br><span class="line">            6.2.1) DER</span><br><span class="line">            6.2.2) NET</span><br><span class="line">            6.2.3) PEM</span><br><span class="line">        6.3) -in arg </span><br><span class="line">        待处理X509证书文件</span><br><span class="line">        6.4) -out arg       </span><br><span class="line">        待输出X509证书文件</span><br><span class="line">        6.5) -req            </span><br><span class="line">        表明输入文件是一个&quot;请求签发证书文件(CSR)&quot;，等待进行签发 </span><br><span class="line">        6.6) -days arg       </span><br><span class="line">        表明将要签发的证书的有效时间 </span><br><span class="line">        6.7) -CA arg </span><br><span class="line">        指定用于签发请求证书的根CA证书 </span><br><span class="line">        6.8) -CAform arg     </span><br><span class="line">        根CA证书格式(默认是PEM) </span><br><span class="line">        6.9) -CAkey arg      </span><br><span class="line">        指定用于签发请求证书的CA私钥证书文件，如果这个option没有参数输入，那么缺省认为私有密钥在CA证书文件里有</span><br><span class="line">        6.10) -CAkeyform arg  </span><br><span class="line">        指定根CA私钥证书文件格式(默认为PEM格式)</span><br><span class="line">        6.11) -CAserial arg   </span><br><span class="line">        指定序列号文件(serial number file)</span><br><span class="line">        6.12) -CAcreateserial </span><br><span class="line">        如果序列号文件(serial number file)没有指定，则自动创建它     </span><br><span class="line">    example1: 转换DER证书为PEM格式</span><br><span class="line">    openssl x509 -in cert.cer -inform DER -outform PEM -out cert.pem</span><br><span class="line">    example2: 使用根CA证书对&quot;请求签发证书&quot;进行签发，生成x509格式证书</span><br><span class="line">    openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt</span><br><span class="line">    example3: 打印出证书的内容</span><br><span class="line">    openssl x509 -in server.crt -noout -text </span><br><span class="line"></span><br><span class="line">    7) crl: crl是用于管理CRL列表 </span><br><span class="line">    openssl crl [args]</span><br><span class="line">        7.1) -inform arg</span><br><span class="line">        输入文件的格式</span><br><span class="line">            7.1.1) DER(DER编码的CRL对象)</span><br><span class="line">            7.1.2) PEM(默认的格式)(base64编码的CRL对象)</span><br><span class="line">        7.2) -outform arg</span><br><span class="line">        指定文件的输出格式 </span><br><span class="line">            7.2.1) DER(DER编码的CRL对象)</span><br><span class="line">            7.2.2) PEM(默认的格式)(base64编码的CRL对象)</span><br><span class="line">        7.3) -text: </span><br><span class="line">        以文本格式来打印CRL信息值。</span><br><span class="line">        7.4) -in filename</span><br><span class="line">        指定的输入文件名。默认为标准输入。</span><br><span class="line">        7.5) -out filename</span><br><span class="line">        指定的输出文件名。默认为标准输出。</span><br><span class="line">        7.6) -hash</span><br><span class="line">        输出颁发者信息值的哈希值。这一项可用于在文件中根据颁发者信息值的哈希值来查询CRL对象。</span><br><span class="line">        7.7) -fingerprint</span><br><span class="line">        打印CRL对象的标识。</span><br><span class="line">        7.8) -issuer</span><br><span class="line">        输出颁发者的信息值。</span><br><span class="line">        7.9) -lastupdate</span><br><span class="line">        输出上一次更新的时间。</span><br><span class="line">        7.10) -nextupdate</span><br><span class="line">        打印出下一次更新的时间。 </span><br><span class="line">        7.11) -CAfile file</span><br><span class="line">        指定CA文件，用来验证该CRL对象是否合法。 </span><br><span class="line">        7.12) -verify</span><br><span class="line">        是否验证证书。        </span><br><span class="line">    example1: 输出CRL文件，包括(颁发者信息HASH值、上一次更新的时间、下一次更新的时间)</span><br><span class="line">    openssl crl -in crl.crl -text -issuer -hash -lastupdate –nextupdate </span><br><span class="line">    example2: 将PEM格式的CRL文件转换为DER格式</span><br><span class="line">    openssl crl -in crl.pem -outform DER -out crl.der  </span><br><span class="line"></span><br><span class="line">    8) crl2pkcs7: 用于CRL和PKCS#7之间的转换 </span><br><span class="line">    openssl crl2pkcs7 [options] &lt;infile &gt;outfile</span><br><span class="line">    转换pem到spc</span><br><span class="line">    openssl crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc</span><br><span class="line">    https://www.openssl.org/docs/apps/crl2pkcs7.html</span><br><span class="line"></span><br><span class="line">    9) pkcs12: PKCS#12数据的管理</span><br><span class="line">    pkcs12文件工具，能生成和分析pkcs12文件。PKCS#12文件可以被用于多个项目，例如包含Netscape、 MSIE 和 MS Outlook</span><br><span class="line">    openssl pkcs12 [options] </span><br><span class="line">    http://blog.csdn.net/as3luyuan123/article/details/16105475</span><br><span class="line">    https://www.openssl.org/docs/apps/pkcs12.html</span><br><span class="line"></span><br><span class="line">    10) pkcs7: PCKS#7数据的管理 </span><br><span class="line">    用于处理DER或者PEM格式的pkcs#7文件</span><br><span class="line">    openssl pkcs7 [options] &lt;infile &gt;outfile</span><br><span class="line">    http://blog.csdn.net/as3luyuan123/article/details/16105407</span><br><span class="line">    https://www.openssl.org/docs/apps/pkcs7.html</span><br></pre></td></tr></table></figure><h1 id="openssl-list-message-digest-commands-消息摘要命令"><a href="#openssl-list-message-digest-commands-消息摘要命令" class="headerlink" title="openssl list-message-digest-commands(消息摘要命令)"></a>openssl list-message-digest-commands(消息摘要命令)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1) dgst: dgst用于计算消息摘要 </span><br><span class="line">openssl dgst [args]</span><br><span class="line">    1.1) -hex           </span><br><span class="line">    以16进制形式输出摘要</span><br><span class="line">    1.2) -binary        </span><br><span class="line">    以二进制形式输出摘要</span><br><span class="line">    1.3) -sign file    </span><br><span class="line">    以私钥文件对生成的摘要进行签名</span><br><span class="line">    1.4) -verify file    </span><br><span class="line">    使用公钥文件对私钥签名过的摘要文件进行验证 </span><br><span class="line">    1.5) -prverify file  </span><br><span class="line">    以私钥文件对公钥签名过的摘要文件进行验证</span><br><span class="line">    verify a signature using private key in file</span><br><span class="line">    1.6) 加密处理</span><br><span class="line">        1.6.1) -md5: MD5 </span><br><span class="line">        1.6.2) -md4: MD4         </span><br><span class="line">        1.6.3) -sha1: SHA1 </span><br><span class="line">        1.6.4) -ripemd160</span><br><span class="line">example1: 用SHA1算法计算文件file.txt的哈西值，输出到stdout</span><br><span class="line">openssl dgst -sha1 file.txt</span><br><span class="line">example2: 用dss1算法验证file.txt的数字签名dsasign.bin，验证的private key为DSA算法产生的文件dsakey.pem</span><br><span class="line">openssl dgst -dss1 -prverify dsakey.pem -signature dsasign.bin file.txt</span><br><span class="line"></span><br><span class="line">2) sha1: 用于进行RSA处理</span><br><span class="line">openssl sha1 [args] </span><br><span class="line">    2.1) -sign file</span><br><span class="line">    用于RSA算法的私钥文件 </span><br><span class="line">    2.2) -out file</span><br><span class="line">    输出文件爱你</span><br><span class="line">    2.3) -hex   </span><br><span class="line">    以16进制形式输出</span><br><span class="line">    2.4) -binary</span><br><span class="line">    以二进制形式输出  </span><br><span class="line">example1: 用SHA1算法计算文件file.txt的HASH值,输出到文件digest.txt</span><br><span class="line">openssl sha1 -out digest.txt file.txt</span><br><span class="line">example2: 用sha1算法为文件file.txt签名,输出到文件rsasign.bin，签名的private key为RSA算法产生的文件rsaprivate.pem</span><br><span class="line">openssl sha1 -sign rsaprivate.pem -out rsasign.bin file.txt</span><br></pre></td></tr></table></figure><h1 id="openssl-list-cipher-commands-Cipher命令的列表"><a href="#openssl-list-cipher-commands-Cipher命令的列表" class="headerlink" title="openssl list-cipher-commands (Cipher命令的列表)"></a>openssl list-cipher-commands (Cipher命令的列表)</h1><blockquote></blockquote><pre><code>1) aes-128-cbc2) aes-128-ecb3) aes-192-cbc4) aes-192-ecb5) aes-256-cbc6) aes-256-ecb7) base648) bf9) bf-cbc10) bf-cfb11) bf-ecb12) bf-ofb13) cast14) cast-cbc15) cast5-cbc16) cast5-cfb17) cast5-ecb18) cast5-ofb19) des20) des-cbc21) des-cfb22) des-ecb23) des-ede24) des-ede-cbc25) des-ede-cfb26) des-ede-ofb27) des-ede328) des-ede3-cbc29) des-ede3-cfb30) des-ede3-ofb31) des-ofb32) des333) desx34) rc235) rc2-40-cbc36) rc2-64-cbc37) rc2-cbc38) rc2-cfb39) rc2-ecb40) rc2-ofb41) rc442) rc4-40</code></pre><p>引用：<a href="https://www.openssl.org/" title="https://www.openssl.org" target="_blank" rel="noopener">https://www.openssl.org/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般使用openssl生成证书步骤：&lt;br&gt;1、使用openssl使用des3算法生成2048位的rsa私钥，此处需输入预置解析密码(需记下以备后用，譬如&lt;code&gt;123456&lt;/code&gt;)：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;openssl genrsa -des3 -out server.key 2048&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注：查看刚生成的私钥(需键入解析密码)：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;openssl rsa -text -in server.key&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2、根据刚生成的私钥创建证书签名请求CSR文件，此处需键入包含公司、国家编码、地区编码等信息：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;openssl req -new -key server.key -out server.csr&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注：查看生成CSR文件详情：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;openssl req -text -in server.csr -noout&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3、删除密钥中的密码，避免在使用该证书的应用加载时需要输入解析密码的操作：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;openssl rsa -in server.key -out server.key&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;4、生成时间为10年(尽量长一点时间)的CA证书：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上一顿操作之后便能在&lt;code&gt;~/tools/openssl&lt;/code&gt;目录下看到如下文件：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;zero@zero:~$ ls -a -l -h tools/openssl/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;total 20K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;drwxrwxr-x 2 zero zero 4.0K Jul  4 03:39 .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;drwxrwxr-x 8 zero zero 4.0K Jul  4 03:36 ..&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-rw-rw-r-- 1 zero zero 1.3K Jul  4 03:39 server.crt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-rw-rw-r-- 1 zero zero 1.1K Jul  4 03:39 server.csr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-rw------- 1 zero zero 1.7K Jul  4 03:42 server.key&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另：如果有需要PEM格式证书，可通过以下方式生成：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;openssl x509 -in server.crt  -outform PEM -out server.pem&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="xn--4gq28lcrm21g.cc/dist/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CA证书" scheme="xn--4gq28lcrm21g.cc/dist/tags/CA%E8%AF%81%E4%B9%A6/"/>
    
      <category term="OPENSSL" scheme="xn--4gq28lcrm21g.cc/dist/tags/OPENSSL/"/>
    
  </entry>
  
  <entry>
    <title>网络模型之OSI七层和TCP/IP四层</title>
    <link href="xn--4gq28lcrm21g.cc/article/2020/03/01/2020-03-01-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B9%8BOSI%E4%B8%83%E5%B1%82%E5%92%8CTCP-IP%E5%9B%9B%E5%B1%82/"/>
    <id>xn--4gq28lcrm21g.cc/article/2020/03/01/2020-03-01-网络模型之OSI七层和TCP-IP四层/</id>
    <published>2020-03-01T15:30:16.000Z</published>
    <updated>2020-07-04T06:08:38.111Z</updated>
    
    <content type="html"><![CDATA[<p>开放系统互连体系(OSI, Open System Interconnection)标准参考模型，也叫七层模型，是国际标准化组织(ISO, International Organization for Standardization)制定的一个用于计算机或通信系统间互联的标准体系，它是一个七层的、抽象的模型体，分别为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层，七层模型不仅包括一系列抽象的术语或概念，也包括具体的协议。<br>TCP/IP四层协议是一组用于实现网络互连的通信协议，Internet网络体系结构以TCP/IP为核心，参考OSI七层模型将协议分为4个层次，分别为应用层、传输层、网络层、数据链路层。</p><a id="more"></a><p>七层模型和TPC/IP四层协议映射</p><table><br>    <tr><br>        <td style="text-align:center;font-weight:bolder">OSI七层模型</td><br>        <td style="text-align:center;font-weight:bolder">TCP/IP四层协议</td><br>        <td style="text-align:center;font-weight:bolder">对应网络协议</td><br>        <td style="text-align:center;font-weight:bolder">功能</td><br>    </tr><br>    <tr><br>        <td>应用层(Application)</td><br>        <td rowspan="3">应用层</td><br>        <td>HTTP,TFTP,FTP,NFS,WAIS,SMTP</td><br>        <td>文件传输，电子邮件，虚拟终端</td><br>    </tr><br>    <tr><br>        <td>表示层(Presentation)</td><br>        <td>Telnet,Rlogin,SNMP,Gopher</td><br>        <td>数据格式化，数据加密</td><br>    </tr><br>    <tr><br>        <td>会话层(Session)</td><br>        <td>SMTP,DNS</td><br>        <td>建立或解除与其他节点的连接</td><br>    </tr><br>    <tr><br>        <td>传输层(Transport)</td><br>        <td>传输层</td><br>        <td>TCP,UDP</td><br>        <td>提供端对端的接口</td><br>    </tr><br>    <tr><br>        <td>网络层(Network)</td><br>        <td>网络层</td><br>        <td>IP,ICMP,ARP,RARP,AKP,UUCP</td><br>        <td>为数据包选择路由</td><br>    </tr><br>    <tr><br>        <td>数据链路层(Data Link)</td><br>        <td rowspan="2">数据链路层</td><br>        <td>FDDI,Ethernet,Arpanet,PDN,SLIP,PPP</td><br>        <td>传输有地址的帧及勘错</td><br>    </tr><br>    <tr><br>        <td>物理层(Physical)</td><br>        <td>IEEE 802.1A,IEEE 802.2~IEEE 802.11</td><br>        <td>物理媒介传输二进制数据</td><br>    </tr><br></table><p><img src="/images/coding/osi7.gif" alt="七层模型"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开放系统互连体系(OSI, Open System Interconnection)标准参考模型，也叫七层模型，是国际标准化组织(ISO, International Organization for Standardization)制定的一个用于计算机或通信系统间互联的标准体系，它是一个七层的、抽象的模型体，分别为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层，七层模型不仅包括一系列抽象的术语或概念，也包括具体的协议。&lt;br&gt;TCP/IP四层协议是一组用于实现网络互连的通信协议，Internet网络体系结构以TCP/IP为核心，参考OSI七层模型将协议分为4个层次，分别为应用层、传输层、网络层、数据链路层。&lt;/p&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="xn--4gq28lcrm21g.cc/dist/categories/TCP-IP/"/>
    
    
      <category term="网络分层" scheme="xn--4gq28lcrm21g.cc/dist/tags/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>《卧虎藏龙》-影评</title>
    <link href="xn--4gq28lcrm21g.cc/article/2018/12/05/2018-12-05-%E3%80%8A%E5%8D%A7%E8%99%8E%E8%97%8F%E9%BE%99%E3%80%8B-%E5%BD%B1%E8%AF%84/"/>
    <id>xn--4gq28lcrm21g.cc/article/2018/12/05/2018-12-05-《卧虎藏龙》-影评/</id>
    <published>2018-12-05T12:25:28.000Z</published>
    <updated>2020-06-06T17:47:36.799Z</updated>
    
    <content type="html"><![CDATA[<p>江湖里卧虎藏龙，人心里何尝不是。刀剑里藏凶，人情里何尝不是。</p><a id="more"></a><p>江南水乡，一湖波澜，山如眉黛。武当剑侠李慕白素袍裹身，闲庭信步的走向雄远镖局，他此行是去拜访相识多年的红颜知己俞秀莲。秀莲是个外强内柔的女子，接下父亲的衣钵后，主持镖局的大小事务，李慕白则是江湖中收人尊敬的武林高手，一把青冥剑，半生江湖怨。已到中年的李慕白一心想要追求内心的平静，然而闭关修炼之后仍然无法放下心里的一些事。第一件事就是他打算退隐江湖，回归本真。听闻秀莲正要押镖进京，慕白便托她把青冥剑赠予贝勒爷。青冥剑乃先秦宝物，神兵利刃，削铁如泥，是慕白的贴身配剑。与青冥剑斩断关系，也是表明他退隐江湖的决心。第二件事就是师傅多年前遭碧眼狐狸暗算，师仇一直未报，慕白决定先去给师傅扫墓，稍后再前往北京与秀莲会合。<br>走镖入京交完货后，秀莲直接去了贝勒爷府。贝勒爷性情豪放，喜欢结交江湖朋友，与秀莲的福清乃是故友，与慕白也是忘年之交。得知秀莲的来意后他只是答应暂时保管青冥剑。谈到秀莲和慕白的感情，贝勒爷忍不住感慨“两人相识多年，互相爱慕，但他们行事太过小心翼翼，这么多年过去了，他们一直不敢向对方承认这份感情”。贝勒爷说：“这次慕白交出了青冥剑，又决定退出江湖，或许他是在向你暗示些什么。”秀莲双手交错，似乎有意避开这个话题。<br>秀莲被贝勒爷留下来小住几日，接着在书房偶遇了玉家大小姐玉娇龙。她是九门提督的女儿，端庄秀丽惹人怜爱。秀莲一时兴起，向玉大小姐展示了青冥剑，宝剑出鞘的一刹那，如蛟龙跃海，似猛虎下山，缭绕之音犹如龙鸣虎啸。娇龙的眼睛直勾勾地盯着宝剑，像是见到了勾魂摄魄之物。当晚入夜以后，一袭黑影略过房檐，贝勒爷府家丁老刘觉察到异常，与蒙面人打了照面后一路追到了九门提督府。被惊醒的秀莲抄近路截住了黑衣人，交手时发现那人用的竟然是武当派的招式，而且身法和武艺都不弱，秀莲一心想要搞清楚对方的身份，然而黑衣人却无心恋战。一番缠斗之后，秀莲渐渐占据上风，正打算揭开对方的面纱时，城楼上却突然飞来一支暗箭，黑衣人趁机逃得无影无踪。第二天一早，秀莲就去拜访玉娇龙，从她握笔转腕的力度来看，娇龙很可能是懂剑法的，这就应证了她的猜测。接着两人谈起闺房私话，娇龙说她就要成婚了，但她不喜欢父母安排的婚事，她喜欢武侠小说里的英雄儿女，就像俞秀莲和李慕白这样的，她想要自由自在的生活，选择心爱的人，用自己的方式去爱他。秀莲笑了笑，讲起了自己的往事。她小时候家里给订过亲，那个人就是李慕白的结义兄弟孟思昭，在一次意外中，孟思昭为救李慕白牺牲，后来两人虽情愫暗生，但他们都不敢表露心声，道德的约束让他们不敢跨过孟思昭的那一纸婚约。娇龙却是直来直去的说，这事儿你和李慕白都没错啊，爱就爱了呗，怪就怪你那个孟大侠没福气。<br>当晚入夜以后玉府迎来了新的“客人”，陕北捕头蔡九因为妻子被碧眼狐狸杀害，所以和女儿一起一路追踪碧眼狐狸到了玉府，并在玉府外墙贴了碧眼狐狸的缉捕告示，目的就是把她逼出来。终于碧眼狐狸忍不住了，主动邀父女两人黄土岗一决生死。此时慕白也赶到京城，从秀莲口中得知了宝剑失窃和碧眼狐狸的事，秀莲以为慕白要责怪她弄丢了宝剑，但慕白却说我来北京是因为，我以为我们已经讲好了。这里暗指他想要正视这段感情，和秀莲一起归隐山林。当晚黄土岗上，秋意肃杀，惊起一片寒鸦，原来这碧眼狐狸正是玉大小姐的师父，当年犯下不少事儿，就改头换面一直混在玉府中。愁人见面分外眼红，一番拼死搏斗后，几人并非碧眼狐狸的对手，接着慕白赶了过来，将碧眼狐狸打败后，正准备为师父报仇时，娇龙却蒙着面纱拿着青冥剑出现。慕白发现眼前的黑衣女子竟然会武当派的玄牝剑法。随后打斗中，蔡捕头被杀，碧眼狐狸和玉娇龙趁机逃走。<br>几日后娇龙母女应邀来到贝勒爷府作客，此时秀莲已经越来越怀疑娇龙，趁机试探了她的功夫，并暗示娇龙知错悔改才不会连累家人。随后慕白跟随贝勒爷会见了娇龙母女，听说娇龙即将出阁，慕白看了她一眼，眉眼清纯，别有几分娇俏，慕白只是说道，福气福气。当晚娇龙潜入贝勒府还剑，慕白早已等候多时，两人一路追逐，来到一座古庙，慕白说“你天分不错，但对武当心决领悟的路子不正，你需要良师的指导，帮你重理剑路”。娇龙却并不领情，招招凛冽，慕白以棍代剑，处处占先。慕白有意收娇龙为徒，传承武当派的“玄牝剑法”。四目相望时，眼神深处有他们极力掩饰的东西，娇龙大骂武当是酒馆娼窑，而后扬长而去。回到家后，娇龙又和师父闹翻，因为他的功夫早就超过了师父，当年碧眼狐狸盗得武当剑法后，她不识字只能按图谱练，而娇龙则按心决来练，最终悟出了剑法奥义，并隐瞒了实力。得知真相的碧眼狐狸怅然若失，只得落寞离开了玉府。月光下独自练剑的李慕白心事重重，秀莲远远的看着他，她欲言又止，但慕白却频繁提到，那个女孩儿。秀莲说，慕白，她不是我们这种江湖中人，她会安安分分的嫁人，但慕白却说，她不是那种人，她应该到武当山来做徒弟。<br>本以为交出青冥剑，他就可以退出江湖，但即使审身已退，此时的心却再也难以平复，而这时的娇龙也是心事重重，难以入眠，忽觉窗外有动静，原来是她的初恋情人小虎，不远万里从新疆到北京来找她。两人一见面，小虎悔不当初，娇龙却思绪万千。事情还得从一年前说起，娇龙一家人在回京图中，遭到马匪罗小虎的抢劫，被戏耍的娇龙和小虎展开追逐战，性子野不服输的娇龙和小虎在沙漠中你追我赶，正所谓不打不相识，年纪相仿，性格相近的两人，在打斗中渐渐产生了微妙的情感，小虎不远万里挑来水让她洗澡，为她挑脚底上的刺儿，当晚两人偷尝禁果，升华了他们的感情。娇龙在这里感受到了自由自在，无拘无束，可寻找娇龙的官兵越来越多，小虎劝娇龙跟父亲回家，他说自己会干一番事业，让娇龙的父母看得起。小虎指着远处的雪山对娇龙说，这里有一个传说，谁敢从那个山上跳下来，天神就会满足他一个愿望，真心的愿望就一定会实现，心诚则灵。第二天娇龙离开了那片草原，小胡说，我每前进一步，就会有阻碍，我真的尽了力。少年为爱情斗志昂扬，转眼却被现实浇了个透心凉。娇龙知道眼前的他终究只是一个马匪，他不是英雄，给不了她一个江湖梦，更无法征服她的内心。出嫁那天，大红嫁衣，龙凤盖头，小虎大闹了迎亲队伍，大喊道，小龙，你是我的。接着他被官兵追捕，慕白和秀莲匆忙将他带离现场，随后慕白让小虎去武当山避难并等他消息。<br>当晚娇龙逃离洞房，然后潜入贝勒爷府盗走青冥剑，此时的她已经没有了依靠，师父的离去，恋人的幼稚，父母的不理解，她开始仗剑走天涯，天地任潇洒。初生牛犊，追逐着心中的江湖，怀揣梦想，挥洒着满腔的热血，她高调行事，拿着青冥剑恃才傲物，行事待人骄横无礼，自以为能力无限大，可以天下任我行，江湖任我闯。她以为世界触手可及，看不起江湖三教九流，歇个脚的功夫都要给人一个下马威，而慕白和秀莲却一路寻找娇龙的下落，希望可以通过她找到碧眼狐狸。竹林小舍休息时，慕白握着秀莲有些粗糙的手说“我们能触摸的东西没有永远，把手握紧，里面什么也没有，把手松开，你拥有的是一切。秀莲，江湖里卧虎藏龙，人心里何尝不是，刀剑里藏凶，人情里何尝不是。我交出青冥剑，却惹来更多烦恼”，秀莲意味深长的说，“压抑只会让感情更强烈，我也阻止不了我的欲望。我想跟你在一起，就像这样坐着，我反而能感觉到一种平静。”说这话的时候，慕白没有看着秀莲，而是看向远方。<br>娇龙的高调行事引来了不少江湖人士的注意，聚星楼的一场武斗，让娇龙一战成名，只不过这名声是恶名，这江湖不是你武功高就可以随便乱闯。手上挂彩的各路豪杰不服气，找来李慕白主持稿公道。几日之后，闯了祸的娇龙主动来到了雄远镖局，她伏在秀莲怀里，梨花带雨，可怜楚楚，秀莲一边为她擦眼泪，一边劝她先回北京。提及罗小虎，秀莲说他被慕白安排在武当山了，娇龙觉得这是他们给自己下的套，想让自己拜李慕白为师。羞怒之下与秀莲闹翻，两人准备决一高下。招式只是发泄，两人各有不满，内心深处都有他们怒气的原因。秀莲十八般武器轮番上阵，却都被青冥剑斩断，娇龙虽有青冥剑在手，但武艺修为还不足以驾驭宝剑，数个回合下来，秀莲仍然占据上风，最后秀莲的断刃架在了娇龙的脖子上，娇龙却气急败坏的陈秀莲不备砍伤了她。慕白及时赶到，娇龙转身逃走，两个身影如同笔尖掠过湖面，他们穿梭在青翠的竹林之巅，轻如飞羽。慕白说当日留一步给你，是要见你的本心。娇龙倔强的回到，你们这些老江湖，怎么见得到本心。这是一场剑法的对决，也是一场情欲的博弈。从第一次见面他就被扰乱，别人或许无从知晓，她却能够真切感受。她生性狂野，奔放不羁，他内敛沉稳，含蓄克制，痴缠到溪水中的石块之上，娇龙问为什么一定要缠着我，慕白执意要当她的师父传授她心决，可娇龙心里知道，这些不过是说给外人听的体面话，眼前的男人内心深处有他自己都不敢面对的东西。一把剑横在他们之间，两人心里都是翻江倒海，她的倔强终于被他的沉稳压倒，或许她也渴望能有人征服她的内心。但她又不甘心就这样被征服，思虑片刻，她终于妥协了，她说三招之内你能拿回青冥剑，我就跟你走。他笑了笑，一招就夺回了剑，她猛的一愣随即反悔。慕白将剑扔进绝壁深渊，然而娇龙却毫不犹豫的跟着跳了下去，等慕白赶到时，娇龙已被碧眼狐狸救起。碧眼狐狸将娇龙藏在一个土窑里，点燃迷香后匆匆离去。接着她冒着大雨在雄远镖局周围徘徊，引起了秀莲的警觉，随后慕白也被引入洞中，而此时的娇龙已是意乱情迷。她浑身湿透，扯开衣襟问慕白，你要剑还是要我。慕白满头大汗，努力调着自己的呼吸，接着娇龙瘫软在他怀里，他故作镇定的看了她一眼，很快发现娇龙是中了迷香，他踢翻香炉，给娇龙闻了解药，然后运气为她疗伤。片刻之后秀莲赶了过来，听慕白说娇龙中了迷香，秀莲瞥视左右，顿觉不妙，她也是被碧眼狐狸引过来的。众人刚反应过来，暗处就出现了无数根九转紫阴针，电光火石之间，毒针就如风驰电掣一般倾斜而来，碧眼狐狸带着毒针腾空跃起冲杀而来，暗箭对准的却是娇龙。慕白急忙挺身护住她，青冥剑瞬间将碧眼狐狸的兵器绞碎，慕白一跃而起补上最后一剑。但不幸的是慕白的脖颈处也中了一针。碧眼狐狸临死之前控诉徒弟不肖，隐瞒心决，害她苦练不成，而娇龙却剑艺精进，什么是毒，一个十八岁的孩子就有这种心机，这就是毒，说完便咽了气。此时娇龙内心受到极大触动，仿佛一瞬间她就明白了一切，她知道解药的配方，决定马上赶回镖局为慕白配解药，但慕白最多只能撑一个时辰，到了最后慕白已经支撑不住，仅有一息尚存。秀莲知道已经无力回天，她劝慕白提升最后一口气，解脱得到，达到他这一生所追求的境地。慕白说，我已经浪费了这一生，我要用最后一口气对你说，我一直深爱着你，说完他便倒了下去，秀莲抱住他印上一个吻。这是他们之间的第一个吻，也是最后一个吻。等娇龙匆匆赶来为时已晚，只能跪在地上不知所措。秀莲扶起她，并让他去武当山找小虎，并说道，答应我，不论你对此生的决定为何，已经要真诚的对待自己。<br>武当山上云雾缭绕，娇龙背上行囊拾级而上，见到了小虎，然而她却出奇的平静，拥吻之时她心不在焉，动情之处她却眼角含泪，一夜缠绵后小虎发现娇龙不见了，接着他看到她正站在石桥之上，痴痴的遥望眼前的幻境。她问小虎，还记得你说的那个故事吗。小虎说，心诚则灵，娇龙说道，小虎许个愿吧，小虎闭上眼睛，一起回新疆。娇龙纵身一跃，跳入茫茫云海，江湖梦已经破碎，该偿还的情已经偿还，你看那山崖之间的云朵，自由自在，人那，要是能那样该多好。<br>《卧虎藏龙》是李安导演2000年上映的作品，电影获得第73届奥斯卡最佳外语片，最佳摄影，最佳艺术指导以及最佳原创配乐四项大奖，这也是华语电影第一次在奥斯卡上获此殊荣，也是美国电影史上第一部超过1亿美元偏方的外语片，它将中国人的武侠世界美轮美奂的呈现给西方观众，不可否认的是，电影暗合了西方观众的审美需求，但其中的情，其中的理则完完全全是东方文化所特有的思想。接下来我将用较长的篇幅来详细解析这部电影里的“江湖”。<br>私认为，这是一部披着武侠外壳的中国人情感伦理片，表面上是在讲武侠世界，讲江湖恩怨，实则是在讲人性，讲情欲伦理。正所谓江湖里藏的是龙和虎，人心里藏的是情和欲。李慕白是个有着较高社会地位的成功人士，他信奉道家思想，同时也深受儒家思想的影响，道家偏好自然与自觉，儒家崇尚理性和修身，这就使得李慕白陷入矛盾之中，他在闭关时感觉周围只有光，他想要冲破世俗却发现陷入其中，甚至充满了悲哀。为什么？因为如果直面内心的话，势必要承受道德层面的压力，作为一个成功人士，要想放下打拼伴生得来的社会地位，去寻求内心的平静，这是非常非常难得一件事。不过好在李慕白终于下了这个决心，交出了青冥剑退隐江湖。然后直面内心的情感打算和俞秀莲共度余生。但俞秀莲也正面临这这样的抉择，在直面感情和到的谴责中挣扎。她对娇龙说，我虽然不是出生高贵，但一个女人一生应该服从的道德和礼教并不会少于你们，三纲五常要求她从一而终，她和李慕白之间横着的不是死去的孟思昭，而是道德和礼教。如果说这是两人的纠缠，事情可能还有解决的希望，但李安不满足于此，玉娇龙的出现彻底打乱了这个局面。从第一次见面，李慕白已经对玉娇龙产生了情愫或者是情欲，听说娇龙即将出嫁，他喃喃的说，福气福气，可能他说的是即将要娶娇龙的那个人好福气。紧接着慕白就决意冲出江湖，一方面是为了报师仇，但更多的是为了那个女孩，这种没来由的情欲最为要命。李慕白必须要说服自己这只是一种惜才之情。此刻，他和秀莲之间又多了一道更大的鸿沟，很明显，秀莲也能感受到那种难以言说的东西，她是懂情的，她也是懂慕白的。她说我也想过平静的日子，我不知道该怎么帮你。慕白说本以为交出青冥剑就可以退出江湖，没想到又引来了新仇旧恨。可哪有什么江湖，江湖从在都只在人心里，又有什么新仇旧恨，只不过是新情旧爱。情不知所起，一往而深，谁又能控制得了呢。贝勒爷说，面对情字，再大的英雄也是莫可奈何，慕白执意要收娇龙为徒，只不过是求一个形式上的圆满，既可以把她留在身边，又能约束自己对她的情欲。他终究无法得道，因为他绝不可能直面对娇龙的感情，他藏的很深，但却瞒不过对娇龙的眼睛。从一开始她就知道，所以她说武当是酒馆娼窑，因为她看得见慕白的情欲。竹林小舍中，慕白说我们能触摸的东西没有永远，或许他想说的是感情其实也一样。慕白说我阻止不了我的欲望，秀莲何尝不知话中的意思，只是淡淡说了一句，压抑只会让感情更强烈。看到这里会有观众可能觉得会不会过度解读，要知道李安是个很克制的导演，无论是描写男女情欲，还是悲欢离合，都是点到即止，会不会嚎啕控诉，更不会用大篇幅去刷悲伤脸。只需一个眼神，一句话，内里却是波涛汹涌的情感，此处没有表明孰好孰坏，只是每个导演风格不同而已。后来娇龙和秀莲武馆里的打斗，其实是一场感情冲突的戏。两个女人之间的爱恨情仇，秀莲是爱中夹杂着不甘和嫉妒，娇龙是不远感情被人操控和对慕白复杂的情感。竹林里慕白和娇龙的追逐则是一次心照不宣的征服与被征服（或者试探和被试探）。慕白说要见娇龙的本心，娇龙却说你们这些老江湖，如何见得本心。岩石之上，当娇龙面对强势的慕白，终于妥协，她说的是，如果你抢回青冥剑，我就跟你走，而不是我就拜你为师，跟你走是一个很暧昧带有挑逗性的词儿，此时的李慕白一抹邪魅的笑，此刻他们都已经心知肚明。所以才有山洞里娇龙问慕白，你是要我还是要剑，如果没有看懂前面的细节铺垫，你肯定会觉得很突兀。其实两人的情欲纠缠从一开始就存在，最终李慕白的情欲和伦理伴随着他的死亡被永远隐藏。道德和情欲，世俗礼仪和听从内心，到底该如何抉择，这是东方文化中最艰难的命题。临终之时，带着没有答案的问题，慕白回归了，秀莲留给娇龙一句话，无论怎样，都要真诚的对待自己，这是慕白和她心理一直想要做却始终无法做到的。而对于娇龙而言，独自闯荡江湖，想要的不过是创造自己的江湖梦，然而师父临死之前的那几句话，让娇龙瞬间明白了，原来江湖不在别处，江湖在人的心里，情欲爱恨，八岁时她已在江湖中，可依旧做着江湖梦。小虎抢亲的时候大喊，你是我的，但在娇龙心里，她就是她，她不是任何人的，可小虎怎么能懂，他心里的江湖跟她的不一样。最后一夜的缠绵也只是为了偿还情债，她以为自己自由自在，可终究，她也逃不过世俗的束缚。站在武当山顶，小虎的愿望是回新疆，可娇龙的愿望却还是无拘无束自由自在，但这个江湖却容不下这份自由。生命诚可贵，爱情价更高，若为自由故，两者皆可抛，这是西方人的信仰，却也是东方人的浪漫。人在江湖，身不由己，心在凡尘，情难自已。<br>最后总给依旧保持勇气听从内心的人们一句话“但愿你们依然能爱恨坦荡，真诚对待自己，切莫白白浪费了这一生。”。</p><p>—— 来自“越哥说电影”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;江湖里卧虎藏龙，人心里何尝不是。刀剑里藏凶，人情里何尝不是。&lt;/p&gt;
    
    </summary>
    
      <category term="影评" scheme="xn--4gq28lcrm21g.cc/dist/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
      <category term="影评" scheme="xn--4gq28lcrm21g.cc/dist/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Boot启动过程-配置信息</title>
    <link href="xn--4gq28lcrm21g.cc/article/2018/10/18/2018-10-18-Spring-Boot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/"/>
    <id>xn--4gq28lcrm21g.cc/article/2018/10/18/2018-10-18-Spring-Boot启动过程-配置信息/</id>
    <published>2018-10-17T16:34:58.000Z</published>
    <updated>2020-06-06T17:47:36.799Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="spring" scheme="xn--4gq28lcrm21g.cc/dist/categories/spring/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
      <category term="spring" scheme="xn--4gq28lcrm21g.cc/dist/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Boot启动过程-Bean初始化</title>
    <link href="xn--4gq28lcrm21g.cc/article/2018/10/17/2018-10-17-Spring-Boot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-Bean%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>xn--4gq28lcrm21g.cc/article/2018/10/17/2018-10-17-Spring-Boot启动过程-Bean初始化/</id>
    <published>2018-10-17T15:51:09.000Z</published>
    <updated>2020-06-06T17:47:36.799Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="spring" scheme="xn--4gq28lcrm21g.cc/dist/categories/spring/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
      <category term="spring" scheme="xn--4gq28lcrm21g.cc/dist/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Boot启动过程-事件</title>
    <link href="xn--4gq28lcrm21g.cc/article/2018/10/17/2018-10-17-Spring-Boot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-%E4%BA%8B%E4%BB%B6/"/>
    <id>xn--4gq28lcrm21g.cc/article/2018/10/17/2018-10-17-Spring-Boot启动过程-事件/</id>
    <published>2018-10-17T14:54:37.000Z</published>
    <updated>2020-06-06T17:47:36.799Z</updated>
    
    <content type="html"><![CDATA[<p>Spring中的监听器<code>listeners</code>是负责在应用启动过程中对各个阶段，对容器的启动过程监听并处理各阶段的动作，它的生命周期也只存在于应用开启启动到启动完成。监听器接收的信号即“事件(event)”在spring项目启动过程中主要分为四个阶段——开始启动、环境参数加载完成、准备完毕、启动成功|失败。</p><p>spring的启动过程是通过一系列的事件(event)在spring context启动的各个阶段通知并告知各组件，Spring事件继承<code>org.springframework.context.ApplicationEvent</code>，在springframework中事件类型主要包含如下:</p><ul><li><code>ApplicationContextEvent</code> (abstract)  以下四种容器生命节点事件的父类</li><li><code>ContextStartEvent</code>        容器开始启动时触发</li><li><code>ContextRefreshEvent</code>      容器刷新时触发</li><li><code>ContextStopEvent</code>         容器开启停止时触发</li><li><code>ContextClosedEvent</code>       容器关闭后触发</li><li><code>PayloadApplicationEvent&lt;T&gt;</code>  广泛的（通过泛型定义）可处理的事件，需要提供事件的处理（即T）</li><li><code>RequestHandledEvent</code>         在web环境中接收到请求事件</li><li><code>ServletRequestHandledEvent</code> 在web环境中接收到请求事件，包含servlet信息，是<code>RequestHandledEvent</code>事件的拓展</li></ul><p>在SpringBoot中，容器启动过程使用另一套事件，即继承<code>org.springframework.boot.context.event.SpringApplicationEvent</code>：</p><ul><li><code>ApplicationStartingEvent</code>  应用开始启动时触发（等于 <code>ApplicationStartedEvent</code>）</li><li><code>ApplicationEvironmentPreparedEvent</code>  应用环境（参数加载）准备完成时触发</li><li><code>ApplicationPreparedEvent</code>  应用准备完成时触发，准备完成包含。。。</li><li><code>ApplicationFailedEvent</code>  应用启动失败的情况下触发</li><li><code>ApplicationReadyEvent</code> 应用启动成功后触发</li></ul><p>除此之外还有其他事件：</p><ul><li><code>AuditApplicationEvent</code> ？</li><li><code>DataSourceInitializedEvent</code>  数据库连接建立完成时触发</li><li><code>EmbeddedServletContainerInitializedEvent</code>  在web环境下，内嵌的servlet容器初始化完成后触发</li><li><code>ExitCodeEvent</code> 应用收到关闭信号时触发，一般只在应用启动过程中收到此事件。</li><li><code>JobExecutionEvent</code> 有定时任务执行时触发</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring中的监听器&lt;code&gt;listeners&lt;/code&gt;是负责在应用启动过程中对各个阶段，对容器的启动过程监听并处理各阶段的动作，它的生命周期也只存在于应用开启启动到启动完成。监听器接收的信号即“事件(event)”在spring项目启动过程中主要分为四个阶段——
      
    
    </summary>
    
      <category term="spring" scheme="xn--4gq28lcrm21g.cc/dist/categories/spring/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
      <category term="spring" scheme="xn--4gq28lcrm21g.cc/dist/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat系统架构</title>
    <link href="xn--4gq28lcrm21g.cc/article/2018/03/03/2018-03-03-Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <id>xn--4gq28lcrm21g.cc/article/2018/03/03/2018-03-03-Tomcat系统架构/</id>
    <published>2018-03-03T14:16:10.000Z</published>
    <updated>2020-06-06T17:47:36.799Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/categories/java/"/>
    
    
      <category term="tomcat" scheme="xn--4gq28lcrm21g.cc/dist/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Java引用类型</title>
    <link href="xn--4gq28lcrm21g.cc/article/2018/01/26/2018-01-26-Java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>xn--4gq28lcrm21g.cc/article/2018/01/26/2018-01-26-Java引用类型/</id>
    <published>2018-01-25T17:08:03.000Z</published>
    <updated>2020-06-06T17:47:36.795Z</updated>
    
    <content type="html"><![CDATA[<p>在jdk1.2之后，位于<code>java.lang.ref</code>包下有<code>Reference</code>的实现<code>SoftReference</code>(软引用),<code>WeakReference</code>(弱引用),<code>PhantomReference</code>(虚引用),<code>FinalReference</code>(即强引用StrongReference),在jdk1.2之前所有的引用皆为强引用。<code>Reference</code>作为一个<code>abstract</code>修饰的类，是所有引用类型的基类，此类定义了常用于所有引用对象的操作。因为引用对象(*Reference)是通过与垃圾回收器的密切合作来实现的，所以不能由程序员直接为此类(<code>Reference</code>)创建子类。Reference类型的使用主要是为了增强jvm内存管理功能，通过使用不同的引用类型，程序员可以在一定程度上与GC交互，通过定义不同对象的引用类型改善GC的效率。被强引用类型引用的对象即使在OOM的情况下也不会被GC掉，软引用的对象在内存吃紧的情况下触发的GC过程中会被清除，弱引用的对象只要触动了GC就会被清除，虚引用的对象引用并不影响对象的生命时间，虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p><a id="more"></a><h1 id="Reference预读"><a href="#Reference预读" class="headerlink" title="Reference预读"></a>Reference预读</h1><p>需要了解引用怎么作用的，需先了解它的两个关键类，<code>Reference</code>和<code>ReferenceQueue</code>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>作为所有引用类型的基类，Reference定义了所有引用对象的常用操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;           <span class="comment">// 清除此引用对象。调用此方法不会导致对象被加入队列。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">()</span></span>;      <span class="comment">// 将此引用对象添加到引用对象已向其注册的队列（如果有）。如果成功将此引用对象加入队列中，则返回 true；如果它已经加入队列或者在创建时没有在队列中注册它，则返回 false。</span></span><br><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span></span>;                <span class="comment">// 返回此引用对象的指示对象。如果此引用对象已经由程序或垃圾回收器清除，则此方法将返回 null。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEnqueue</span><span class="params">()</span></span>;    <span class="comment">// 由程序或垃圾回收器通知是否已将此引用对象加入队列。当且仅当此引用对象已经加入队列时返回 true。</span></span><br></pre></td></tr></table></figure></p><p>每个引用都有以下属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T referent;         <span class="comment">/* Treated specially by GC */</span>       <span class="comment">// 定义引用的对象</span></span><br><span class="line"><span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;                       <span class="comment">// 引用队列</span></span><br><span class="line">Reference next;                                                 <span class="comment">// 作为引用队列的下一个元素指针</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* used by VM */</span></span><br></pre></td></tr></table></figure></p><h2 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h2><p>引用对象队列，是用来保存注册为引用对象的队列。在检测到引用对象的可到达性被变更后，垃圾回收器会将已注册的引用对象添加到该队列中。引用队列是一个线程安全的单向队列类型，通过<code>volatile</code>声明的Reference类型的<code>head</code>指针作为队列的入口，属性<code>queueLength</code>记录队列长度，对该队列的所有操作都会通过<code>synchronized</code>关键字锁住队列本身，即每个引用队列都具备一个锁维护出入队的线程安全：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123; &#125;;</span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> Lock();</span><br></pre></td></tr></table></figure></p><p>ReferenceQueue的所有入队方法为<code>friendly</code>修饰的，即所有引用队列元素的入队操作都是由该队列所在的引用对象完成的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferenceQueue的入队(Called only by Reference class)</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;? extends T&gt; r)</span> </span>&#123; <span class="comment">/* Called only by Reference class */</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// Check that since getting the lock this reference hasn't already been</span></span><br><span class="line">        <span class="comment">// enqueued (and even then removed)</span></span><br><span class="line">        ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">        <span class="keyword">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> queue == <span class="keyword">this</span>;</span><br><span class="line">        r.queue = ENQUEUED;</span><br><span class="line">        r.next = (head == <span class="keyword">null</span>) ? r : head;</span><br><span class="line">        head = r;</span><br><span class="line">        queueLength++;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 仅在 Reference中被调用(Reference.enqueue())</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.enqueue(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了被引用掌控的入队操作，ReferenceQueue还具有以下操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Reference&lt;? extends T&gt; poll();               <span class="comment">// 轮询此队列，查看是否存在可用的引用对象。如果存在一个立即可用的对象，则从该队列中移除此对象并返回。否则此方法立即返回 null。</span></span><br><span class="line"><span class="keyword">public</span> Reference&lt;? extends T&gt; remove(<span class="keyword">long</span> timeout); <span class="comment">// 移除此队列中的下一个引用对象，阻塞到有一个对象变得可用或者给定的超时期(ms)满了为止。如果超时值为零，则无限期地阻塞。</span></span><br><span class="line"><span class="keyword">public</span> Reference&lt;? extends T&gt; remove()              <span class="comment">// 移除此队列中的下一个引用对象，阻塞到某个对象变得可用为止。即超时值被设为0。</span></span><br></pre></td></tr></table></figure></p><h1 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h1><h2 id="SoftReference-软引用"><a href="#SoftReference-软引用" class="headerlink" title="SoftReference 软引用"></a>SoftReference 软引用</h2><p>软引用对象，在响应内存需要时，由垃圾回收器决定是否清除此对象。<strong>软引用对象最常用于实现内存敏感的缓存</strong>。假定垃圾回收器确定在某一时间点某个对象是软可到达对象，这时，它可以选择自动清除针对该对象的所有软引用，以及通过强引用链，从其可以到达该对象的针对任何其他软可到达对象的所有软引用。在同一时间或晚些时候，它会将那些已经向引用队列注册的新清除的软引用加入队列。软可到达对象的所有软引用都要保证在虚拟机抛出 OutOfMemoryError 之前已经被清除。否则，清除软引用的时间或者清除不同对象的一组此类引用的顺序将不受任何约束。然而，虚拟机倾向于反对清除最近访问或使用过的软引用。<br>此类的直接实例可用于实现简单缓存；该类或其派生的子类还可用于更大型的数据结构，以实现更复杂的缓存。只要软引用的指示对象是强可到达对象，即正在实际使用的对象，就不会清除软引用。例如，通过保持最近使用的项的强指示对象，并由垃圾回收器决定是否放弃剩余的项，复杂的缓存可以防止放弃最近使用的项。 </p><h2 id="WeakReference-弱引用"><a href="#WeakReference-弱引用" class="headerlink" title="WeakReference 弱引用"></a>WeakReference 弱引用</h2><p>弱引用对象，在弱引用对象没有任何强引用的情况下，触发GC时弱引用对象就会被清除。对应使用到弱引用的数据结构有<code>WeakHashMap</code>，该Map的元素类即继承自<code>WeakReference</code>，通常该类型Map也被用来作为缓存。</p><h2 id="PhantomReference-虚引用"><a href="#PhantomReference-虚引用" class="headerlink" title="PhantomReference 虚引用"></a>PhantomReference 虚引用</h2><p>虚引用对象，在垃圾回收器决定它引用的对象可能要被回收时就会将其添加到队列(构造方法中的那个ReferenceQueue)中，虚引用经常被用于比Java的finalization机制更灵活的方式来调度预验(pre-mortem)清除操作。为了确保可回收的对象仍然保持原状，虚引用的指示对象不能被获取，即虚引用的<code>get</code>方法总是返回<code>null</code>（阻止其指向的几乎被销毁的对象重新复活）。通过虚引用可到达的对象将仍然保持原状，直到所有这类引用都被清除，或者它们都变得不可到达。虚引用和前面的软引用、弱引用不同，虚引用在加入队列时并没有通过垃圾回收器自动清除，它并不影响对象的生命周期。<strong>虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动（即前文提及的预验(pre-mortem)清除操作）。</strong></p><h2 id="FinalReference-StrongReference-强引用"><a href="#FinalReference-StrongReference-强引用" class="headerlink" title="FinalReference(StrongReference)强引用"></a>FinalReference(StrongReference)强引用</h2><p>强引用其实就是默认的引用类型，是指创建一个对象并把这个对象赋给一个引用变量，譬如<code>String a = new String(&quot;a is a strong reference.&quot;);</code>，则<code>a</code>这个引用即是强引用，虚拟机将这类引用就通过<code>FinalReference</code>包装处理。<strong>强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象</strong>。如果需要强制释放强引用引用的对象，可以将强引用引用到<code>null</code>，那该对象在没有被引用的情况下就能响应GC操作，被清理掉了。</p><h3 id="Finalizer"><a href="#Finalizer" class="headerlink" title="Finalizer"></a>Finalizer</h3><p>关于 Finalizer类的描述，祥见<a href="https://yq.aliyun.com/articles/2947?spm=0.0.0.0.At14xp" title="JVM源码分析之FinalReference完全解读-寒泉子" target="_blank" rel="noopener">JVM源码分析之FinalReference完全解读</a>。综合文章描述有以下几点：<br>1、Finalizer是FinalReference的继承，package(包)访问权限，final不可扩展类。<br>2、通过类中是否存在一个参数为空，返回void的非空<code>void finalize()</code>方法判断该类是否为一个 Finalizer类。<br>3、Finalizer类对象在构造函数返回之前调用<code>Finalizer.register</code>方法，可通过配置<code>-XX:-RegisterFinalizersAtInit</code>关闭，并将在对象空间分配好之后调用<code>Finalizer.register</code>，将强引用类型对象引用注册为<code>Finalizer</code>类型引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Finalizer</span><span class="params">(Object finalizee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(finalizee, queue);</span><br><span class="line">    add();  <span class="comment">// 即将 this添加到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Invoked by VM */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object finalizee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Finalizer(finalizee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当通过clone的方式复制一个对象时，如果当前类是一个f类，那么在clone完成时将调用<code>Finalizer.register</code>方法进行注册。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实 SoftReference, WeakReference 以及 PhantomReference 的构造函数都可以接收一个 ReferenceQueue 对象。当 SoftReference 以及 WeakReference 被清空的同时，也就是 Java 垃圾回收器准备对它们所指向的对象进行回收时，调用对象的<code>finalize()</code>方法之前，它们自身会被加入到这个 ReferenceQueue 对象中，此时可以通过 ReferenceQueue 的<code>poll()</code>方法取到它们。而 PhantomReference 只有当 Java 垃圾回收器对其所指向的对象真正进行回收时，会将其加入到这个 ReferenceQueue 对象中，这样就可以追综对象的销毁情况。</p><table><thead><tr><th style="text-align:center">引用类型</th><th style="text-align:center">取得目标对象的方式</th><th style="text-align:center">垃圾回收条件</th><th style="text-align:center">是否可能内存泄露</th></tr></thead><tbody><tr><td style="text-align:center">强引用</td><td style="text-align:center">直接引用</td><td style="text-align:center">不回收</td><td style="text-align:center">可能</td></tr><tr><td style="text-align:center">软引用</td><td style="text-align:center">通过get()取得</td><td style="text-align:center">视内存情况(OOM前)</td><td style="text-align:center">不可能</td></tr><tr><td style="text-align:center">弱引用</td><td style="text-align:center">通过get()取得</td><td style="text-align:center">有GC即回收</td><td style="text-align:center">不可能</td></tr><tr><td style="text-align:center">虚引用</td><td style="text-align:center">无法获取</td><td style="text-align:center">不回收</td><td style="text-align:center">可能</td></tr></tbody></table><p>感谢：</p><ul><li>JVM源码分析之FinalReference完全解读: <a href="https://yq.aliyun.com/articles/2947" title="JVM源码分析之FinalReference完全解读-寒泉子" target="_blank" rel="noopener">https://yq.aliyun.com/articles/2947</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在jdk1.2之后，位于&lt;code&gt;java.lang.ref&lt;/code&gt;包下有&lt;code&gt;Reference&lt;/code&gt;的实现&lt;code&gt;SoftReference&lt;/code&gt;(软引用),&lt;code&gt;WeakReference&lt;/code&gt;(弱引用),&lt;code&gt;PhantomReference&lt;/code&gt;(虚引用),&lt;code&gt;FinalReference&lt;/code&gt;(即强引用StrongReference),在jdk1.2之前所有的引用皆为强引用。&lt;code&gt;Reference&lt;/code&gt;作为一个&lt;code&gt;abstract&lt;/code&gt;修饰的类，是所有引用类型的基类，此类定义了常用于所有引用对象的操作。因为引用对象(*Reference)是通过与垃圾回收器的密切合作来实现的，所以不能由程序员直接为此类(&lt;code&gt;Reference&lt;/code&gt;)创建子类。Reference类型的使用主要是为了增强jvm内存管理功能，通过使用不同的引用类型，程序员可以在一定程度上与GC交互，通过定义不同对象的引用类型改善GC的效率。被强引用类型引用的对象即使在OOM的情况下也不会被GC掉，软引用的对象在内存吃紧的情况下触发的GC过程中会被清除，弱引用的对象只要触动了GC就会被清除，虚引用的对象引用并不影响对象的生命时间，虚引用主要用来跟踪对象被垃圾回收器回收的活动。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/categories/java/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
      <category term="jdk阅读计划" scheme="xn--4gq28lcrm21g.cc/dist/tags/jdk%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92/"/>
    
      <category term="Reference" scheme="xn--4gq28lcrm21g.cc/dist/tags/Reference/"/>
    
  </entry>
  
  <entry>
    <title>Redis实现分布式锁</title>
    <link href="xn--4gq28lcrm21g.cc/article/2018/01/23/2018-01-23-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>xn--4gq28lcrm21g.cc/article/2018/01/23/2018-01-23-Redis实现分布式锁/</id>
    <published>2018-01-23T13:28:55.000Z</published>
    <updated>2020-06-06T17:47:36.795Z</updated>
    
    <content type="html"><![CDATA[<p>分布式锁总是一个热点讨论的话题，在涉及到多个系统调用，或者多台服务并行提供服务的情况下，对竞争资源的保护一般都会采用乐观锁，或分布式锁的方式实现，对单条资源的竞争一般选择乐观锁/悲观锁，而对过程的竞争往往是通过分布式锁的方式加以保护。实现分布式锁的方案也有很多。在实现分布式锁的过程中，往往有很多人会忽略一个细节，即<strong>只有加锁的人才具备释放锁的权利</strong>。这也是在公司中看一个”前人”在2015年实现的一个分布式锁源码，发现具有这个漏洞，特重新实现，以做记录。</p><a id="more"></a><p>话不多说，先上实现，这是一个基于redis实现的具备阻塞功能的，通用的分布式锁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.zero.boot.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.zero.boot.web.init.context.ApplicationContextHolder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加锁工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年1月23日 下午4:01:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LockUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Redis操作api</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RedisTemplate&lt;?, ?&gt; redisTemplate = (RedisTemplate&lt;?, ?&gt;) ApplicationContextHolder.application.getBean(<span class="string">"redisTemplate"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_KEY_PREFIX = <span class="string">"lock:"</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_LOCKING_TIME = <span class="number">30_000L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_WAITING_FOR_LOCK_TIME = <span class="number">10_000L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取默认配置的阻塞锁</span></span><br><span class="line"><span class="comment">     * 阻塞容许时间 10s，取得锁时锁定时间 30s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lock(key, DEFAULT_WAITING_FOR_LOCK_TIME, DEFAULT_LOCKING_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取阻塞锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            上锁资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waittimeout    阻塞时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockingtime    锁定时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">long</span> waittimeout, <span class="keyword">long</span> lockingtime)</span> </span>&#123;</span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">final</span> String lockKey = LOCK_KEY_PREFIX + key;</span><br><span class="line">        <span class="keyword">long</span> timeoutpoing = System.currentTimeMillis() + waittimeout;</span><br><span class="line">        <span class="keyword">while</span>(timeoutpoing &gt; System.currentTimeMillis()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> setnx = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] skey = ((RedisSerializer&lt;String&gt;) redisTemplate.getKeySerializer()).serialize(lockKey);</span><br><span class="line">                    <span class="keyword">byte</span>[] svalue = ( (RedisSerializer&lt;String&gt;) redisTemplate.getValueSerializer()).serialize(uuid);</span><br><span class="line">                    <span class="keyword">return</span> connection.setNX(skey, svalue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(setnx) &#123;</span><br><span class="line">                <span class="comment">// 获取锁成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 随机阻塞时间，提升锁竞争公平性，同时防止饥饿线程等待</span></span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (<span class="number">100</span> + random.nextInt(<span class="number">300</span>)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  锁定的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String lockKey = LOCK_KEY_PREFIX + key;</span><br><span class="line">        <span class="keyword">if</span>(uuid == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] skey = ((RedisSerializer&lt;String&gt;) redisTemplate.getKeySerializer()).serialize(lockKey);</span><br><span class="line">                    String lockuuid = ((RedisSerializer&lt;String&gt;) redisTemplate.getValueSerializer()).deserialize(connection.get(skey));</span><br><span class="line">                    <span class="keyword">if</span>(lockuuid == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(uuid.equals(lockuuid)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> connection.del(skey) &gt; <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 及时清理 ThreadLocalMap</span></span><br><span class="line">            LOCK_OWNER_UUID.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完全释放锁，不需要权限认证（即非本线程获取的锁也能释放）[慎用，最好别用]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 锁定的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">superUnlock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String lockKey = LOCK_KEY_PREFIX + key;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] skey = ((RedisSerializer&lt;String&gt;) redisTemplate.getKeySerializer()).serialize(lockKey);</span><br><span class="line">                    <span class="keyword">return</span> connection.del(skey) &gt; <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式锁总是一个热点讨论的话题，在涉及到多个系统调用，或者多台服务并行提供服务的情况下，对竞争资源的保护一般都会采用乐观锁，或分布式锁的方式实现，对单条资源的竞争一般选择乐观锁/悲观锁，而对过程的竞争往往是通过分布式锁的方式加以保护。实现分布式锁的方案也有很多。在实现分布式锁的过程中，往往有很多人会忽略一个细节，即&lt;strong&gt;只有加锁的人才具备释放锁的权利&lt;/strong&gt;。这也是在公司中看一个”前人”在2015年实现的一个分布式锁源码，发现具有这个漏洞，特重新实现，以做记录。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/categories/java/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
      <category term="redis" scheme="xn--4gq28lcrm21g.cc/dist/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>对象创建模式Builder</title>
    <link href="xn--4gq28lcrm21g.cc/article/2017/12/26/2017-12-26-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8FBuilder/"/>
    <id>xn--4gq28lcrm21g.cc/article/2017/12/26/2017-12-26-对象创建模式Builder/</id>
    <published>2017-12-26T14:47:12.000Z</published>
    <updated>2020-06-06T17:47:36.791Z</updated>
    
    <content type="html"><![CDATA[<p>前两天听到有同事抱怨有人的代码中使用<code>and属性名(属性值)</code>的方式创建对象，很不方便，还是提供属性的<code>Getter</code>/<code>Setter</code>方法更好些，听到他这样抱怨的时候我还花了点时间给他讲了采用这种方式创建对象的好处——这种对象创建的方式是为了保护对象在创建之后就不允许被更改。同时也想到这么好的设计模式时很值得学习的，且做个记录。</p><a id="more"></a><h1 id="一般对象实例化"><a href="#一般对象实例化" class="headerlink" title="一般对象实例化"></a>一般对象实例化</h1><p>一般对象通过构造方法进行实例化，即通过<code>new Object()</code>的方式，在不声明构造方法的情况下，java默认会有无参的构造方法，也可以通过<code>public T(Object ...)</code>的方式创建具有构造参数的构造方法。</p><h1 id="私有构造方法的情况"><a href="#私有构造方法的情况" class="headerlink" title="私有构造方法的情况"></a>私有构造方法的情况</h1><p>一般情况下，枚举类型应采用私有构造方法的情况，毕竟枚举类型中的枚举值是应在枚举类创建好之后就应指定（不排除其他的需求），那么会将枚举类型的构造方法设为私有，以保证枚举列表不被破坏。</p><h1 id="Builder-对象创建模式"><a href="#Builder-对象创建模式" class="headerlink" title="Builder 对象创建模式"></a>Builder 对象创建模式</h1><p>什么情况下需要使用到 Builder的方式去构建对象。如果说只是为了去掉过多的<code>Setter</code>方法去为属性赋值，那完全可以公有其属性（即用public修饰），也就是说，<strong>Builder方式创建的对象一般是需要对属性保护的对象，一旦对象被创建，其内容将不可变</strong>，为了达到该目的，很容易让人想到被保护的属性需私有化，而能够访问其私有属性的<code>Setter</code>方法的只有通过内部类的方式实现，譬如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Builder模式创建对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年12月26日 上午1:04:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 名字(被保护的属性,无Setter方法) */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/** 性别(被保护的属性,无Setter方法) */</span></span><br><span class="line">    <span class="keyword">private</span> String gendar;</span><br><span class="line">    <span class="comment">/** 年龄(可变的属性) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 私有化其构造方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGendar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gendar;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 创建构造器 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Builder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 静态内部类-Builder */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Person person = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/** 创建Builder的时候创建 Person实例 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            person = <span class="keyword">new</span> Person();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 赋予属性-名字 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            person.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 赋予属性-性别 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">gendar</span><span class="params">(String gendar)</span> </span>&#123;</span><br><span class="line">            person.gendar = gendar;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 赋予属性-年龄(冗余，提供方便) */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            person.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 返回实例化的Person对象 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Person target = person;</span><br><span class="line">            person = <span class="keyword">null</span>;    <span class="comment">// 防止第二次 build，即build一次之后，这个Builder对象就失效了</span></span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Person中<code>name</code>和<code>gendar</code>是受保护的属性，即在Person对象实例化之后，这两个属性值不应该被改变，而<code>age</code>是可变的，提供公有的<code>Setter</code>改变其值。Builder模式可以通过一个静态内部类作为工厂的方式访问私有属性，组装私有属性值之后通过<code>build()</code>方法产出对象，并销毁当前”胚胎”，可以类比为鸡蛋里孵出小鸡，一颗鸡蛋只能孵出一只小鸡。</p><p><strong> 注意 </strong></p><ul><li>既然是受保护的对象，一般私有化其构造方法</li><li>受保护的对象也可以有可变的属性</li><li>Builder中容许冗余填充可变的属性方法</li><li><code>build()</code>只能产出一次</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天听到有同事抱怨有人的代码中使用&lt;code&gt;and属性名(属性值)&lt;/code&gt;的方式创建对象，很不方便，还是提供属性的&lt;code&gt;Getter&lt;/code&gt;/&lt;code&gt;Setter&lt;/code&gt;方法更好些，听到他这样抱怨的时候我还花了点时间给他讲了采用这种方式创建对象的好处——这种对象创建的方式是为了保护对象在创建之后就不允许被更改。同时也想到这么好的设计模式时很值得学习的，且做个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/categories/java/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
      <category term="设计模式" scheme="xn--4gq28lcrm21g.cc/dist/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal剖析</title>
    <link href="xn--4gq28lcrm21g.cc/article/2017/12/20/2017-12-20-ThreadLocal%E5%89%96%E6%9E%90/"/>
    <id>xn--4gq28lcrm21g.cc/article/2017/12/20/2017-12-20-ThreadLocal剖析/</id>
    <published>2017-12-20T10:46:57.000Z</published>
    <updated>2020-06-06T17:47:36.791Z</updated>
    
    <content type="html"><![CDATA[<p>ThrealLocal顾名思义是提供在当前线程内存中增加并操作对象的一个工具类，也即是对当前线程内存空间的一个掌控，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定[1]。对象的绑定或者隐射很容易就让人想到这事Map类型的操作，ThreadLocal中的确对象的绑定是通过map的方式，只不过并没有直接使用到jdk中常用Map的实现。通过阅读源码，让我再一次重温了引用(Reference)[2]相关的知识。</p><a id="more"></a><p><em>以下分析基于jdk1.8</em></p><h1 id="ThreadLocal对象的唯一性"><a href="#ThreadLocal对象的唯一性" class="headerlink" title="ThreadLocal对象的唯一性"></a>ThreadLocal对象的唯一性</h1><p>既然对象是绑定在线程上，基于Map的设计思想，线程作为Key，绑定的对象为Value，即必须保证Key在绑定关系表上是唯一性的，ThreadLocal通过三个简单的属性轻松解决了这个问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每产生一个ThreadLocal实例，就更新下一次的 hashCode</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原子操作(CAS)并自动更新产生下一个 hashCode，保证唯一性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">// hashCode 每次更新增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get and update</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以知道第一个ThreadLocal实例的hashCode为0(hashCode的数据类型为 int), 增量是 0x61c88647, 这已经是一个很大的数了，也就是说即之后第 N个 ThreadLocal实例的 hashCode为 <code>(N-1)*0x61c88647</code>, 但第二个ThreadLocal的实例就已经超过 <code>Integer.MAX_VALUE</code>了，也就是数据范围溢出了，回到Map的设计思想上来，我们都知道HashMap为什么一般使用String作为Key就是因为String的Hash算法在去重上面足够严谨（这里就不讨论了，毕竟扩展太多），也就是说，这个增量肯定是有考究的，也就考虑到在该hashCode值溢出的情况下仍能尽量保证不重复（重复是必然的，毕竟int存储范围也就 Integer.MIN_VALUE[-2147483648]~Integer.MAX_VALUE[2147483647]），通过实际计算也证明了这是一个很具有魔力的数字。既然知道了意图，那就验证一下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = Integer.MAX_VALUE &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span>(; n &lt; size; n++) &#123;</span><br><span class="line">        set.add(nextHashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"n: "</span> + n + <span class="string">", size: "</span> + set.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法有点笨，不敢size直接等于Integer.MAX_VALUE，在尝试降到 <code>33554431(Integer.MAX_VALUE &gt;&gt; 6)</code>（此时堆的使用达到近 3.5个G，再翻个番我机器就要受不鸟了）的情况下仍能保证唯一性（数学好的可以从数学维度上给点提示，先感谢），即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n: 33554431, size: 33554431</span><br></pre></td></tr></table></figure></p><h1 id="ThreadLocal详情"><a href="#ThreadLocal详情" class="headerlink" title="ThreadLocal详情"></a>ThreadLocal详情</h1><p>保证了ThreadLocal对象（即Map的Key）hashCode的唯一性，作为其值（Value）的生命周期应与键（Key）一致，ThreadLocal中用来保存对象的类型是<code>ThreadLocal.ThreadLocalMap.Entry</code>，这个<code>Entry</code>继承<code>java.lang.ref.WeakReference&lt;T&gt;</code>即弱引用，且将ThreadLocal对象作为弱引用类型<code>T</code>，弱引用的性质就是当它没有被引用时就立即清除，而对ThreadLocalMap对象的引用是属于Thread对象中的属性，故Thread对象被destory之后该引用即失效，从而达到能被及时清除的效果。而ThradLocalMap是ThreadLocal的内部静态类，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ThreadLocal的构造方法"><a href="#ThreadLocal的构造方法" class="headerlink" title="ThreadLocal的构造方法"></a>ThreadLocal的构造方法</h2><p>构造方法体中内容为空，却注释让我们查看<code>#withInitial(java.util.function.Supplier)</code>，即除了通过<code>new ThreadLocal()</code>的方式，还可以通过调用 ThreadLocal的静态方法<code>public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier)</code>获取ThreadLocal实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a thread local variable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #withInitial(java.util.function.Supplier)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Supplier(@FunctionalInterface)即为ThreadLocal绑定对象的产生器(since 1.8)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在对ThreadLocal绑定的对象的set/get方法处理上：</p><h2 id="ThreadLocalMap的”put”"><a href="#ThreadLocalMap的”put”" class="headerlink" title="ThreadLocalMap的”put”"></a>ThreadLocalMap的”put”</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  @Thread#ThreadLocal.ThreadLocalMap threadLocals = null; threadLocals是Thread对象中的一个 "friendly"的属性。</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map.set(this, value) </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">            e != <span class="keyword">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ThreadLocalMap.nextIndex(i, len)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// replaceStaleEntry(key, value, i)</span></span><br><span class="line"><span class="comment">// 有点长，略</span></span><br></pre></td></tr></table></figure><p>ThreadLocalMap也是通过数组<code>Entry[] table</code>的方式存放（初始化容量是16，在ThreadLocalMap对象实例化的时候指定），通过ThreadLocal的 hashCode确定对象存放的位置，与HashMap不同的是，在Hash冲突的时候，通过环的方式，从hash到的位置开始，一次向后遍历，如果发现有空的位置（可能是本来就为空的位置，或者已经过期的线程占有的位置）就将这个值存放进去（这里用的是 replace）。<strong>每有一个Entry加入，都要重新检查并调整数组的结构</strong>，即先清理一些已经无效的Entry，<strong>当ThreadLocal中没有绑定对象了，这个Entry会被认为是无效的</strong>，<strong>如果ThreadLocal引用已经失效了，但对应的Entry仍存在，则也需要将这个Entry标识为失效</strong>，失效的Entry占有的位置将会被清理出来，这也就是所谓的”启发式的垃圾清理”；<strong>当数组中的元素达到数组容量的2/3（即容量的阈值，参考Collection结构的阈值）时，对数组进行rehash，在rehash过程中又会进行一次”垃圾清理”，清理过后如果size还大于阈值的3/4，则会对存储的数组扩容。</strong></p><h2 id="ThreadLocalMap的”get”"><a href="#ThreadLocalMap的”get”" class="headerlink" title="ThreadLocalMap的”get”"></a>ThreadLocalMap的”get”</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map.getEntry(this) </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get</code>方法，先通过<code>Thread.currentThread()</code>获取到当前线程，通过<code>getMap(t)</code>取得当前线程具有的 ThreadLocalMap对象，然后根据hash到table中获取这个Entry，如果发现没找到，即可能在容量有变更的情况下（resize过），采取<code>getEntryAfterMiss</code>的方式，从应该出现的位置开始依次遍历查找，这里需要注意的是，每次遍历到<code>k</code>为null的情况下，都会进行一次<code>expungeStaleEntry(i)</code>操作。如果<code>getMap(t)</code>获取到的值为null的情况，即还没调用<code>set</code>的情况下先<code>get</code>了，则会通过<code>setInitialValue()</code>方法进行初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();   <span class="comment">// initialValue() 方法是提供给 ThreadLocal子类实现的初始化方法</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即主要是创建 ThreadLocalMap对象，并把这个对象赋给当前线程的<code>threadLocals</code>变量。</p><h2 id="ThreadLocalMap的”remove”"><a href="#ThreadLocalMap的”remove”" class="headerlink" title="ThreadLocalMap的”remove”"></a>ThreadLocalMap的”remove”</h2><p>ThreadLocal的remove方法会触发ThreadLocalMap的<code>remove(ThreadLocal)</code>方法，这样就会将该Entry&lt;ThreadLocal, Object&gt;从ThreadLocalMap的table中清除。关于remove的描述:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the current thread's value for this thread-local</span></span><br><span class="line"><span class="comment">     * variable.  If this thread-local variable is subsequently</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span></span><br><span class="line"><span class="comment">     * reinitialized by invoking its &#123;<span class="doctag">@link</span> #initialValue&#125; method,</span></span><br><span class="line"><span class="comment">     * unless its value is &#123;<span class="doctag">@linkplain</span> #set set&#125; by the current thread</span></span><br><span class="line"><span class="comment">     * in the interim.  This may result in multiple invocations of the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> initialValue&#125; method in the current thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"># InheritableThreadLocal</span><br><span class="line">在ThreadLocal的`getMap(t)`方法中可以知道`threadLocals`是Thread类的属性，与`threadLocals`属性并列的还有`inheritableThreadLocals`，InheritableThreadLocal是ThreadLocal的子类，通过名称也可以推断出来，与ThreadLocal不同的是，**InheritableThreadLocal允许一个线程以及该线程创建的所有子线程都可以访问它保存的值。**对应的，TheadLocal中也有创建InheritableThreadLocal的静态方法，且创建的对象会包含其父线程中具有的 ThreadLocalMap数据。</span><br><span class="line">```java</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>ThreadLocal是提供放置一个同一个线程在任何时候访问结果都是一致的本地变量的工具。</li><li>线程结束，ThreadLocalMap新的元素set、set(null)，remove()被调用，等情况都会导致ThreadLocalMap中的Entry对象被标识为staled(过期)，从而会在新元素插入时被清理。</li></ul><p>ThreadLocal使用到的场景很多，主要是可以用它来取代方法调用之间使用的传参传递线程中需要用到的参数，譬如单机应用的requestNo的传递，分布式锁的使用场景[3]（即在释放锁操作中通过验证该锁是否为当前线程获取的锁来判断本次锁的释放是否拥有权限，如果不是当前线程获取的锁，那当前线程就没有权限去释放这个锁）。</p><p>参考：<br>[1] <a href="http://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/" title="借鉴-sczyh30的表述" target="_blank" rel="noopener">并发编程 | ThreadLocal源码深入分析</a><br>[2] <a href="/article/2018/01/26/2018-01-26-Java引用类型/" title="站内文章-Java引用类型">引用类型</a><br>[3] <a href="/article/2018/01/23/2018-01-23-Redis实现分布式锁/" title="站内文章-Redis实现分布式锁">Redis实现分布式锁</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ThrealLocal顾名思义是提供在当前线程内存中增加并操作对象的一个工具类，也即是对当前线程内存空间的一个掌控，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定[1]。对象的绑定或者隐射很容易就让人想到这事Map类型的操作，ThreadLocal中的确对象的绑定是通过map的方式，只不过并没有直接使用到jdk中常用Map的实现。通过阅读源码，让我再一次重温了引用(Reference)[2]相关的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/categories/java/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
      <category term="jdk阅读计划" scheme="xn--4gq28lcrm21g.cc/dist/tags/jdk%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92/"/>
    
      <category term="Thread" scheme="xn--4gq28lcrm21g.cc/dist/tags/Thread/"/>
    
      <category term="ThreadLocal" scheme="xn--4gq28lcrm21g.cc/dist/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>HashMap剖析</title>
    <link href="xn--4gq28lcrm21g.cc/article/2017/12/13/2017-12-13-HashMap%E5%89%96%E6%9E%90/"/>
    <id>xn--4gq28lcrm21g.cc/article/2017/12/13/2017-12-13-HashMap剖析/</id>
    <published>2017-12-13T02:17:40.000Z</published>
    <updated>2020-06-08T13:48:25.114Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap在Java中除了集合(Collection)类型应该是用得最多的处理K-V（键值对）映射关系数据的数据结构，如其名HashMap，其中比较重要的”Hash”部分即为了表示元素被哈希存储到指定位置，也通过哈希去重，譬如HashSet所用的存储方案就是通过HashMap的key部分存储元素，而所有value都是一个空对象(<code>private static final Object PRESENT = new Object();</code>).对于一个出现频率极高的数据结构，了解其底层实现有助于更优雅、高效地使用它。<br><a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>几乎所有Key-Value结构的数据结构都实现<code>java.util.Map&lt;K, V&gt;</code>接口，且实现对键值对的集合常用的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">size()</span><br><span class="line">isEmpty()</span><br><span class="line">containsKey(Object)</span><br><span class="line">containsValue(Object)</span><br><span class="line">get(Object)</span><br><span class="line">put(K, V)</span><br><span class="line">putAll(Map&lt;K, V&gt;)</span><br><span class="line">remove(Object)</span><br><span class="line">clear()</span><br><span class="line">keySet()</span><br><span class="line">values()</span><br><span class="line">entrySet()</span><br></pre></td></tr></table></figure></p><p>而在jdk中Map的实现主要有以下几种：HashMap, LinkedHashMap, TreeMap, WeakHash, Ident ityHashMap, 继承字典的 Hashtable和 Properties, 以及并发包下的实现 ConcurrentHashMap以及 ConcurrentSkipListMap.<br><img src="/images/coding/Map-Class-Diagram.png" alt="Map-Class-Diagram" title="JDK中Map类继承关系图"></p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap作为最常用的K-V数据结构，</p><h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><h1 id="ConcurrentMap"><a href="#ConcurrentMap" class="headerlink" title="ConcurrentMap"></a>ConcurrentMap</h1><h1 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap在Java中除了集合(Collection)类型应该是用得最多的处理K-V（键值对）映射关系数据的数据结构，如其名HashMap，其中比较重要的”Hash”部分即为了表示元素被哈希存储到指定位置，也通过哈希去重，譬如HashSet所用的存储方案就是通过HashMap的key部分存储元素，而所有value都是一个空对象(&lt;code&gt;private static final Object PRESENT = new Object();&lt;/code&gt;).对于一个出现频率极高的数据结构，了解其底层实现有助于更优雅、高效地使用它。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/categories/java/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
      <category term="jdk阅读计划" scheme="xn--4gq28lcrm21g.cc/dist/tags/jdk%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92/"/>
    
      <category term="HashMap" scheme="xn--4gq28lcrm21g.cc/dist/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>盘点一下JDK中的那些工具类-Math</title>
    <link href="xn--4gq28lcrm21g.cc/article/2017/11/01/2017-11-01-%E7%9B%98%E7%82%B9%E4%B8%80%E4%B8%8BJDK%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB-Math/"/>
    <id>xn--4gq28lcrm21g.cc/article/2017/11/01/2017-11-01-盘点一下JDK中的那些工具类-Math/</id>
    <published>2017-11-01T03:34:43.000Z</published>
    <updated>2020-06-06T17:47:36.791Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/categories/java/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>盘点一下JDK中的那些工具类-Collectors</title>
    <link href="xn--4gq28lcrm21g.cc/article/2017/11/01/2017-11-14-%E7%9B%98%E7%82%B9%E4%B8%80%E4%B8%8BJDK%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB-Collectors/"/>
    <id>xn--4gq28lcrm21g.cc/article/2017/11/01/2017-11-14-盘点一下JDK中的那些工具类-Collectors/</id>
    <published>2017-11-01T03:21:01.000Z</published>
    <updated>2020-06-06T17:47:36.791Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/categories/java/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>盘点一下JDK中的那些工具类-Collections</title>
    <link href="xn--4gq28lcrm21g.cc/article/2017/11/01/2017-11-07-%E7%9B%98%E7%82%B9%E4%B8%80%E4%B8%8BJDK%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB-Collections/"/>
    <id>xn--4gq28lcrm21g.cc/article/2017/11/01/2017-11-07-盘点一下JDK中的那些工具类-Collections/</id>
    <published>2017-11-01T03:20:46.000Z</published>
    <updated>2020-06-06T17:47:36.791Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/categories/java/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>盘点一下JDK中的那些工具类-Arrays</title>
    <link href="xn--4gq28lcrm21g.cc/article/2017/11/01/2017-11-01-%E7%9B%98%E7%82%B9%E4%B8%80%E4%B8%8BJDK%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB-Arrays/"/>
    <id>xn--4gq28lcrm21g.cc/article/2017/11/01/2017-11-01-盘点一下JDK中的那些工具类-Arrays/</id>
    <published>2017-11-01T03:20:38.000Z</published>
    <updated>2020-06-06T17:47:36.787Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.util.Arrays</code>工具类是对集合操作的工具集合，其中包含的工具主要有排序，查找，比较，填充，拷贝，计算Hash值，集合转字符串，枚举，以及集合转流。作为一个工具类，它的构造方法为私有，这样就避免了工具方法被用户实例化的尴尬，同时，它的工具方法都是公开的静态方法。</p><a id="more"></a><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>数组的排序是编程界比较基础的算法，Arrays提供常用数据类型byte, char, short, int, long, double的排序方法，同时提供实现了<code>Comparable</code>的类型数组的排序，以及能通过<code>Comparator</code>外排序类型的数组的排序。所有通过<code>sort</code>排序的结果都为升序(ascending numerical order).排序方法的实现采用<strong>双枢轴快速排序</strong>(1.7)，时间复杂度为<code>O(n log(n))</code>.除了一半的排序实现，在jdk1.8中，提供了并行排序的方法实现<code>parallelSort</code>，在需要排序的数组长度小于等于8192时仍采用以上单线程(串行)排序算法实现，当需要排序的数组长度大于8192时则采用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;java.util.Arrays&lt;/code&gt;工具类是对集合操作的工具集合，其中包含的工具主要有排序，查找，比较，填充，拷贝，计算Hash值，集合转字符串，枚举，以及集合转流。作为一个工具类，它的构造方法为私有，这样就避免了工具方法被用户实例化的尴尬，同时，它的工具方法都是公开的静态方法。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/categories/java/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Maven生命周期</title>
    <link href="xn--4gq28lcrm21g.cc/article/2017/10/16/2017-10-16-Maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>xn--4gq28lcrm21g.cc/article/2017/10/16/2017-10-16-Maven生命周期/</id>
    <published>2017-10-16T12:08:23.000Z</published>
    <updated>2020-06-07T15:05:05.966Z</updated>
    
    <content type="html"><![CDATA[<p>Maven生命周期。</p><a id="more"></a><h2 id="maven生命周期"><a href="#maven生命周期" class="headerlink" title="maven生命周期"></a>maven生命周期</h2><ol><li>process-resources# resources:resources</li></ol><p>复制<code>src/main/resources</code>下的文件到<code>target/resources</code>目录下</p><p>compile# compiler:compile</p><blockquote><p>process-classes<br>process-test-resources# resources:testResources<br>test-compile<br>test-compile<br>test<br>prepare-package<br>package</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Maven生命周期。&lt;/p&gt;
    
    </summary>
    
      <category term="maven" scheme="xn--4gq28lcrm21g.cc/dist/categories/maven/"/>
    
    
      <category term="maven" scheme="xn--4gq28lcrm21g.cc/dist/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Object中的wait/notify</title>
    <link href="xn--4gq28lcrm21g.cc/article/2017/10/13/2017-10-13-Object%E4%B8%AD%E7%9A%84wait-notify/"/>
    <id>xn--4gq28lcrm21g.cc/article/2017/10/13/2017-10-13-Object中的wait-notify/</id>
    <published>2017-10-13T06:34:45.000Z</published>
    <updated>2020-06-06T17:47:36.787Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的基类Object中，有 <code>notify()</code>, <code>notifyAll()</code>, <code>wait(long)</code>, <code>wait(long, int)</code>, <code>wait()</code>方法，在非Thread类型中，可以通过这些方法实现多线程之间的通信和互斥。</p><a id="more"></a><p>在以上方法中，前三个为native实现，<code>wait(long, int)</code>和<code>wait()</code>是对<code>wait(long)</code>的拓展，其中<code>wait()</code>即是<code>wait(0)</code>，而<code>wait(long, int)</code>第二个int类型参数是传入纳秒值，实际情况是当该值大于0的情况下，第一个long型参数值加一，并不会具体实现纳秒级的wait操作。<br>对象的<code>wait</code>操作会引起当前线程让出锁，直到该对象的<code>notify</code>或<code>notifyAll</code>被调用，或者<code>wait</code>操作传入的时间过期之后才会重新竞争锁，并在获取到锁之后再继续执行。<strong>换一种说法就是调用<code>wait()</code>方法的线程必须在一个已获取到锁的代码块中调用</strong>。按理来说，在<code>synchronized</code>代码块中能保持属于的一致性，但是在同步代码块中有被锁的对象调用<code>wait()</code>的情况下，在被锁对象调用<code>wait()</code>方法时候会释放掉已拥有的锁，在再次获取到锁之后继续执行，也就是说，在有被锁对象的<code>wait()</code>操作的同步代码块中，从<code>wait()</code>操作到同步代码块结束才是一个单位的操作，<strong>所以如果在同步代码块中被锁对象调用<code>wait()</code>方法之前对该对象进行的更改都属于非法的操作</strong>，即无法保证操作的一致性，但它的其他操作确实允许的，因为该<code>synchronized</code>只对被锁的对象保证线程安全。<br>如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> Integer obj = Integer.valueOf(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> Integer ext = Integer.valueOf(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoWaitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line"><span class="comment">//                  obj++;  // 该操作会在obj调用wait时引起 IllegalMonitorStateException 异常</span></span><br><span class="line">                    ext++;</span><br><span class="line">                    System.out.println(<span class="string">"DoWaitThread: before wait... obj="</span> + obj + <span class="string">", ext="</span> + ext);</span><br><span class="line">                    obj.wait();</span><br><span class="line">                    obj++;</span><br><span class="line">                    ext++;</span><br><span class="line">                    System.out.println(<span class="string">"DoWaitThread: after wait... obj="</span> + obj + <span class="string">", ext="</span> + ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"DoWaitThread: exception occurred"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoNotifyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"DoNotifyThread: before notify... obj="</span> + obj + <span class="string">", ext="</span> + ext);</span><br><span class="line">                    obj.notifyAll();    <span class="comment">// 该通知释放锁是要在该同步块结束之后才会正式释放锁，若无该操作则DoWaitThread的wait之后的操作仍继续等待。</span></span><br><span class="line">                    obj++;</span><br><span class="line">                    ext++;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"DoNotifyThread: after notify... obj="</span> + obj + <span class="string">", ext="</span> + ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"DoNotifyThread: exception occurred"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWaitNotify</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread w = <span class="keyword">new</span> DoWaitThread();</span><br><span class="line">        Thread n = <span class="keyword">new</span> DoNotifyThread();</span><br><span class="line">        w.start();</span><br><span class="line">        n.start();</span><br><span class="line">        w.join();</span><br><span class="line">        n.join();</span><br><span class="line">        System.out.println(<span class="string">"obj="</span> + obj + <span class="string">", ext="</span> + ext);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>以上测试执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DoWaitThread: before wait... obj=0, ext=1</span><br><span class="line">DoNotifyThread: before notify... obj=0, ext=1</span><br><span class="line">DoNotifyThread: after notify... obj=1, ext=2</span><br><span class="line">DoWaitThread: after wait... obj=2, ext=3</span><br><span class="line">obj=2, ext=3</span><br></pre></td></tr></table></figure></p><p>可见是在DoWaitThread中<code>obj.wait()</code>之后就让出了锁，由DoNotifyThread获取到锁，在DoNotifyThread中notify，当DoNotifyThread释放锁之后，DoWaitThread继续执行。如果注释掉DoNotifyThread中的<code>obj.notifyAll();</code>则DoWaitThread将一直处于等待状态。如果将DoWaitThread中的<code>wait()</code>替换成<code>wait(2000L)</code>,则在DoNotifyThread执行完之后，DoWaitThread可再次获取到锁，并在超时之后继续执行。如果DoWaitThread中的<code>wait()</code>替换成<code>wait(500L)</code>，即DoWaitThread可在DoNotifyThread还未获取到锁之前等待时间超时，则可再获取到锁，则其执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DoWaitThread: before wait... obj=0, ext=1</span><br><span class="line">DoWaitThread: after wait... obj=1, ext=2</span><br><span class="line">DoNotifyThread: before notify... obj=1, ext=2</span><br><span class="line">DoNotifyThread: after notify... obj=2, ext=3</span><br><span class="line">obj=2, ext=3</span><br></pre></td></tr></table></figure></p><blockquote><p>Object的<code>wait()</code>方法的线程需在该对象上锁的情况下被调用。<br>notify是唤醒单个正在等待中的线程，如果有多个线程正在等待，则值唤醒一个，而notifyAll是唤醒所有等待的线程，且不管会由哪个线程能竞争到该对象的锁。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中的基类Object中，有 &lt;code&gt;notify()&lt;/code&gt;, &lt;code&gt;notifyAll()&lt;/code&gt;, &lt;code&gt;wait(long)&lt;/code&gt;, &lt;code&gt;wait(long, int)&lt;/code&gt;, &lt;code&gt;wait()&lt;/code&gt;方法，在非Thread类型中，可以通过这些方法实现多线程之间的通信和互斥。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/categories/java/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
      <category term="thread" scheme="xn--4gq28lcrm21g.cc/dist/tags/thread/"/>
    
      <category term="jdk阅读计划" scheme="xn--4gq28lcrm21g.cc/dist/tags/jdk%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Java关于线程的小知识</title>
    <link href="xn--4gq28lcrm21g.cc/article/2017/10/10/2017-10-10-Java%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>xn--4gq28lcrm21g.cc/article/2017/10/10/2017-10-10-Java关于线程的小知识/</id>
    <published>2017-10-10T02:52:28.000Z</published>
    <updated>2020-06-06T17:47:36.787Z</updated>
    
    <content type="html"><![CDATA[<p>关于<code>Thread</code>的一些tips。</p><a id="more"></a><h1 id="处理未捕捉的异常"><a href="#处理未捕捉的异常" class="headerlink" title="处理未捕捉的异常"></a>处理未捕捉的异常</h1><p>在JVM运行时，当一个线程抛出一个运行时异常，JVM是怎么处理这个异常的，遇到这种情况，这种“漏网”的异常又该怎么正确处理。我们可以通过实现<code>UncaghtExceptionHandler</code>接口，处理用户未catch，且逃脱到JVM的异常。首先声明<code>UncaghtExceptionHandler</code>的实现类，将该<code>Handler</code>注册到程序中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread.UncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"Thead: name[%s], status[%s] \n"</span>, t.getName(), t.getState());</span><br><span class="line">            System.out.printf(<span class="string">"Exception: [%s] \n"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExceptionThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"Thread [%s] is running. \n"</span>, getName());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Man made exception for "</span> + getName() + <span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> ExceptionThread(<span class="string">"sama"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>以上通过<code>Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</code>向程序中注册默认的未捕捉异常处理Handler，其运行结果如下，可以看到在<code>MyUncaughtExceptionHandler</code>中对未手动<code>catch</code>到的异常信息进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">main thread terminated.</span><br><span class="line">Thread [sama0] is running. </span><br><span class="line">Thead: name[sama0], status[RUNNABLE] </span><br><span class="line">Exception: [Man made exception for sama0.] </span><br><span class="line">Thread [sama5] is running. </span><br><span class="line">Thead: name[sama5], status[RUNNABLE] </span><br><span class="line">Exception: [Man made exception for sama5.] </span><br><span class="line">Thread [sama4] is running. </span><br><span class="line">Thead: name[sama4], status[RUNNABLE] </span><br><span class="line">Exception: [Man made exception for sama4.] </span><br><span class="line">Thread [sama3] is running. </span><br><span class="line">Thread [sama2] is running. </span><br><span class="line">Thead: name[sama2], status[RUNNABLE] </span><br><span class="line">Exception: [Man made exception for sama2.] </span><br><span class="line">Thread [sama1] is running. </span><br><span class="line">Thead: name[sama3], status[RUNNABLE] </span><br><span class="line">Exception: [Man made exception for sama3.] </span><br><span class="line">Thead: name[sama1], status[RUNNABLE] </span><br><span class="line">Exception: [Man made exception for sama1.]</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="What-is-a-shutdown-hook"><a href="#What-is-a-shutdown-hook" class="headerlink" title="What is a shutdown hook?"></a>What is a shutdown hook?</h1><p>“终止钩子”是什么，终止钩子是在JVM终止运行时会执行的一个线程，它可以通过获取运行时环境的<code>addShutdownHook(Thread)</code>添加，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestShutdownHook</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">"Sleep thread execute over."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">        runtime.addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"The first shutdown hook executing."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        runtime.addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"The second shutdown hook executing."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> SleepThread().start();</span><br><span class="line">        System.out.println(<span class="string">"main thread execute over."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>运行结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main thread execute over.</span><br><span class="line">Sleep thread execute over.</span><br><span class="line">The first shutdown hook executing.</span><br><span class="line">The second shutdown hook executing.</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>如果将第一个hook thread的休眠时间设的比第二个长，则执行结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main thread execute over.</span><br><span class="line">Sleep thread execute over.</span><br><span class="line">The second shutdown hook executing.</span><br><span class="line">The first shutdown hook executing.</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>因为<code>Runtime.addShutdownHook(Thread)</code>中，是调用<code>ApplicationShutdownHooks.add(Thread)</code>将Hook Thread添加到<code>IdentityHashMap&lt;Thread, Thread&gt; hooks</code>中，而执行终止钩子线程的方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runHooks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;Thread&gt; threads;</span><br><span class="line">    <span class="keyword">synchronized</span>(ApplicationShutdownHooks<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        threads = hooks.keySet();</span><br><span class="line">        hooks = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        hook.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hook.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException x) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>是将所有的终结钩子线程一起启动，然后通过<code>join()</code>等待他们都执行完成，<code>runHooks()</code>才结束。</p></blockquote><h1 id="Thread-amp-Runnable"><a href="#Thread-amp-Runnable" class="headerlink" title="Thread &amp; Runnable"></a>Thread &amp; Runnable</h1><p>继承Thread或实现Runnable并将实现传入Thread都可以声明一个线程，不同的是，调用Runnable的<code>run()</code>方法是不会起一个线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadRunnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"thread01"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"this is thread01. name: "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="string">"thread02"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"this is thread02. name: "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它的执行结果如下，可知在调用Runnable的<code>run()</code>方法，在<code>run()</code>方法体内获取到的当前线程还是主线程 main，所以正确的启动一个线程的方法是调用Thread的<code>start()</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this is thread01. name: thread01</span><br><span class="line">this is thread02. name: main</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于&lt;code&gt;Thread&lt;/code&gt;的一些tips。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/categories/java/"/>
    
    
      <category term="java" scheme="xn--4gq28lcrm21g.cc/dist/tags/java/"/>
    
      <category term="Thread" scheme="xn--4gq28lcrm21g.cc/dist/tags/Thread/"/>
    
  </entry>
  
</feed>
